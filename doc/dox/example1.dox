/**
\page ex_1

\section ex_1 First example

Example of query pattern

\subsection ex_1_file File structure

Example of standard communication object:

 - commExampleTime.cc    : Implementation of communication object for
                           transmitting time
 - commExampleTime.hh    : Headerfile of communication object for transmitting
                           time
 - exampleTime.idl       : IDL description of the data structure which
                           transmits time within the above communication object

Example of communication object with STL data structures at the user interface:

  - commExampleValues.cc : Implementation of communication object for transmitting
                           list of values
  - commExampleValues.hh : Headerfile of the above communication object
  - exampleValues.idl    : IDL description of the transmitted data structure


Another standard communication object:

  - commExampleResult.cc
  - commExampleResult.hh
  - exampleResult.idl


\subsection ex_1_comm What is inside the communication objects?

Communication objects wrap the data to be transmitted by the communication
patterns. For the user it looks like the communication patterns transmit
instances of communication objects. At the implementational level, only
the data structure inside a communication object is transmitted. These
data structures are described by IDL.

IDL description for time of day:
\dontinclude exampleTime.idl
\skip user
\until

Therefore the content of a communication object is platform
independent. When transmitting a communication object, it is newly
created within the receiving component.

Communication objects provide various methods to access their content. These
methods can use every kind of data structures like STL containers etc. and are
not restricted to CORBA types. In particular the user of a communication object
has not at all to deal with CORBA types.

The user data types are transmitted via any types between the server and the
client part of a communication pattern. This allows to completely specify the
internal interface of the communication patterns without knowing what kind of
user data is transmitted. This in particular supports the chosen template based
implementation.

To allow the templates to extract the user data structure of a communication
object, every communication object has to provide a "get" and a "set" as can
be seen in the examples. These convert the user data structure into an any
type by using the <<= and the >>= operator. These operators are automatically
generated by the IDL compiler for the IDL described user data structures.

Currently no abstract communication object is specified which enforces the
implementation of the "set" and "get" method. This is not a big issue since
the compiler detects missing methods when trying to expand the communication
pattern templates.

declaration of time of day communication object:
\dontinclude commExampleTime.hh
\skip Example
\until siudfhiusdgfisduzhfoiwezr87345e76t8q734t5

definition of time of day communication object:
\dontinclude commExampleTime.cc
\skip include
\until sadf7382r687gisdfw34

Example Component that includes two servers
\dontinclude smartExampleComponent1.cc
\skip include
\until i3874tziugf8a7ewjgtfiweag

Client for that Component

\dontinclude smartExampleComponent2.cc
\skip include
\until suagf87t4riuagwe
*/
