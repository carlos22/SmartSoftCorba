// --------------------------------------------------------------------------
//
//  Copyright (C) 2002/2004 Christian Schlegel
//
//        schlegel@hs-ulm.de
//
//        Prof. Dr. Christian Schlegel
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Communication Library".
//  It provides standardized patterns for communication between
//  different components.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
//  (partly based on joint work with Robert Wörz)
//
// --------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// client part of event template
//
/////////////////////////////////////////////////////////////////////////

//
// static handle method called by CORBA object
//
template<class P, class E> void CHS::EventClient<P,E>::hndEvent(void* ptr,const CORBA::Any& user,const CORBA::Long cltId)
{
  EventClient<P,E> *lthis = (EventClient<P,E> *)ptr;
  EventClientList  *lptr;

  //
  // hint: mutexConnection need not be acquired here since client can not get
  //       disconnected or destroyed while this handler is being executed. The
  //       server posseses the mutexClientList all the time this handler is being
  //       executed. Since this mutex is also needed to finish a disconnect, this
  //       handler is first finished for sure before a disconnect is executed.
  //
  //       Acquiring mutexConnection in handlers can even result in deadlocks.
  //       Calling queryRequest holds the mutexConnection and a concurrent call
  //       to the answer member function at the server holds the counterpart
  //       mutexClientList. Neither call can be finished if the handlers now
  //       also try to get the mutexConnection or the mutexClientList.
  //
  lthis->mutexEventList.acquire();

  for( lptr = lthis->events; lptr != 0; lptr = lptr->next )
    if( lptr->id == cltId )
      break;

  if( lptr != 0 ) {
    if (lptr->mode == single) {
      //
      // in single mode, we use the flags "eventAvailable" and "eventFired"
      //
      if (lptr->eventFired == 0) {
        // not yet fired
        lptr->eventAvailable = 1;
        lptr->eventFired     = 1;
        lptr->e.set(user);

        // always signal both condition variables since both are used ...
        lptr->condW.signal();
        lptr->condWO.signal();

        // if handler object is registrated, call it ...
        if (lthis->hndObject != 0) {
          lthis->hndObject->handleEvent(lptr->id, lptr->e);
        }
      } else {
        //
        // we should never reach this section since a single event
        // can only fire once and therefore we simply ignore this
        //
      }
    }
    if (lptr->mode == continuous) {
      //
      // in continuous mode, only the "eventAvailable" flag is needed
      //
      lptr->eventAvailable = 1;
      lptr->e.set(user);

      // always signal both condition variables since both are used ...
      lptr->condW.signal();
      lptr->condWO.signal();

      // if handler object is registrated, call it ...
      if (lthis->hndObject != 0) {
        lthis->hndObject->handleEvent(lptr->id, lptr->e);
      }
    }
  } else {
    //
    // do nothing since event has been received after event e.g. has been deactivated
    // and therefore corresponding entry does not exist any longer. Doesn't matter
    // since in this case no thread is waiting for the event since removing an entry
    // from the list of active events is only possible without having an active
    // blocking wait.
    //
  }

  lthis->mutexEventList.release();
}


//
// static handle method called by CORBA object
//
template<class P, class E> void CHS::EventClient<P,E>::hndServDisc(void* ptr)
{
  EventClient<P,E> *lthis = (EventClient<P,E> *)ptr;

  lthis->disconnect();
}


//
// static internal interface methods used by wiring service
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::internalConnect(void *ptr,const std::string & srv, const std::string & svc)
{
  EventClient<P,E>* lthis = (EventClient<P,E> *)ptr;

  return lthis->connect(srv,svc);
}


template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::internalDisconnect(void* ptr)
{
  EventClient<P,E>* lthis = (EventClient<P,E> *)ptr;

  return lthis->disconnect();
}


//
// private helper method to clean up list of events
//
template<class P,class E> CHS::StatusCode CHS::EventClient<P,E>::removeActivationId(const CHS::EventId id) throw()
{
  EventClientList *lptr  = 0;
  EventClientList *hlptr = 0;
  CHS::StatusCode  result;

  result = CHS::SMART_ERROR;

  mutexEventList.acquire();

  for (lptr = events; lptr != 0; lptr = lptr->next )
    if (lptr->id == id)
      break;

  if (lptr == 0) {
    result = CHS::SMART_WRONGID;
  } else {
    //
    // now delete list entry
    //
    // since we have already found an entry with the correct id, we know
    // that the entry is still in the list ... each id also occurs only
    // once in the list
    //
    if (id == events->id) {
      //
      // first entry in list therefore remove head of list ...
      //
      component->removeCV(&(lptr->condW));
      component->removeCV(&(lptr->condWO));

      lptr   = events;
      events = lptr->next;
      delete lptr;
    } else {
      //
      // not first entry in list, must therefore be second or later one ...
      //
      lptr = events;
      while (lptr->next != 0) {
        if (lptr->next->id == id) {
          hlptr      = lptr->next;
          lptr->next = lptr->next->next;
          component->removeCV(&(hlptr->condW));
          component->removeCV(&(hlptr->condWO));
          delete hlptr;
        } else {
          lptr = lptr->next;
        }
      }
    }
  }

  mutexEventList.release();

  return result;
}


//
// default constructor
//
template<class P, class E> inline CHS::EventClient<P,E>::EventClient(void) throw(CHS::SmartError)
{
  std::cerr << "CommPattern (event): ERROR: Entered default constructor EventClient" << std::endl;

  throw(CHS::SmartError(CHS::SMART_ERROR,"CommPattern (eventClient): ERROR: Entered default constructor EventClient"));
}

//
// standard constructor port
//
template<class P, class E> inline CHS::EventClient<P,E>::EventClient(SmartComponent* m,const std::string& port, WiringSlave* slave) throw(CHS::SmartError)
{
  CHS::StatusCode status;

  // set the configuration flags appropriately
  statusConnected    = 0;
  statusManagedPort  = 0;
  portname           = port;
  statusUserBlocking = true;
  eventCnt           = 0;
  events             = 0;
  hndObject          = 0;
  component          = m;
  wiringslave        = slave;

  // Create the CORBA client object
  corbaClient = new EventClient_impl((void *)this,&EventClient<P,E>::hndEvent,&EventClient<P,E>::hndServDisc);

  // activate object to obtain the object reference, need not be registered at name service
  // since object reference is sent to server with every event activation
  h = corbaClient->_this();

  status = this->add(slave, port);

  if (status == CHS::SMART_PORTALREADYUSED) {
    //
    // port name already in use therefore throw exception
    //
    throw(CHS::SmartError(CHS::SMART_PORTALREADYUSED,"CommPattern (eventClient): ERROR: port name already in use"));
  } else if (status != CHS::SMART_OK) {
    //
    // throw exception since something went wrong
    //
    throw(CHS::SmartError(CHS::SMART_ERROR,"CommPattern (eventClient): ERROR: something went wrong"));
  }
}

//
// standard constructor
//
template<class P,class E> inline CHS::EventClient<P,E>::EventClient(SmartComponent* m) throw (CHS::SmartError)
{
  // set the configuration flags appropriately
  statusConnected    = 0;
  statusManagedPort  = 0;
  portname           = "";
  statusUserBlocking = true;
  eventCnt           = 0;
  events             = 0;
  hndObject          = 0;
  component          = m;
  wiringslave        = 0;

  // Create the CORBA client object
  corbaClient = new EventClient_impl((void *)this,&EventClient<P,E>::hndEvent,&EventClient<P,E>::hndServDisc);

  // activate object to obtain the object reference, need not be registered at name service
  // since object reference is sent to server with every event activation
  h = corbaClient->_this();
}

//
// standard constructor already wired
//
template<class P,class E> inline CHS::EventClient<P,E>::EventClient(SmartComponent* m,const std::string& srv,const std::string& svc) throw (CHS::SmartError)
{
  CHS::StatusCode status;
  int flag;

  // set the configuration flags appropriately
  statusConnected    = 0;
  statusManagedPort  = 0;
  portname           = "";
  statusUserBlocking = true;
  eventCnt           = 0;
  events             = 0;
  hndObject          = 0;
  component          = m;
  wiringslave        = 0;

  // Create the CORBA client object
  corbaClient = new EventClient_impl((void *)this,&EventClient<P,E>::hndEvent,&EventClient<P,E>::hndServDisc);

  // activate object to obtain the object reference, need not be registered at name service
  // since object reference is sent to server with every event activation
  h = corbaClient->_this();

  // Now connect to the server side of the event pattern
  std::cout << "Try to connect to (" << srv << ":event<" << P::identifier() << "," << E::identifier() << ">:" << svc << ") ..." << std::endl;

  do {
    status = this->connect(srv,svc);

    if (status == CHS::SMART_OK) {
      flag = 1;
      std::cout << "... connected to (" << srv << ":event<" << P::identifier() << "," << E::identifier() << ">:" << svc << ")" << std::endl;
    } else if (status == CHS::SMART_SERVICEUNAVAILABLE) {
      std::cout << "CommPattern (eventClient): INFO: not yet found in naming service ..." << std::endl;
      sleep(1);
      flag = 0;
    } else if (status == CHS::SMART_INCOMPATIBLESERVICE) {
      std::cout << "CommPattern (eventClient): ERROR: incompatible service ..." << std::endl;
      flag = 1;
      throw(CHS::SmartError(status,"CommPattern (eventClient): ERROR: incompatible service"));
    } else {
      std::cout << "CommPattern (eventClient): ERROR: something went wrong ..." << std::endl;
      flag = 1;
      throw(CHS::SmartError(status,"CommPattern (eventClient): ERROR: something went wrong"));
    };
  } while (flag == 0);
}

//
// standard constructor port
//
template<class P, class E> inline CHS::EventClient<P,E>::EventClient(SmartComponent* m,const std::string& port, WiringSlave* slave,EventHandler<E>& hnd) throw(CHS::SmartError)
{
  CHS::StatusCode status;

  // set the configuration flags appropriately
  statusConnected    = 0;
  statusManagedPort  = 0;
  portname           = port;
  statusUserBlocking = true;
  eventCnt           = 0;
  events             = 0;
  hndObject          = &hnd;
  component          = m;
  wiringslave        = slave;

  // Create the CORBA client object
  corbaClient = new EventClient_impl((void *)this,&EventClient<P,E>::hndEvent,&EventClient<P,E>::hndServDisc);

  // activate object to obtain the object reference, need not be registered at name service
  // since object reference is sent to server with every event activation
  h = corbaClient->_this();

  status = this->add(slave, port);

  if (status == CHS::SMART_PORTALREADYUSED) {
    //
    // port name already in use therefore throw exception
    //
    throw(CHS::SmartError(CHS::SMART_PORTALREADYUSED,"CommPattern (eventClient): ERROR: port name already in use"));
  } else if (status != CHS::SMART_OK) {
    //
    // throw exception since something went wrong
    //
    throw(CHS::SmartError(CHS::SMART_ERROR,"CommPattern (eventClient): ERROR: something went wrong"));
  }
}

//
// standard constructor
//
template<class P,class E> inline CHS::EventClient<P,E>::EventClient(SmartComponent* m,EventHandler<E>& hnd) throw (CHS::SmartError)
{
  // set the configuration flags appropriately
  statusConnected    = 0;
  statusManagedPort  = 0;
  portname           = "";
  statusUserBlocking = true;
  eventCnt           = 0;
  events             = 0;
  hndObject          = &hnd;
  component          = m;
  wiringslave        = 0;

  // Create the CORBA client object
  corbaClient = new EventClient_impl((void *)this,&EventClient<P,E>::hndEvent,&EventClient<P,E>::hndServDisc);

  // activate object to obtain the object reference, need not be registered at name service
  // since object reference is sent to server with every event activation
  h = corbaClient->_this();
}

//
// standard constructor already wired
//
template<class P,class E> inline CHS::EventClient<P,E>::EventClient(SmartComponent* m,const std::string& srv,const std::string& svc,EventHandler<E>& hnd) throw (CHS::SmartError)
{
  CHS::StatusCode status;
  int flag;

  // set the configuration flags appropriately
  statusConnected    = 0;
  statusManagedPort  = 0;
  portname           = "";
  statusUserBlocking = true;
  eventCnt           = 0;
  events             = 0;
  hndObject          = &hnd;
  component          = m;
  wiringslave        = 0;

  // Create the CORBA client object
  corbaClient = new EventClient_impl((void *)this,&EventClient<P,E>::hndEvent,&EventClient<P,E>::hndServDisc);

  // activate object to obtain the object reference, need not be registered at name service
  // since object reference is sent to server with every event activation
  h = corbaClient->_this();

  // Now connect to the server side of the event pattern
  std::cout << "Try to connect to (" << srv << ":event<" << P::identifier() << "," << E::identifier() << ">:" << svc << ") ..." << std::endl;

  do {
    status = this->connect(srv,svc);

    if (status == CHS::SMART_OK) {
      flag = 1;
      std::cout << "... connected to (" << srv << ":event<" << P::identifier() << "," << E::identifier() << ">:" << svc << ")" << std::endl;
    } else if (status == CHS::SMART_SERVICEUNAVAILABLE) {
      std::cout << "CommPattern (eventClient): INFO: not yet found in naming service ..." << std::endl;
      sleep(1);
      flag = 0;
    } else if (status == CHS::SMART_INCOMPATIBLESERVICE) {
      std::cout << "CommPattern (eventClient): ERROR: incompatible service ..." << std::endl;
      flag = 1;
      throw(CHS::SmartError(status,"CommPattern (eventClient): ERROR: incompatible service"));
    } else {
      std::cout << "CommPattern (eventClient): ERROR: something went wrong ..." << std::endl;
      flag = 1;
      throw(CHS::SmartError(status,"CommPattern (eventClient): ERROR: something went wrong"));
    };
  } while (flag == 0);
}

//
// destructor
//
template<class P,class E> inline CHS::EventClient<P,E>::~EventClient(void) throw()
{
  EventClientList *lptr = 0;

  //
  // remove port from managed set of ports and disconnect from server even if not
  // exposed as port or connected to a server since this is handled correctly inside
  // remove() and disconnect(). Disconnect automatically deactivates all still active
  // events.
  //
  this->remove();
  this->disconnect();

  // free memory
  mutexEventList.acquire();
  while ( events != 0 ) {
    lptr = events;
    events = events->next;
    delete lptr;
  }
  mutexEventList.release();

  // client does not bind object at naming service,
  // therefore no unbind of objects needed here


  // ### delete/deactivate the corbaServant object (Christian Schlegel)
}

//
//
//
template<class P,class E> CHS::StatusCode CHS::EventClient<P,E>::add(WiringSlave* slave, const std::string& port) throw()
{
  CHS::StatusCode status;

  mutexConnection.acquire();

  // first remove eventually valid registration
  this->remove();

  // now add client
  portname          = port;
  statusManagedPort = 1;

  wiringslave = slave;
  status      = this->wiringslave->add(port, (void*)this, &EventClient<P,E>::internalConnect, &EventClient<P,E>::internalDisconnect);

  mutexConnection.release();

  return status;
}

//
//
//
template<class P,class E> CHS::StatusCode CHS::EventClient<P,E>::remove() throw()
{
  CHS::StatusCode status;

  mutexConnection.acquire();

  if (statusManagedPort == 1) {
    status = this->wiringslave->remove(portname);

    portname          = "";
    statusManagedPort = 0;

  } else {
    status = CHS::SMART_OK;
  }

  mutexConnection.release();

  return status;
}

//
//
//
template<class P,class E> CHS::StatusCode CHS::EventClient<P,E>::connect(const std::string& srv, const std::string& svc) throw()
{
  CHS::StatusCode result;

  result = CHS::SMART_ERROR;

  mutexConnection.acquire();

  // first disconnect eventually valid connection
  this->disconnect();

  try {
    CosNaming::Name name;
    name.length(6);
    name[0].id = CORBA::string_dup("orocos");
    name[1].id = CORBA::string_dup(srv.c_str());
    name[2].id = CORBA::string_dup("event");
    name[3].id = CORBA::string_dup(svc.c_str());
    name[4].id = CORBA::string_dup(P::identifier().c_str());
    name[5].id = CORBA::string_dup(E::identifier().c_str());

    try {
      corbaServant = resolve_name<SmartEventServerPattern>(component->namingService.in(), name);
      result = CHS::SMART_OK;
    } catch (const CosNaming::NamingContext::NotFound &) {
      // not found in naming service
      result = CHS::SMART_SERVICEUNAVAILABLE;
    }
  } catch (const CORBA::Exception & e) {
    result = CHS::SMART_ERROR;
  }

  if (result == CHS::SMART_OK) {
    // now call server to introduce this client and to check whether the server really is
    // available or whether it is in the process of destruction
    try {
      result = static_cast<CHS::StatusCode>(corbaServant->connect(h));
    } catch (CORBA::SystemException &e) {
      //
      // it might be that the server is currently being destroyed and therefore any
      // CORBA exception is interpreted as a not available service
      //
      result = CHS::SMART_ERROR_COMMUNICATION;
    }

    if (result == CHS::SMART_OK) {
      // successfully connected to the server
      statusConnected = 1;
    }
  }

  mutexConnection.release();

  return result;
}

//
//
//
template<class P,class E> CHS::StatusCode CHS::EventClient<P,E>::disconnect() throw()
{
  CHS::StatusCode result;
  CHS::StatusCode status;
  EventClientList *lptr = 0;

  mutexConnection.acquire();

  if (statusConnected == 0) {
    result = CHS::SMART_OK;
  } else {
    //
    // from now on no new activate etc. can be initiated anymore since we hold the
    // mutexConnection and it is released only after the status is already set to
    // "disconnected"
    //

    result = CHS::SMART_OK;

    mutexEventList.acquire();

    for (lptr = events; lptr != 0; lptr = lptr->next) {
      status = this->deactivate(lptr->id);
      if (status != CHS::SMART_OK) {
        result = status;
      }
    }

    mutexEventList.release();

    //
    // it is important to set statusConnected to 0 AFTER calling deactivate for every
    // event activation since deactivate itself checks the statusConnected flag and
    // executes deactivate only in case a connection to a server is available
    //
    statusConnected = 0;
  }

  mutexConnection.release();

  return result;
}

//
//
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::blocking(const bool b) throw()
{
  CHS::StatusCode result = CHS::SMART_OK;
  EventClientList *lptr = 0;

  mutexConnection.acquire();

  statusUserBlocking = b;

  mutexEventList.acquire();

  for( lptr = events; lptr != 0; lptr = lptr->next ) {
    lptr->condW.blockingUser(statusUserBlocking);
    lptr->condWO.blockingUser(statusUserBlocking);
  }

  mutexEventList.release();

  mutexConnection.release();

  return result;
}

//
//
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::activate(const EventMode m, const P& p, EventId& id) throw()
{
  EventClientList *lptr;
  CHS::StatusCode result;

  mutexConnection.acquire();

  if (statusConnected == 0) {
    //
    // no connection available
    //
    id     = 0;
    result = CHS::SMART_DISCONNECTED;

    mutexConnection.release();

    return result;
  }

  mutexEventList.acquire();

  eventCnt++;
  lptr                 = new EventClientList;
  lptr->id             = eventCnt;
  lptr->mode           = m;
  lptr->eventFired     = 0;
  lptr->eventAvailable = 0;
  lptr->next           = events;
  events = lptr;

  lptr->condW.blockingUser(statusUserBlocking);
  lptr->condWO.blockingUser(statusUserBlocking);
  component->addCV(&(lptr->condW));
  component->addCV(&(lptr->condWO));

  id = eventCnt;

  mutexEventList.release();

  //
  // now call CORBA object to send request message
  //
  result = CHS::SMART_OK;
  try {
    CORBA::Any any;
    p.get(any);
    corbaServant->activate(h, m, id, any);
  } catch (CORBA::SystemException &e) {
    result = CHS::SMART_ERROR_COMMUNICATION;
  }

  if (result != CHS::SMART_OK) {
    //
    // remove list entry
    //
    this->removeActivationId(id);
  }

  mutexConnection.release();

  return result;
}


//
//
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::deactivate(const EventId id) throw()
{
  CHS::StatusCode result;
  EventClientList *lptr;

  mutexConnection.acquire();

  if (statusConnected == 0) {
    //
    // no connection available and still active event is not possible
    //
    result = CHS::SMART_ERROR;

    mutexConnection.release();

    return result;
  }

  mutexEventList.acquire();

  for (lptr = events; lptr != 0; lptr = lptr->next)
    if (lptr->id == id)
      break;

  if( lptr == 0 ) {
    mutexEventList.release();

    result = CHS::SMART_WRONGID;
  } else {
    //
    // the signalling has to be done within the mutex protected block to make sure that
    // lptr still points to valid variables
    //
    lptr->condW.blockingPattern(false);
    lptr->condWO.blockingPattern(false);

    //
    // remove list entry
    //
    this->removeActivationId(id);

    mutexEventList.release();

    //
    // while calling deactivate we have to release the mutex since otherwise concurrently
    // running firings from the server can not be finished and therefore deactivate can
    // not be executed at the server side ... see same problem in query ...
    //

    //
    // now call CORBA object to send request message
    //
    result = CHS::SMART_OK;
    try {
      corbaServant->deactivate(h, id);
    } catch (CORBA::SystemException &e) {
      // severe communication problem like server object unreachable
      result = CHS::SMART_ERROR_COMMUNICATION;
    }
  }

  mutexConnection.release();

  return result;
}

//
//
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::tryEvent(const EventId id) throw()
{
  EventClientList *lptr;
  CHS::StatusCode  result;

  result = CHS::SMART_ERROR;

  mutexEventList.acquire();

  for (lptr = events; lptr != 0; lptr = lptr->next)
    if (lptr->id == id)
      break;

  if( lptr == 0 ) {
    result = CHS::SMART_WRONGID;
  } else if (lptr->mode == single) {
    if ((lptr->eventFired == 1) && (lptr->eventAvailable == 1)) {
      // event fired and is available
      result = CHS::SMART_OK;
    } else if ((lptr->eventFired == 1) && (lptr->eventAvailable == 0)) {
      // event already fired and not available anymore
      result = CHS::SMART_PASSIVE;
    } else if (lptr->eventFired == 0) {
      // event not yet fired
      result = CHS::SMART_ACTIVE;
    } else {
      // this does not make sense
      result = CHS::SMART_ERROR;
    }
  } else if (lptr->mode == continuous) {
    if (lptr->eventAvailable == 1) {
      // event fired and is available
      result = CHS::SMART_OK;
    } else if (lptr->eventAvailable == 0) {
      // currently no event available
      result = CHS::SMART_ACTIVE;
    } else {
      // this does not make sense
      result = CHS::SMART_ERROR;
    }
  } else {
    result = CHS::SMART_ERROR;
  }

  mutexEventList.release();

  return result;
}

//
//
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::getEvent(const EventId id,E& e) throw()
{
  EventClientList *lptr;
  CHS::StatusCode result;

  result = CHS::SMART_ERROR;

  mutexEventList.acquire();

  for (lptr = events; lptr != 0; lptr = lptr ->next)
    if (lptr->id == id)
      break;

  if (lptr == 0) {
    result = CHS::SMART_WRONGID;
  } else if (lptr->mode == single) {
    if ((lptr->eventFired == 1) && (lptr->eventAvailable == 1)) {
      // event fired and is available => consume it
      e = lptr->e;
      lptr->eventAvailable = 0;
      result = CHS::SMART_OK;
    } else if ((lptr->eventFired == 1) && (lptr->eventAvailable == 0)) {
      // event already fired and not available anymore
      result = CHS::SMART_PASSIVE;
    } else if (lptr->eventFired == 0) {
      // event not yet fired => wait for it
      mutexEventList.release();

      // important hint:
      //
      // I use a CV with memory in the single mode to make sure that the event is not missed when it
      // fires just between the above mutexEventList.release() and the following call to wait() ...
      //
      result = lptr->condW.wait();

      mutexEventList.acquire();
      if (result != CHS::SMART_OK) {
        //
        // has been cancelled ... two possible reasons, either standard cancel where event is
        // still active but blocking waits are not allowed or cancelled by the "deactivate"
        // member function
        //
        for (lptr = events; lptr != 0; lptr = lptr->next)
          if (lptr->id == id)
            break;

        if (lptr == 0) {
          //
          // when cancelled and id is not valid any longer, then either a "deactivation" or a
          // "disconnect" is responsible for the cancelled call
          //
          mutexConnection.acquire();
          if (statusConnected == 0) {
            result = CHS::SMART_DISCONNECTED;
          } else {
            result = CHS::SMART_NOTACTIVATED;
          }
          mutexConnection.release();
        } else {
          //
          // since id still valid, it is a standard "cancel" of a blocking method
          //
          result = CHS::SMART_CANCELLED;
        }
      } else {
        //
        // got event, in case that several concurrent calls waited for the event to arrive then
        // every call gets the same fired event
        //
        lptr->eventAvailable = 0;
        lptr->eventFired     = 1;
        e = lptr->e;
      }
    } else {
      //  this does not make sense
      result = CHS::SMART_ERROR;
    }
  } else if (lptr->mode == continuous) {
    if (lptr->eventAvailable == 1) {
      // event fired and is available
      lptr->eventAvailable = 0;
      lptr->condW.reset();
      e = lptr->e;
      result = CHS::SMART_OK;
    } else if (lptr->eventAvailable == 0) {
      // wait for the next firing
      mutexEventList.release();

      // important hint:
      //
      // The problem is that an event arriving just after releasing the mutexEventList and before
      // calling the wait() is missed. This is the reason why I use a CV with memory for the single
      // activation. A CV with memory can not be used here since we then would rush through the wait
      // once we have received an event. I therefore reset the CV each time an event is consumed.
      // The CV then blocks again the next time if meanwhile no event occured.
      result = lptr->condW.wait();

      mutexEventList.acquire();
      if (result != CHS::SMART_OK) {
        //
        // has been cancelled ... two possible reasons, either standard cancel where event is
        // still active but blocking waits are not allowed or cancelled by the "deactivate"
        // member function
        //
        for (lptr = events; lptr != 0; lptr = lptr->next)
          if (lptr->id == id)
            break;

        if (lptr == 0) {
          //
          // when cancelled and id is not valid any longer, then either a "deactivation" or a
          // "disconnect" is responsible for the cancelled call
          //
          mutexConnection.acquire();
          if (statusConnected == 0) {
            result = CHS::SMART_DISCONNECTED;
          } else {
            result = CHS::SMART_NOTACTIVATED;
          }
          mutexConnection.release();
        } else {
          //
          // since id still valid, it is a standard "cancel" of a blocking method
          //
          result = CHS::SMART_CANCELLED;
        }
      } else {
        //
        // got event, in case that several concurrent calls waited for the event to arrive then
        // every call gets the same fired event
        //
        lptr->eventAvailable = 0;
        lptr->condW.reset();
        e = lptr->e;
        result = CHS::SMART_OK;
      }
    } else {
      // this does not make sense
      result = CHS::SMART_ERROR;
    }
  } else {
    result = CHS::SMART_ERROR;
  }

  mutexEventList.release();

  return result;
}

//
//
//
template<class P, class E> CHS::StatusCode CHS::EventClient<P,E>::getNextEvent(const EventId id,E& e) throw()
{
  EventClientList *lptr;
  CHS::StatusCode result;

  mutexEventList.acquire();

  for (lptr = events; lptr != 0; lptr = lptr ->next)
    if (lptr->id == id)
      break;

  if (lptr == 0) {
    result = CHS::SMART_WRONGID;
  } else if (lptr->mode == single) {
    if (lptr->eventFired == 1) {
      // fired already and therefore waiting makes no sense
      result = CHS::SMART_PASSIVE;
    } else if (lptr->eventFired == 0) {
      // event not yet fired, wait for it
      mutexEventList.release();

      //
      // see important hint in getEvent() ...
      //
      result = lptr->condW.wait();

      mutexEventList.acquire();

      if (result != CHS::SMART_OK) {
        //
        // has been cancelled ... two possible reasons, either standard cancel where event is
        // still active but blocking waits are not allowed or cancelled by the "deactivate"
        // member function
        //
        for (lptr = events; lptr != 0; lptr = lptr->next)
          if (lptr->id == id)
            break;

        if (lptr == 0) {
          //
          // when cancelled and id is not valid any longer, then either a "deactivation" or a
          // "disconnect" is responsible for the cancelled call
          //
          mutexConnection.acquire();
          if (statusConnected == 0) {
            result = CHS::SMART_DISCONNECTED;
          } else {
            result = CHS::SMART_NOTACTIVATED;
          }
          mutexConnection.release();
        } else {
          //
          // since id still valid, it is a standard "cancel" of a blocking method
          //
          result = CHS::SMART_CANCELLED;
        }
      } else {
        //
        // got event, in case that several concurrent calls waited for the event to arrive then
        // every call gets the same fired event
        //
        lptr->eventAvailable = 0;
        lptr->eventFired     = 1;
        e = lptr->e;
      }
    } else {
      // this does not make sense
      result = CHS::SMART_ERROR;
    }
  } else if (lptr->mode == continuous) {
    //
    // wait for the next firing ... therefore use the CV without memory
    //
    // Important: the CV with memory can not be used here since the memory is just to indicate
    //            whether data is available or not. Calling reset here would reset the data
    //            available indicator which is different to waiting for the next time the
    //            event fires !
    mutexEventList.release();

    result = lptr->condWO.wait();

    mutexEventList.acquire();

    if (result != CHS::SMART_OK) {
      //
      // has been cancelled ... two possible reasons, either standard cancel where event is
      // still active but blocking waits are not allowed or cancelled by the "deactivate"
      // member function
      //
      for (lptr = events; lptr != 0; lptr = lptr->next)
        if (lptr->id == id)
          break;

      if (lptr == 0) {
        //
        // when cancelled and id is not valid any longer, then either a "deactivation" or a
        // "disconnect" is responsible for the cancelled call
        //
        mutexConnection.acquire();
        if (statusConnected == 0) {
          result = CHS::SMART_DISCONNECTED;
        } else {
          result = CHS::SMART_NOTACTIVATED;
        }
      } else {
        //
        // since id still valid, it is a standard "cancel" of a blocking method
        //
        result = CHS::SMART_CANCELLED;
      }
    } else {
      //
      // got event, in case that several concurrent calls waited for the event to arrive then
      // every call gets the same fired event
      //
      lptr->eventAvailable = 0;
      lptr->condW.reset();

      e = lptr->e;
      result = CHS::SMART_OK;
    }
  } else {
    // this does not make sense
    result = CHS::SMART_ERROR;
  }

  mutexEventList.release();

  return result;
}







/////////////////////////////////////////////////////////////////////////
//
// server part of event template
//
/////////////////////////////////////////////////////////////////////////

//
// static handle method called by CORBA object
//
template<class P,class E,class S> CHS::StatusCode CHS::EventServer<P,E,S>::hndCnct(void *ptr, const SmartEventClientPattern_ptr client)
{
  EventServer<P,E,S>* lthis = (EventServer<P,E,S> *)ptr;
  EventClientList* cptr;

  CHS::StatusCode result;

  lthis->mutexClientList.acquire();

  if (lthis->serverReady == 0) {
    //
    // don't accept any new clients since server is in process of destruction or not yet ready
    //
    result = CHS::SMART_SERVICEUNAVAILABLE;
  } else {
    //
    // make new client list entry
    //
    cptr            = new EventClientList;
    cptr->client    = SmartEventClientPattern::_duplicate(client);
    cptr->next      = lthis->clients;
    lthis->clients  = cptr;

    result = CHS::SMART_OK;
  }

  lthis->mutexClientList.release();

  return result;
}

//
// static handle method called by CORBA object
//
template<class P,class E,class S> void CHS::EventServer<P,E,S>::hndDisc(void* ptr, const SmartEventClientPattern_ptr client)
{
  EventServer<P,E,S>* lthis  = (EventServer<P,E,S> *)ptr;
  EventClientList* cptr      = 0;
  EventClientList* hcptr     = 0;

  lthis->mutexClientList.acquire();

  //
  // If serverReady == 0 then do not modify the list of clients anymore since
  // this list is stepped through by the destructor outside the mutexClientList
  // to disconnect all still connected clients. See comments in destructor why
  // no modifications are allowed then.
  //
  if (lthis->serverReady == 1) {
    //
    // remove client from list of clients
    //

    //
    // first remove entries from head as long as they match the corba client object
    //
    while ((lthis->clients != 0) && (client->_is_equivalent(lthis->clients->client))) {
      cptr = lthis->clients;
      lthis->clients = lthis->clients->next;
      CORBA::release(cptr->client);
      delete cptr;
    }

    //
    // now search through the rest of the list which might be empty already. If the
    // length is greater than zero, than the first element never matches and never
    // gets deleted
    //
    cptr = lthis->clients;
    if (cptr == 0) {
      // list contains no element anymore => ready
    } else {
      // list can now contain one or more elements with the first element matching never
      while (cptr->next != 0) {
        if (client->_is_equivalent(cptr->next->client)) {
          hcptr      = cptr->next;
          cptr->next = cptr->next->next;
          CORBA::release(hcptr->client);
          delete hcptr;
        } else {
          cptr = cptr->next;
        }
      }
    }
  } else {
    //
    // do nothing since server is in process of destruction
    //
  }

  lthis->mutexClientList.release();
}

//
// static handle method called by CORBA object
//
template<class P,class E,class S> void CHS::EventServer<P,E,S>::hndActivate(void *ptr, const SmartEventClientPattern_ptr client, const CORBA::Long mode, const CORBA::Long cltId, const CORBA::Any & user)
{
  EventServer<P,E,S>* lthis = (EventServer<P,E,S> *)ptr;
  EventServerList* lptr;

  lthis->mutexEventList.acquire();

  lptr = new EventServerList;
  lptr->p.set(user);
  lptr->eventMode = (EventMode)mode;
  lptr->clientId  = cltId;
  lptr->client    = SmartEventClientPattern::_duplicate(client);
  lptr->eventCnt  = 0;
  lptr->next      = lthis->events;
  lthis->events   = lptr;

  lthis->mutexEventList.release();
}

template<class P,class E,class S> void CHS::EventServer<P,E,S>::hndDeactivate(void *ptr, const SmartEventClientPattern_ptr client, const CORBA::Long cltId)
{
  EventServer<P,E,S>* lthis = (EventServer<P,E,S> *)ptr;
  EventServerList* cptr;
  EventServerList* hcptr;

  lthis->mutexEventList.acquire();

  //
  // first remove entries from head as long as they match the corba client object and the id
  //
  while ((lthis->events != 0) && (client->_is_equivalent(lthis->events->client)) && (cltId == lthis->events->clientId)) 
  {
    cptr = lthis->events;
    lthis->events = lthis->events->next;
    CORBA::release(cptr->client);
    delete cptr;
  }

  //
  // now search through the rest of the list which might be empty already. If the
  // length is greater than zero, then the first element never matches and never
  // gets deleted
  //
  cptr = lthis->events;
  if (cptr == 0) {
    // list contains no element anymore => ready
  } else {
    // list can now contain one or more elements with the first element matching never
    while (cptr->next != 0) {
      if ((client->_is_equivalent(cptr->next->client)) && (cltId == cptr->next->clientId)) {
        hcptr      = cptr->next;
        cptr->next = cptr->next->next;
        CORBA::release(hcptr->client);
        delete hcptr;
      } else {
        cptr = cptr->next;
      }
    }
  }

  lthis->mutexEventList.release();
}

//
// default constructor
//
template<class P, class E, class S> inline CHS::EventServer<P,E,S>::EventServer(void) throw(CHS::SmartError)
{
  std::cerr << "CommPattern (event): ERROR: Entered default constructor EventServer" << std::endl;

  throw(CHS::SmartError(CHS::SMART_ERROR,"CommPattern (event): ERROR: Entered default constructor EventServer"));
}

//
// standard constructor
//
template<class P, class E, class S> 
inline CHS::EventServer<P,E,S>::EventServer(SmartComponent* m,
                                            const std::string& svc, 
                                            EventTestHandler<P,E,S>& hnd) throw()
  : component(m),
    service(svc),
    testHandler(hnd),
    serverReady(0)
{
  mutexClientList.acquire();

  // reset list, counter and other stuff
  clients = 0;

  mutexEventList.acquire();
  events   = 0;
  mutexEventList.release();

  // Create the CORBA server object
  corbaServant = new EventServer_impl((void *)this,
                                      &EventServer<P,E,S>::hndActivate,
                                      &EventServer<P,E,S>::hndDeactivate,
                                      &EventServer<P,E,S>::hndCnct,
                                      &EventServer<P,E,S>::hndDisc);

  // activate object to obtain the object reference
  SmartEventServerPattern_var tm = corbaServant->_this ();

  CosNaming::Name name;                                                   // initialize name

  name.length(1);
  name[0].id = CORBA::string_dup("orocos");
  try {
    CosNaming::NamingContext_var orocos = component->namingService->bind_new_context(name);    // inc -> orocos
  } catch (const CosNaming::NamingContext::AlreadyBound &) {
    // Fine, context already exists
  }

  std::string server = component->getComponentName();
  name.length(2);
  name[1].id = CORBA::string_dup(server.c_str());
  try {
    CosNaming::NamingContext_var compname = component->namingService->bind_new_context(name);   // orocos -> <<component name>>
  } catch (const CosNaming::NamingContext::AlreadyBound &) {
    // Fine, context already exists
  }

  name.length(3);
  name[2].id = CORBA::string_dup("event");
  try {
    CosNaming::NamingContext_var eventname = component->namingService->bind_new_context(name); // << component name>> -> event
  } catch (const CosNaming::NamingContext::AlreadyBound &) {
    // Fine, context already exists
  }

  name.length(4);
  name[3].id = CORBA::string_dup(svc.c_str());
  try {
    CosNaming::NamingContext_var eventname = component->namingService->bind_new_context(name); // event -> <<service name>>
  } catch (const CosNaming::NamingContext::AlreadyBound &) {
    // Fine, context already exists
  }

  name.length(5);
  name[4].id = CORBA::string_dup(P::identifier().c_str());
  try {
    CosNaming::NamingContext_var eventname = component->namingService->bind_new_context(name); // <<service name>> -> <<identifier R>>
  } catch (const CosNaming::NamingContext::AlreadyBound &) {
    // Fine, context already exists
  }

  name.length(6);
  name[5].id = CORBA::string_dup(E::identifier().c_str());
  try {
    component->namingService->bind(name,tm.in());                                              // <<identifier R>> -> <<identifier A>>
  } catch (const CosNaming::NamingContext::AlreadyBound &) {
    std::cerr << "CommPattern (event): WARNING: service " << name[3].id << " in " << name[1].id << " rebound !" << std::endl;
    component->namingService->rebind(name,tm.in());
  }

  //
  //
  //
  serverReady = 1;

  mutexClientList.release();
}

//
// default destructor
//
template<class P, class E, class S> inline CHS::EventServer<P,E,S>::~EventServer(void) throw()
{
  EventServerList *lptr = 0;
  EventClientList *cptr = 0;

  mutexClientList.acquire();
  //
  // since we now have the mutex, connects and disconnects from clients can not be
  // executed while modifying the server state to serverReady = 0. From now on any
  // tries to connect to this server are rejected
  //
  serverReady = 0;

  mutexClientList.release();

  //
  // - pending disconnects from clients can now get the mutexClientList and can
  //   therefore execute their disconnect
  // - since serverReady == 0, from now on all modifications on the list of clients
  //   are rejected inside the disconnect handler
  // - therefore one can step through the list of clients without requiring to hold
  //   the mutexClientList and can call disconnect at the client side
  // - the server has to call the client's disconnect outside the mutexClientList since
  //   the client calls back the server within the disconnect member function and the
  //   server handler requires the mutexClientList
  // - Concurrent calls to the client's disconnect member function from this server
  //   and from the client are not critical since disconnects are executed sequentially
  //   in the client due to the client's mutexConnection
  //

  while (clients != 0) {
    cptr = clients;
    try {
      cptr->client->serverInitiatedDisconnect();
      //
      // IMPORTANT HINT:
      //
      // It might happen that a client disconnects itself and connects to another server
      // just after we released the mutexClientList and before we call serverInitiatedDisconnect
      // here. We would now disconnect that client from its new server since that client has not
      // been removed from the client list due to serverready = 0. To avoid disconnecting the
      // client from its new server in that case, we should transmit the server CORBA reference
      // to the client with the server initiated disconnect and then check whether the client
      // is still connected to this server by comparing the CORBA object ids and only disconnect
      // it in case of equivalence.
      //
      // ### NOT YET IMPLEMENTED ! Christian Schlegel
      //
    } catch (const CORBA::Exception & e) {
      // do not rethrow, continue destruction

      // the client might have disappeared meanwhile since we can't hold the
      // mutexClientList here
    }
    CORBA::release(cptr->client);
    clients = clients->next;
    delete cptr;
  }

  // - since clients are now all disconnected, finally no more new activations are received

  // unbind at naming service
  try {

    CosNaming::Name name;
    name.length(6);
    name[0].id = CORBA::string_dup("orocos");
    name[1].id = CORBA::string_dup(component->getComponentName().c_str());
    name[2].id = CORBA::string_dup("event");
    name[3].id = CORBA::string_dup(service.c_str());
    name[4].id = CORBA::string_dup(P::identifier().c_str());
    name[5].id = CORBA::string_dup(E::identifier().c_str());

    component->namingService->unbind(name);
  } catch (const CosNaming::NamingContext::NotFound &) {
    std::cerr << "could not unbind EventServer "
	 << component->getComponentName() << "/"
	 << service << " from naming service" << std::endl;
  } catch (const CORBA::Exception & e) {
    std::cerr << "CORBA Error while unbinding from Naming Service: ";
    CHS::operator<<(std::cerr, e) << std::endl;
    // do not rethrow, continue destruction of object
  }

  // free memory
  while ( events != 0 ) {
    lptr = events;
    CORBA::release(lptr->client);
    events = events->next;
    delete lptr;
  }

  // ### delete/deactivate the corbaServant object (Christian Schlegel)
}

//
// puts the current state s into event server object and calls the testEvent methods
// with this state and the specific parameters
//
template<class P, class E, class S> CHS::StatusCode CHS::EventServer<P,E,S>::put(const S& s) throw()
{
  EventServerList *lptr;
  E               e;

  CHS::StatusCode status = CHS::SMART_OK;

  mutexClientList.acquire();

  mutexEventList.acquire();

  for (lptr = events; lptr != 0; lptr = lptr->next) {
    if (this->testHandler.testEvent(lptr->p, e, s)) {
      if ((lptr->eventMode == single) && (lptr->eventCnt != 0)) {
        //
        // this a single activation which already fired, therefore
        // do not fire again
        //
      } else {
        //
        // event fires
        //
        lptr->eventCnt++;
	
	try {
          CORBA::Any any;
          e.get(any);
	  lptr->client->event(any,lptr->clientId);
	} catch (CORBA::SystemException &e) {
	  std::cerr << "EventServer::put(): Corba::SystemException : ";
	  CHS::operator<<(std::cerr, e) << std::endl;
	  status = CHS::SMART_ERROR_COMMUNICATION;
	}
      }
    }
  }

  mutexEventList.release();

  mutexClientList.release();

  return status;
}

