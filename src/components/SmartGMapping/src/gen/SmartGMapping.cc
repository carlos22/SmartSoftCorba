//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.2
// The SmartSoft Toolchain has been developed by:
//  
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
// 
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#include "SmartGMapping.hh"

// constructor
SmartGMapping::SmartGMapping()
{
	std::cout << "constructor of SmartGMapping\n";

	ini.component.name = "SmartGMapping";

	ini.paramServer.serviceName = "param";
	ini.stateServer.serviceName = "state";
	ini.basePositionUpdateClient.serverName = "SmartPioneerBaseServer";
	ini.basePositionUpdateClient.serviceName = "positionUpdate";
	ini.laserClient.serverName = "SmartLaserLMS200Server";
	ini.laserClient.serviceName = "scan";
	ini.gfs.angularUpdate = 0.5;
	ini.gfs.astep = 0.05;
	ini.gfs.critscore = 0.0;
	ini.gfs.delta = 0.05;
	ini.gfs.generateMap = true;
	ini.gfs.iterations = 5;
	ini.gfs.kernelSize = 1;
	ini.gfs.linearUpdate = 1.0;
	ini.gfs.lsigma = 0.05;
	ini.gfs.lskip = 0;
	ini.gfs.lstep = 0.05;
	ini.gfs.maxMove = 1.0;
	ini.gfs.maxUrange = 80.0;
	ini.gfs.maxrange = 81.0;
	ini.gfs.numScanBeams = 181;
	ini.gfs.ogain = 3;
	ini.gfs.particles = 50;
	ini.gfs.regscore = 0.0004;
	ini.gfs.resampleThreshold = 0.5;
	ini.gfs.sigma = 0.05;
	ini.gfs.srr = 0.1;
	ini.gfs.srt = 0.1;
	ini.gfs.str = 0.1;
	ini.gfs.stt = 0.1;
	ini.gfs.xmax = 20.0;
	ini.gfs.xmin = -20.0;
	ini.gfs.ymax = 20.0;
	ini.gfs.ymin = -20.0;
}

void SmartGMapping::init(int argc, char *argv[])
{
	try
	{
		loadParameter(argc, argv);
		component = new CHS::SmartComponent(ini.component.name, argc, argv);

		std::cout << "Component SmartGMapping is named " << ini.component.name
				<< "." << std::endl;

		// create ports
		basePositionUpdateClient = new CHS::SendClient<
				CommBasicObjects::CommBasePositionUpdate>(component);
		laserClient = new CHS::PushNewestClient<
				CommBasicObjects::CommMobileLaserScan>(component);

		paramServer = new CHS::SendServer<
				CommNavigationObjects::CommGMappingParameter>(component,
				ini.paramServer.serviceName, paramHandler);

		stateServer = new CHS::SmartStateServer(component,
				ini.stateServer.serviceName, stateChangeHandler);
		// define states for stateServer (CHS::SmartStateServer) 
		if (stateServer->defineStates("active", "active") != CHS::SMART_OK)
			std::cerr << "ERROR: define state" << std::endl;

	} catch (const CORBA::Exception &)
	{
		std::cerr << "Uncaught CORBA exception" << std::endl;
	} catch (...)
	{
		std::cerr << "Uncaught exception" << std::endl;
	}
}

// run the component
void SmartGMapping::run()
{
	compHandler.onStartup();
	component->run();
	delete component;
}

void SmartGMapping::loadParameter(int argc, char *argv[])
{
	/* 
	 Parameters can be specified via command line -filename=<filename>
	 
	 With this parameter present:
	 - The component will look for the file in the current working directory, 
	 a path relative to the current directory or any absolute path
	 - The component will use the default values if the file cannot be found
	 
	 With this parameter absent:
	 - <Name of Component>.ini will be read from current working directory, if found there
	 - $SMART_ROOT/etc/<Name of Component>.ini will be read otherwise
	 - Default values will be used if neither found in working directory or /etc   
	 */
	CHS::SmartParameter parameter;

	// load parameters
	try
	{
		// check if paramfile is given as argument
		bool paramFile = false;
		std::string str;
		for (int i = 0; i < argc; i++)
		{
			str = argv[i];
			if (str.find("filename") != std::string::npos)
				paramFile = true;
		}

		// if paramfile is given as argument
		if (paramFile == true)
		{
			std::cout << "load parameter file from argv \n";
			parameter.addFile(argc, argv, "filename", false);
		}
		// else load standard paramfile
		else
		{
			std::cout << "load SmartGMapping.ini parameter file\n";
			parameter.addFile("SmartGMapping.ini");
		}

		// than add command line arguments to allow overwriting of parameters
		// from file
		parameter.addCommandLine("", argc, argv);

		// print all known parameters
		parameter.print(); // TODO remove this


		// load parameter
		parameter.getString("component", "name", ini.component.name);

		parameter.getString("paramServer", "serviceName",
				ini.paramServer.serviceName);
		parameter.getString("stateServer", "serviceName",
				ini.stateServer.serviceName);
		parameter.getString("basePositionUpdateClient", "serverName",
				ini.basePositionUpdateClient.serverName);
		parameter.getString("basePositionUpdateClient", "serviceName",
				ini.basePositionUpdateClient.serviceName);
		parameter.getString("laserClient", "serverName",
				ini.laserClient.serverName);
		parameter.getString("laserClient", "serviceName",
				ini.laserClient.serviceName);
		parameter.getDouble("gfs", "angularUpdate", ini.gfs.angularUpdate);
		parameter.getDouble("gfs", "astep", ini.gfs.astep);
		parameter.getDouble("gfs", "critscore", ini.gfs.critscore);
		parameter.getDouble("gfs", "delta", ini.gfs.delta);
		parameter.getTruthValue("gfs", "generateMap", ini.gfs.generateMap);
		parameter.getInt("gfs", "iterations", ini.gfs.iterations);
		parameter.getInt("gfs", "kernelSize", ini.gfs.kernelSize);
		parameter.getDouble("gfs", "linearUpdate", ini.gfs.linearUpdate);
		parameter.getDouble("gfs", "lsigma", ini.gfs.lsigma);
		parameter.getInt("gfs", "lskip", ini.gfs.lskip);
		parameter.getDouble("gfs", "lstep", ini.gfs.lstep);
		parameter.getDouble("gfs", "maxMove", ini.gfs.maxMove);
		parameter.getDouble("gfs", "maxUrange", ini.gfs.maxUrange);
		parameter.getDouble("gfs", "maxrange", ini.gfs.maxrange);
		parameter.getInt("gfs", "numScanBeams", ini.gfs.numScanBeams);
		parameter.getInt("gfs", "ogain", ini.gfs.ogain);
		parameter.getInt("gfs", "particles", ini.gfs.particles);
		parameter.getDouble("gfs", "regscore", ini.gfs.regscore);
		parameter.getDouble("gfs", "resampleThreshold",
				ini.gfs.resampleThreshold);
		parameter.getDouble("gfs", "sigma", ini.gfs.sigma);
		parameter.getDouble("gfs", "srr", ini.gfs.srr);
		parameter.getDouble("gfs", "srt", ini.gfs.srt);
		parameter.getDouble("gfs", "str", ini.gfs.str);
		parameter.getDouble("gfs", "stt", ini.gfs.stt);
		parameter.getDouble("gfs", "xmax", ini.gfs.xmax);
		parameter.getDouble("gfs", "xmin", ini.gfs.xmin);
		parameter.getDouble("gfs", "ymax", ini.gfs.ymax);
		parameter.getDouble("gfs", "ymin", ini.gfs.ymin);

	} catch (const CORBA::Exception &)
	{
		std::cerr << "Uncaught CORBA exception" << std::endl;
	} catch (const CHS::ParameterError & e)
	{
		std::cerr << "Exception from parameter handling: " << e << std::endl;
	} catch (...)
	{
		std::cerr << "Uncaught exception" << std::endl;
	}
}

