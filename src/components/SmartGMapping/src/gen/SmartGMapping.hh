//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.4
// The SmartSoft Toolchain has been developed by:
//  
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
// 
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#ifndef _SMARTGMAPPING_HH
#define _SMARTGMAPPING_HH

#include <iostream>
#include "smartSoft.hh"
#include "../SmartGMappingCore.hh"
// include communication objects
#include <CommBasicObjects/commBasePositionUpdate.hh>
#include <CommBasicObjects/commMobileLaserScan.hh>
#include <CommNavigationObjects/commGMappingParameter.hh>
// include tasks	

#include "../GMappingTask.hh"
// include handler
#include "../CompHandler.hh"
#include "../ParamHandler.hh"
#include "../StateChangeHandler.hh"

#define COMP SmartGMapping::instance()

class SmartGMapping: public SmartGMappingCore
{
private:
	static SmartGMapping _smartGMapping;

	// constructor
	SmartGMapping();

	// copy-constructor
	SmartGMapping(const SmartGMapping& cc);

	// destructor
	~SmartGMapping()
	{
	}
	;

	// load parameter from ini file
	void loadParameter(int argc, char *argv[]);

	// instantiate handler
	CompHandler compHandler;
	ParamHandler paramHandler;
	StateChangeHandler stateChangeHandler;

	// ThreadQueueHandler 


public:
	// component
	CHS::SmartComponent *component;

	// create mutex


	// create condition mutex


	// instantiate tasks

	GMappingTask gMappingTask;

	// ports
	CHS::SendClient<CommBasicObjects::CommBasePositionUpdate>
			*basePositionUpdateClient;
	CHS::PushNewestClient<CommBasicObjects::CommMobileLaserScan> *laserClient;
	CHS::SendServer<CommNavigationObjects::CommGMappingParameter> *paramServer;
	CHS::SmartStateServer *stateServer;
	CHS::WiringSlave *wiringSlave;

	void init(int argc, char *argv[]);
	void run();

	// return singleton instance
	static SmartGMapping* instance()
	{
		return (SmartGMapping*) &_smartGMapping;
	}

	// ini parameter
	struct ini_ini
	{

		// component struct
		struct ini_component
		{
			// the name of the component
			std::string name;
		} component;

		struct ini_paramServer
		{
			std::string serviceName;
		} paramServer;

		struct ini_stateServer
		{
			std::string serviceName;
		} stateServer;

		struct ini_basePositionUpdateClient
		{
			std::string serverName;
			std::string serviceName;
		} basePositionUpdateClient;

		struct ini_laserClient
		{
			std::string serverName;
			std::string serviceName;
		} laserClient;

		/**
		 * #autosize         off     # determine te map size by pre readoing the log
		 * #skipMatching     off      # do not perform scan matching before computing the statistics
		 * #randseed            0    # this is for the repeated experiments
		 * # likelihood sampling
		 * #llsamplerange              0.05        # linear range
		 * #llsamplestep               0.05  # linear step
		 * #lasamplerange              0.05 # angular range
		 * #lasamplestep               0.05 # angular step
		 * ## odometry integration in proposal
		 * #linearOdometryReliability  0.0
		 * #angularOdometryReliability 0.0
		 * #considerOdometryCovariance   off
		 * ## file parameters
		 * #readFromStdin       off
		 * #onLine              off
		 * #generateMap         off
		 */
		struct ini_gfs
		{

			/**
			 * gfs measurement integration
			 */
			double angularUpdate;

			/**
			 * angular search step, this is fine, depending on the odometry error and the update interval
			 */
			double astep;

			/**
			 * critical score (leave this)
			 */
			double critscore;

			/**
			 * map resolution
			 */
			double delta;

			bool generateMap;

			/**
			 * iterations
			 */
			long iterations;

			/**
			 * the higher the value the slower the filter
			 * the better it can deal with noise, but the less precise and slower
			 */
			long kernelSize;

			double linearUpdate;

			/**
			 * sigma likelihood of 1 beam
			 */
			double lsigma;

			/**
			 * beams to skip in the likelihood computation
			 */
			long lskip;

			/**
			 * default settings for a 0.1 m map cell
			 * linear search step (choose delta)
			 */
			double lstep;

			/**
			 * maximum move among two scans. This detects some corrupted logs
			 */
			double maxMove;

			/**
			 * (use up to)
			 */
			double maxUrange;

			/**
			 * scan matcher
			 * (maximum valid) for SICK LMS, 81m max, SICK PLS 50m
			 */
			double maxrange;

			/**
			 * number of scan beams used
			 */
			long numScanBeams;

			/**
			 * gain for smoothing the likelihood
			 */
			long ogain;

			/**
			 * gfs - number of particles
			 */
			long particles;

			/**
			 * minimum score for regsistering a scan
			 */
			double regscore;

			/**
			 * when neff  is below this value a resampling occurs
			 */
			double resampleThreshold;

			/**
			 * scan matcher cell sigma, for the greedy search
			 */
			double sigma;

			/**
			 * # motion model parameters
			 * translation as a function of translation
			 */
			double srr;

			/**
			 * translation as a function of rotation
			 */
			double srt;

			/**
			 * rotation as a function of translation
			 */
			double str;

			/**
			 * rotation as a function of rotation
			 */
			double stt;

			double xmax;

			/**
			 * # inital map params
			 */
			double xmin;

			double ymax;

			double ymin;
		} gfs;
	} ini;

};
#endif
