//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//
//  Copyright (C) 2009 Andreas Steck, Matthias Lutz
//
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the communication with the pioneer robot was taken from the
// Playerstage Project, which is distributed under GPL, and you can find at
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//----------------------------------------------------------------------------


#include "SmartPlayerStageSimulatorCore.hh"

// constructor
SmartPlayerStageSimulatorCore::SmartPlayerStageSimulatorCore()
{
	std::cout << "constructor SmartPlayerStageSimulatorCore\n";

	robot = new PlayerCc::PlayerClient("127.0.0.1", 6665);
	laserProxy = new PlayerCc::LaserProxy(robot, 0);
	position_2d_proxy = new PlayerCc::Position2dProxy (robot, 0);


    try
    {
        robot->SetDataMode( PLAYERC_DATAMODE_PUSH );
        robot->SetReplaceRule( true, -1, -1, -1 );
    }
    catch (PlayerCc::PlayerError e)
    {
        std::cout << "Could not set to pull-mode" << std::endl;
        std::cout << e.GetErrorStr() << std::endl;
    }

    position_2d_proxy->SetMotorEnable(true);
    laserProxy->IntensityOn();
    robot->Read();
    robot->Read();
}


// -PI <= a <= PI
double SmartPlayerStageSimulatorCore::piToPiRad( double a ) {
  fmod(a, 2*M_PI );
  if( a >  M_PI ) a -= 2*M_PI;
  if( a < -M_PI ) a += 2*M_PI;
  return a;
}


bool SmartPlayerStageSimulatorCore::updateCovMatrix(CommBasicObjects::CommBasePosition pos0, CommBasicObjects::CommBasePosition &pos1) {
	  //< probabilitic (Andreas Steck 07/2008)

	  // maybe some of the piToPiRad() calls are not necesarry.

	  // robot orientation (radiant) !!!
	  double phiK  = pos0.get_base_alpha();
	  double phiK1 = pos1.get_base_alpha();

	  phiK  = piToPiRad( phiK );
	  phiK1 = piToPiRad( phiK1 );

	  // robot motion
	  double deltaX = pos1.get_x() - pos0.get_x();
	  double deltaY = pos1.get_y() - pos0.get_y();
	  double d = sqrt( (deltaX*deltaX) + (deltaY*deltaY) ); // euclidic distance betwenn old and new position

	  double delta = 0.0;
	  double deltaAlpha1 = 0.0;
	  double deltaAlpha2 = 0.0;

	  // delta existst only if d > 0
	  if( deltaX > 0 && deltaY > 0 )
	  {
	    delta = atan( deltaY/deltaX ); // angle of d (angular average of robot motion)
	  }
	  delta = piToPiRad( delta );

	  // both in radiant
	  deltaAlpha1 = delta - phiK;  // angular difference
	  deltaAlpha2 = phiK1 - delta; // angular difference

	  // calculate new covariance matrix just if there is some motion !!!
	  // if covM will be calculated and there is no motion covM will be increased, but should be constant;
	  // this is because of the fabs() in the calculation of sigmaDeltaAlpha1 and sigmaDeltaAlpha2
	  // the problem occurs by calculating sigmaQ2; sigmaQ2(1,1) and sigmaQ2(2,2) will be positiv and thus increasing covM
	  // without the fabs() covM will decrease in some situations, although this should never happen
	  if( d > 0.0 || fabs(phiK1-phiK) > 0.0 )
	  {
	    boost::numeric::ublas::matrix<double> covM(3, 3);
	    covM(0,0) = pos0.get_cov(0,0);
	    covM(0,1) = pos0.get_cov(0,1);
	    covM(0,2) = pos0.get_cov(0,2);
	    covM(1,0) = pos0.get_cov(1,0);
	    covM(1,1) = pos0.get_cov(1,1);
	    covM(1,2) = pos0.get_cov(1,2);
	    covM(2,0) = pos0.get_cov(2,0);
	    covM(2,1) = pos0.get_cov(2,1);
	    covM(2,2) = pos0.get_cov(2,2);

	    deltaAlpha1 = piToPiRad( deltaAlpha1 );
	    deltaAlpha2 = piToPiRad( deltaAlpha2 );

	    double sigmaD           = fabs(d) * lamdaSigmaD;
	    double sigmaDeltaAlpha1 = fabs(deltaAlpha1) * lamdaSigmaDeltaAlpha;
	    double sigmaDeltaAlpha2 = fabs(deltaAlpha2) * lamdaSigmaDeltaAlpha;
	    double sigmaDeltaBeta   = fabs(d) * lamdaSigmaDeltaBeta;

	    boost::numeric::ublas::matrix<double> nablaFq1(3, 3);
	    nablaFq1(0,0) = 1;
	    nablaFq1(0,1) = 0;
	    nablaFq1(0,2) = -d * sin( phiK + deltaAlpha1 );
	    nablaFq1(1,0) = 0;
	    nablaFq1(1,1) = 1;
	    nablaFq1(1,2) = d * cos( phiK + deltaAlpha1 )  ;
	    nablaFq1(2,0) = 0;
	    nablaFq1(2,1) = 0;
	    nablaFq1(2,2) = 1;

	    boost::numeric::ublas::matrix<double> nablaFq2(3, 4);
	    nablaFq2(0,0) = cos( phiK + deltaAlpha1 );
	    nablaFq2(0,1) = -d * sin( phiK + deltaAlpha1 );
	    nablaFq2(0,2) = 0;
	    nablaFq2(0,3) = 0;
	    nablaFq2(1,0) = sin( phiK + deltaAlpha1 );
	    nablaFq2(1,1) = d * cos( phiK + deltaAlpha1 );
	    nablaFq2(1,2) = 0;
	    nablaFq2(1,3) = 0;
	    nablaFq2(2,0) = 0;
	    nablaFq2(2,1) = 1;
	    nablaFq2(2,2) = 1;
	    nablaFq2(2,3) = 1;

	    boost::numeric::ublas::matrix<double> sigmaQ1(3, 3);
	    sigmaQ1 = covM;

	    boost::numeric::ublas::matrix<double> sigmaQ2(4, 4);
	    sigmaQ2(0,0) = sigmaD;
	    sigmaQ2(0,1) = 0;
	    sigmaQ2(0,2) = 0;
	    sigmaQ2(0,3) = 0;

	    sigmaQ2(1,0) = 0;
	    sigmaQ2(1,1) = sigmaDeltaAlpha1;
	    sigmaQ2(1,2) = 0;
	    sigmaQ2(1,3) = 0;

	    sigmaQ2(2,0) = 0;
	    sigmaQ2(2,1) = 0;
	    sigmaQ2(2,2) = sigmaDeltaAlpha2;
	    sigmaQ2(2,3) = 0;

	    sigmaQ2(3,0) = 0;
	    sigmaQ2(3,1) = 0;
	    sigmaQ2(3,2) = 0;
	    sigmaQ2(3,3) = sigmaDeltaBeta;

	    boost::numeric::ublas::matrix<double> tmp3x3(3, 3);
	    boost::numeric::ublas::matrix<double> tmp3x3_2(3, 3);
	    boost::numeric::ublas::matrix<double> tmp3x4(3, 4);
	    boost::numeric::ublas::matrix<double> nablaFq1_T(3, 3);
	    boost::numeric::ublas::matrix<double> nablaFq2_T(4, 3);

	    nablaFq1_T = boost::numeric::ublas::trans( nablaFq1 );
	    nablaFq2_T = boost::numeric::ublas::trans( nablaFq2 );

	    boost::numeric::ublas::axpy_prod( nablaFq1, sigmaQ1, tmp3x3, true ); // tmp =  nablaFq1 * sigmaQ1
	    boost::numeric::ublas::axpy_prod( tmp3x3, nablaFq1_T, tmp3x3_2, true ); // tmp =  tmp * nablaFq1_T

	    covM.clear();
	    covM = tmp3x3_2;

	    boost::numeric::ublas::axpy_prod( nablaFq2, sigmaQ2, tmp3x4, true);
	    boost::numeric::ublas::axpy_prod( tmp3x4, nablaFq2_T, tmp3x3, true);

	    covM += tmp3x3;

	    pos1.set_cov(0,0, covM(0,0) );
	    pos1.set_cov(0,1, covM(0,1) );
	    pos1.set_cov(0,2, covM(0,2) );
	    pos1.set_cov(1,0, covM(1,0) );
	    pos1.set_cov(1,1, covM(1,1) );
	    pos1.set_cov(1,2, covM(1,2) );
	    pos1.set_cov(2,0, covM(2,0) );
	    pos1.set_cov(2,1, covM(2,1) );
	    pos1.set_cov(2,2, covM(2,2) );

	    return true;

	  }
	  // if theres was no motion the above calculations will not be done - thus set the old valuse
	  // no motion --> no change in covMatrix
	  else
	  {
	    pos1.set_cov(0,0, pos0.get_cov(0,0) );
	    pos1.set_cov(0,1, pos0.get_cov(0,1) );
	    pos1.set_cov(0,2, pos0.get_cov(0,2) );
	    pos1.set_cov(1,0, pos0.get_cov(1,0) );
	    pos1.set_cov(1,1, pos0.get_cov(1,1) );
	    pos1.set_cov(1,2, pos0.get_cov(1,2) );
	    pos1.set_cov(2,0, pos0.get_cov(2,0) );
	    pos1.set_cov(2,1, pos0.get_cov(2,1) );
	    pos1.set_cov(2,2, pos0.get_cov(2,2) );

	    return false;
	  }


}
