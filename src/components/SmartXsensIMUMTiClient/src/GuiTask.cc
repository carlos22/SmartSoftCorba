//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//
//  Copyright (C) 2009 Christian Schlegel, Florian Poppa
//
//        schlegel@hs-ulm.de
//        poppa@hs-ulm.de
//
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

#include "GuiTask.hh"
#include "gen/SmartXsensIMUMTiClient.hh"

// count of measurements used for the moving average filter
#define FILTER_CNT 3

const double GuiTask::init_eliminate_g[3] =
  { 0.0, 0.0, 9.81 };
const double GuiTask::init_3x3_matrix_with_0[9] =
  { 0.0, 0.0, 0.0,  0.0, 0.0, 0.0,  0.0, 0.0, 0.0 };



GuiTask::GuiTask() :
	//imusamplerate(imusamplerateArg),
	userQuit(false),
	// filter measured accelerations using a moving average filter with filterCnt data values
	accelerations_to_filter(3,FILTER_CNT), accelerations_filtered(3,1), index_accelerations_to_filter(0), filtered_values_available(false),
	// rotate accelerations to real world coordinate system and eliminate gravity
	rotation_x(3,3), rotation_y(3,3), rotation_z(3,3), accelerations_rotated(3,1), eliminate_g(3,1),
	// integrate accelerations to get velocities along x,y,z-axis
	acc_delta_velocity(3,1), velocity(3,1),
	// integrate once again to get position
	acc_delta_position(3,1), position(3,1)
{
	std::cout << "constructor GuiTask\n";
}

int GuiTask::svc()
{
	  // receive CommIMUData
	  CommBasicObjects::CommIMUData imuData;

	  // initialization of eliminate_g matrix
	  eliminate_g = init_eliminate_g;

	  // init rotation matrices
	  rotation_x = init_3x3_matrix_with_0;
	  rotation_y = init_3x3_matrix_with_0;
	  rotation_z = init_3x3_matrix_with_0;

	  // check for valid filterCnt value
	  if (FILTER_CNT < 1)
	  {
	    std::cerr << "ERROR: define FILTER_CNT  must be >= 1." << std::endl << std::endl;
	  }
	  else
	  {
	    // user input
	    int chr;
	    // smartsoft status
	    CHS::StatusCode state;

	    // init gui
	    initNCurses();

	    while(!userQuit)
	    {
	      state = COMP->pushTimedDataClient->getUpdateWait(imuData);

	      if (state == CHS::SMART_OK)
	      {
	        calculateAdditionalValues(imuData);
	        viewValues(imuData);
	      }
	      else
	      {
	    	  std::cerr << "error in communication: " << CHS::StatusCodeConversion(state) << std::endl;
	      }

	      chr = getch();

	      if (chr == 'q')
	      {
	        userQuit = true;
	      }
	      if (chr == 'r')
	      {
	        // collect filterCnt new values for filtering purposes first
	        index_accelerations_to_filter = 0;
	        filtered_values_available = false;

	        // reset velocity
	        velocity(0,0) = 0;
	        velocity(1,0) = 0;
	        velocity(2,0) = 0;

	        // reset position
	        position(0,0) = 0;
	        position(1,0) = 0;
	        position(2,0) = 0;
	      }
	    }
	  }

	  die();

	  // that's it
	  std::cout << "Closing Gui Task." << std::endl;

	  return 0;
}



/**
  * Method to call when it is all done. Does a bit of clean-up.
  */
void GuiTask::die()
{
  // shutdown ncurses
  echo();
  endwin();
}

/**
 * View the Xsens IMU values as well as the additional calculated values using ncurses
 */
inline void GuiTask::viewValues(CommBasicObjects::CommIMUData& imuData)
{
  // helper
  int x=0, y=0;

  // clear current ncurses window
  wclear(local_win);

  // view header
  mvwprintw(local_win,   y, x, "// --------------------------------------------------------------------\n");
  mvwprintw(local_win, ++y, x, "// Xsens MTi driver\n");
  mvwprintw(local_win, ++y, x, "// --------------------------------------------------------------------\n");

  // empty line
  ++y;

  wmove(local_win, ++y, x);
  wprintw(local_win, "Gui update rate: %3.0f Hz", (double)COMP->ini.viewer.imusamplerate/(double)vieweverynthvalue);

  // counter / Xsens timestamp
  ++y; wmove(local_win, ++y, x);
  unsigned short timestamp;
  imuData.get_timestamp(timestamp);
  wprintw(local_win, "Timestamp (just a counter): %05hu", timestamp);

  // temperature
  wmove(local_win, ++y, x);
  double temperature;
  imuData.get_temperature(temperature);
  wprintw(local_win, "Temperature (°C): %6.2f", temperature);

  // accelerometer values
  ++y, wmove(local_win, ++y, x);
  double acc_x, acc_y, acc_z;
  imuData.get_accelerometer_values(acc_x, acc_y, acc_z);
  wprintw(local_win, "Accelerometer values (m/sec²)");

  wmove(local_win, ++y, x);
  wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
    acc_x,
    acc_y,
    acc_z
  );

  // gyroscope values
  wmove(local_win, ++y, x);
  double gyr_x, gyr_y, gyr_z;
  imuData.get_gyroscope_values(gyr_x, gyr_y, gyr_z);
  wprintw(local_win, "Gyroscope values (rad/sec)");

  wmove(local_win, ++y, x);
  wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
    gyr_x,
    gyr_y,
    gyr_z
  );

  // magnetometer values
  wmove(local_win, ++y, x);
  double mag_x, mag_y, mag_z;
  imuData.get_magnetometer_values(mag_x, mag_y, mag_z);
  wprintw(local_win, "Magnetometer values (arbitrary units)");

  wmove(local_win, ++y, x);
  wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
    mag_x,
    mag_y,
    mag_z
  );

  // euler angles
  wmove(local_win, ++y, x);
  wprintw(local_win, "Euler angles (degrees)");

  wmove(local_win, ++y, x);
  double roll, pitch, yaw;
  imuData.get_euler_angles(roll, pitch, yaw);
  wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
    roll,
    pitch,
    yaw
  );

  if (filtered_values_available == true)
  {
    // accelerations rotated (calculated)
    y++, wmove(local_win, ++y, x);
    wprintw(local_win, "(CALCULATED) Accelerations rotated and without gravity (m/sec²)");

    wmove(local_win, ++y, x);
    wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
      accelerations_rotated(0,0),
      accelerations_rotated(1,0),
      accelerations_rotated(2,0)
    );

    // velocity (calculated)
    wmove(local_win, ++y, x);
    wprintw(local_win, "(CALCULATED) Velocity (m/sec)");

    wmove(local_win, ++y, x);
    wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
      velocity(0,0),
      velocity(1,0),
      velocity(2,0)
    );

    // position (calculated)
    wmove(local_win, ++y, x);
    wprintw(local_win, "(CALCULATED) Position (m)");

    wmove(local_win, ++y, x);
    wprintw(local_win, "%6.2f, %6.2f, %6.2f ",
      position(0,0),
      position(1,0),
      position(2,0)
    );
  }

  // quit and reset
  ++y; wmove(local_win, ++y, x);
  wprintw(local_win, "(q) Quit ");
  wmove(local_win, ++y, x);

  wprintw(local_win, "(r) Reset calculated position and velocity");
  wprintw(local_win, "\n");

  wrefresh(local_win);
}

//--------------------------------------------------------------------------
// ncurses stuff
//--------------------------------------------------------------------------

/**
 * Initialize ncurses
 */
void GuiTask::initNCurses()
{
  initscr();

  noecho();
  raw();

  // window size must be greater than 30 LINES and 80 COLS to show everything in a nice way
  local_win = newwin(30, 80, 0, 0);

  nodelay(stdscr, 1);
  keypad(stdscr, 1);
}

/**
 * Calculate additional values based on the Xsens IMU data
 * (e.g. velocities along the x,y,z-axis, position, ...)
 */
inline void GuiTask::calculateAdditionalValues(CommBasicObjects::CommIMUData& imuData)
{
  // timing / sample rate
  // (necessary for integration)
  double sec_between_samples = 1.0 / (double) COMP->ini.viewer.imusamplerate;

  //
  // filter the accelerometer values of the Xsens IMU before integration using
  // an moving average filter with filterCnt values
  //
  double acc_x, acc_y, acc_z;
  imuData.get_accelerometer_values(acc_x, acc_y, acc_z);

  // fill filter structure for filtering of accelerometer values
  accelerations_to_filter(0, index_accelerations_to_filter) = acc_x;
  accelerations_to_filter(1, index_accelerations_to_filter) = acc_y;
  accelerations_to_filter(2, index_accelerations_to_filter) = acc_z;
  index_accelerations_to_filter++;

  if (index_accelerations_to_filter >= FILTER_CNT)
  {
    index_accelerations_to_filter = 0;
    filtered_values_available = true;
  }

  // filter structure is filled, proceed
  if (filtered_values_available)
  {
    //
    // calculate mean of the last filterCnt accelerometer values
    //
    accelerations_filtered(0,0)=0;
    accelerations_filtered(1,0)=0;
    accelerations_filtered(2,0)=0;

    for (int index = 0; index < FILTER_CNT; index++)
    {
      accelerations_filtered(0,0) += accelerations_to_filter(0,index);
      accelerations_filtered(1,0) += accelerations_to_filter(1,index);
      accelerations_filtered(2,0) += accelerations_to_filter(2,index);
    }

    accelerations_filtered = 1.0/FILTER_CNT * accelerations_filtered;

    //
    // prepare for rotation
    //
    double roll, pitch, yaw;
    imuData.get_euler_angles(roll, pitch, yaw);

    // fill rotation matrix x
    rotation_x(0,0) =  1;
    rotation_x(1,1) =  cos(degToRad(roll));
    rotation_x(2,2) =  cos(degToRad(roll));
    rotation_x(1,2) =  sin(degToRad(roll));
    rotation_x(2,1) = -sin(degToRad(roll));

    // fill rotation matrix y
    rotation_y(1,1) =  1;
    rotation_y(0,0) =  cos(degToRad(pitch));
    rotation_y(2,2) =  cos(degToRad(pitch));
    rotation_y(0,2) = -sin(degToRad(pitch));
    rotation_y(2,0) =  sin(degToRad(pitch));

    // fill rotation matrix z
    rotation_z(2,2) =  1;
    rotation_z(0,0) =  cos(degToRad(yaw));
    rotation_z(1,1) =  cos(degToRad(yaw));
    rotation_z(0,1) =  sin(degToRad(yaw));
    rotation_z(1,0) = -sin(degToRad(yaw));

    //
    // HINT: ~ means transpose in MRPT
    //

    //
    // The calculation itself
    //

    // rotate the filtered acceleration values into the real world coordinate system
    accelerations_rotated = ~rotation_z * ~rotation_y * ~rotation_x * accelerations_filtered;
    // eliminate gravity (yes it is soooo easy to win the fight against gravity :-) )
    accelerations_rotated -= eliminate_g;
    // 1st integration step (simple integration, Runge-Kutta would be better)
    acc_delta_velocity = sec_between_samples * accelerations_rotated;
    // calculate current velocity (vx0, vy0, vz0 are 0)
    velocity += acc_delta_velocity;
    // 2nd integration step (simple integration, Runge-Kutta would be better)
    acc_delta_position = sec_between_samples * velocity;
    // calculate current position (posx0, posy0, posz0 are 0)
    position += acc_delta_position;
  }
}
