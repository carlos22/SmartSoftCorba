//--------------------------------------------------------------------------
//
//  Copyright (C) 2003 Christian Schlegel, Andreas Steck
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//  This work is based on previous work by the folks from PlayerStage.
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the communication with the pioneer robot was taken from the
// Playerstage Project, which is distributed under GPL, and you can find at
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//----------------------------------------------------------------------------


#include "Robot.hh"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Robot::Robot(int robotType)
{
  serial_fd = -1;

  this->robotPos.set_x(0.0);
  this->robotPos.set_y(0.0);
  this->robotPos.set_base_alpha(0.0);

  this->rawPos.set_x(0.0);
  this->rawPos.set_y(0.0);
  this->rawPos.set_base_alpha(0.0);

  updateV = false;
  updateOmega = false;

  this->oldPos.set_x(0.0);
  this->oldPos.set_y(0.0);
  this->oldPos.set_base_alpha(0.0);

  oldth = 0;
  oldxpos = 0;
  oldypos = 0;
  totalDistance = 0;
  totalRotationLeft = 0;
  totalRotationRight = 0;

  // initialize covariance matrix
  this->oldPos.set_cov(0,0, 50*50);
  this->oldPos.set_cov(1,1, 50*50);
  this->oldPos.set_cov(2,2, 5*5/180.0*M_PI);
  this->robotPos.set_cov(0,0, oldPos.get_cov(0,0) );
  this->robotPos.set_cov(1,1, oldPos.get_cov(1,1) );
  this->robotPos.set_cov(2,2, oldPos.get_cov(2,2) );

  // uncertainity of robot
  lamdaSigmaD = 50*50/1000.0; // TODO
  lamdaSigmaDeltaAlpha = (5*5/360.0) /180.0 * M_PI; // TODO
  lamdaSigmaDeltaBeta = (2*2/1000.0) /180.0 * M_PI; // TODO


  // select the parameters according to the specified pioneer robot type
  switch(robotType)
  {
    // P3DX SH
    case ROBOT_TYPE_P3DX_SH:
    {
       AngleConvFactor = 0.001534;
       DiffConvFactor  = 0.0056;
       DistConvFactor  = 1.0;
       VelConvFactor   = 1.0;
       RangeConvFactor = 1.0;
       break;
    }

    // P3DX
    case ROBOT_TYPE_P3DX:
    {
       AngleConvFactor = 0.001534;
       DiffConvFactor  = 0.0056;
       DistConvFactor  = 0.485;
       VelConvFactor   = 1.0;
       RangeConvFactor = 1.0;
       break;
    }

    // P3AT SH
    case ROBOT_TYPE_P3AT_SH:
    {
       AngleConvFactor = 0.001534;
       DiffConvFactor  = 0.0034;
       DistConvFactor  = 1.0;
       VelConvFactor   = 1.0;
       RangeConvFactor = 1.0;
       break;
    }
  }
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Robot::~Robot()
{
  this->closeSerial();
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Robot::openSerial( std::string serialPort, bool enableMotors, bool enableSonar )
{

//< taken from player 2.0.5 (file: p2os.cc function: Setup() )
  P2OSPacket packet;
  P2OSPacket receivedpacket;

  //save base parameters
  param_serialport = serialPort;
  param_enable_motors = enableMotors;
  param_enable_sonar = enableSonar;

  // this is the order in which we'll try the possible baud rates
  //int bauds[] = {B9600, B38400, B19200, B115200, B57600};
  int bauds[] = {B115200, B57600, B38400, B9600};
  int numbauds = sizeof(bauds);
  int currbaud = 0;

  struct termios term;
  unsigned char command[20];
  int flags=0;
  bool sent_close = false;
  enum
  {
    NO_SYNC,
    AFTER_FIRST_SYNC,
    AFTER_SECOND_SYNC,
    READY
  } psos_state;

  psos_state = NO_SYNC;

  char name[20], type[20], subtype[20];
  int cnt;

  // Serial port:

  printf("P2OS connection opening serial port %s...\n",serialPort.c_str() );

  if((serial_fd = ::open(serialPort.c_str(),
                     O_RDWR | O_SYNC | O_NONBLOCK, S_IRUSR | S_IWUSR )) < 0 )
  {
    perror("P2OS::Setup():open():");
    return(1);
  }

  if(tcgetattr( serial_fd, &term ) < 0 )
  {
    perror("P2OS::Setup():tcgetattr():");
    close(serial_fd);
    serial_fd = -1;
    return(1);
  }

    cfmakeraw( &term );
    cfsetispeed(&term, bauds[currbaud]);
    cfsetospeed(&term, bauds[currbaud]);

  if(tcsetattr(serial_fd, TCSAFLUSH, &term ) < 0)
  {
    perror("P2OS::Setup():tcsetattr():");
    close(serial_fd);
    serial_fd = -1;
    return(1);
  }

  if(tcflush(serial_fd, TCIOFLUSH ) < 0)
  {
    perror("P2OS::Setup():tcflush():");
    close(serial_fd);
    serial_fd = -1;
    return(1);
  }

  if((flags = fcntl(serial_fd, F_GETFL)) < 0)
  {
    perror("P2OS::Setup():fcntl()");
    close(serial_fd);
    serial_fd = -1;
    return(1);
  }

  printf("Connected to robot device, handshaking with P2OS...\n");

  int num_sync_attempts = 3;
  while(psos_state != READY)
  {
    switch(psos_state)
    {
      case NO_SYNC:
        command[0] = SYNC0;
        packet.Build(command, 1);
        packet.Send(serial_fd);
        usleep(P2OS_CYCLETIME_USEC);
        break;
      case AFTER_FIRST_SYNC:
        printf("turning off NONBLOCK mode...\n");
        if(fcntl(serial_fd, F_SETFL, flags ^ O_NONBLOCK) < 0)
        {
          perror("P2OS::Setup():fcntl()");
          close(serial_fd);
          serial_fd = -1;
          return(1);
        }
        command[0] = SYNC1;
        packet.Build(command, 1);
        packet.Send(serial_fd);
        break;
      case AFTER_SECOND_SYNC:
        command[0] = SYNC2;
        packet.Build(command, 1);
        packet.Send(serial_fd);
        break;
      default:
        puts("P2OS::Setup():shouldn't be here...");
        break;
    }
    usleep(P2OS_CYCLETIME_USEC);

    if(receivedpacket.Receive(serial_fd))
    {
      if((psos_state == NO_SYNC) && (num_sync_attempts >= 0))
      {
        num_sync_attempts--;
        usleep(P2OS_CYCLETIME_USEC);
        continue;
      }
      else
      {
        // couldn't connect; try different speed.
        if(++currbaud < numbauds)
        {
          cfsetispeed(&term, bauds[currbaud]);
          cfsetospeed(&term, bauds[currbaud]);
          if( tcsetattr(serial_fd, TCSAFLUSH, &term ) < 0 )
          {
            perror("P2OS::Setup():tcsetattr():");
            close(serial_fd);
            serial_fd = -1;
            return(1);
          }

          if(tcflush(serial_fd, TCIOFLUSH ) < 0 )
          {
            perror("P2OS::Setup():tcflush():");
            close(serial_fd);
            serial_fd = -1;
            return(1);
          }
          num_sync_attempts = 3;
          continue;
        }
        else
        {
          // tried all speeds; bail
          break;
        }
      }
    }

    switch(receivedpacket.packet[3])
    {
      case SYNC0:
        psos_state = AFTER_FIRST_SYNC;
        break;
      case SYNC1:
        psos_state = AFTER_SECOND_SYNC;
        break;
      case SYNC2:
        psos_state = READY;
        break;
      default:
        // maybe P2OS is still running from last time.  let's try to CLOSE
        // and reconnect
        if(!sent_close)
        {
          command[0] = CLOSE;
          packet.Build(command, 1);
          packet.Send(serial_fd);
          sent_close = true;
          usleep(2*P2OS_CYCLETIME_USEC);
          tcflush(serial_fd,TCIFLUSH);
          psos_state = NO_SYNC;
        }
        break;
    }
    usleep(P2OS_CYCLETIME_USEC);
  }

  if(psos_state != READY)
  {
    printf("pose_state != READY\n");
    close(serial_fd);
    serial_fd = -1;
    return(1);
  }

  cnt = 4;
  cnt += sprintf(name, "%s", &receivedpacket.packet[cnt]);
  cnt++;
  cnt += sprintf(type, "%s", &receivedpacket.packet[cnt]);
  cnt++;
  cnt += sprintf(subtype, "%s", &receivedpacket.packet[cnt]);
  cnt++;


  command[0] = OPEN;
  packet.Build(command, 1);
  packet.Send(serial_fd);
  usleep(P2OS_CYCLETIME_USEC);

  command[0] = PULSE;
  packet.Build(command, 1);
  packet.Send(serial_fd);
  usleep(P2OS_CYCLETIME_USEC);

  command[0] = SONAR;
  command[1] = ARGINT;
  command[2] = (unsigned char)enableSonar;
  command[3] = 0;
  packet.Build(command, 4);
  packet.Send(serial_fd);
  usleep(P2OS_CYCLETIME_USEC);


  command[0] = ENABLE;
  command[1] = ARGINT;
  command[2] = (unsigned char)enableMotors;
  command[3] = 0;
  packet.Build(command, 4);
  packet.Send(serial_fd);
  usleep(P2OS_CYCLETIME_USEC);

  printf("Done. Connected to %s, a %s %s, currbaud = %d\n", name, type, subtype, currbaud);
  return 0;
//> taken from player
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Robot::closeSerial()
{
//< taken from player 2.0.5 (file: p2os.cc function: Shutdown() )
  unsigned char command[20];
  P2OSPacket packet;

  if(serial_fd == -1)
    return;

  command[0] = STOP;
  packet.Build(command, 1);
  packet.Send(serial_fd);
  usleep(P2OS_CYCLETIME_USEC);

  command[0] = CLOSE;
  packet.Build(command, 1);
  packet.Send(serial_fd);
  usleep(P2OS_CYCLETIME_USEC);

  close(serial_fd);
  serial_fd = -1;
  printf("P2OS has been shutdown");

//> taken from player
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Robot::positionChange( unsigned short from, unsigned short to )
{
//< taken from player 2.0.5 (file: sip.cc function PositionChange() )
  int diff1, diff2;

  /* find difference in two directions and pick shortest */
  if ( to > from ) {
    diff1 = to - from;
    diff2 = - ( from + 4096 - to );
  }
  else {
    diff1 = to - from;
    diff2 = 4096 - from + to;
  }

  if ( abs(diff1) < abs(diff2) )
    return(diff1);
  else
    return(diff2);
//> taken from player
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Robot::parse( unsigned char *buffer )
{

//< taken from player 2.0.5 (file: sip.cc function: Parse() )
  int cnt = 0;
  int deltaX;
  int deltaY;
  int deltaDistance;

  unsigned short newxpos, newypos;

  status = buffer[cnt];
  cnt += sizeof(unsigned char);

  // take mutex
  mutexRobotPos.acquire();

  /////////////////////////////////////////////////////////
  // Get ricks from base and calculate delta
  /////////////////////////////////////////////////////////
  // X
  newxpos = ((buffer[cnt] | (buffer[cnt+1] << 8))
             & 0xEFFF) % 4096; /* 15 ls-bits */
  deltaX = (int) rint(positionChange( oldxpos, newxpos ) * DistConvFactor);
  oldxpos = newxpos;

  // Y
  cnt += sizeof(short);
  newypos = ((buffer[cnt] | (buffer[cnt+1] << 8))
             & 0xEFFF) % 4096; /* 15 ls-bits */
  deltaY = (int) rint(positionChange( oldypos, newypos ) * DistConvFactor);
  oldypos = newypos;

  // Alpha
  cnt += sizeof(short);
  unsigned short th = ((buffer[cnt] | (buffer[cnt+1] << 8)) & 0xEFFF) % 4096;
  double deltaA = (double)positionChange( oldth, th ) * AngleConvFactor;
  deltaA = piToPiRad( deltaA );
  oldth = th;

  if(abs(deltaX)>100 || abs(deltaY)>100)
  {
    printf("invalid odometry change [%d,%d]; odometry values are tainted", deltaX,deltaY);
  }
  else
  {

    double dAlpha = piToPiRad( this->robotPos.get_base_alpha() - rawPos.get_base_alpha());
    double a1 = cos(dAlpha);
    double a2 = (-1.0)*sin(dAlpha);
    double a3 = 0;

    double a4 = sin(dAlpha);
    double a5 = cos(dAlpha);
    double a6 = 0;

    double a7 = 0;
    double a8 = 0;
    double a9 = 1;

    this->robotPos.set_x( this->robotPos.get_x() + (a1*deltaX + a2*deltaY + a3*deltaA) );
    this->robotPos.set_y( this->robotPos.get_y() + (a4*deltaX + a5*deltaY + a6*deltaA) );
    this->robotPos.set_base_alpha( piToPiRad(this->robotPos.get_base_alpha() +  (a7*deltaX + a8*deltaY + a9*deltaA)) );

    //////////////////////////////////////////////////////////////////
    // calculation of new rawPos

    this->rawPos.set_x( this->rawPos.get_x() + deltaX);
    this->rawPos.set_y( this->rawPos.get_y() + deltaY);
    this->rawPos.set_base_alpha( piToPiRad(this->rawPos.get_base_alpha() +  deltaA) );


  }


  deltaDistance = sqrt( (deltaX*deltaX) + (deltaY*deltaY) );
  totalDistance += deltaDistance;

  if( deltaA >= 0 )
  {
    totalRotationLeft += fabs( deltaA );
  }
  else
  {
    totalRotationRight += fabs( deltaA );
  }


  // update the covMatrix in robotPos
  // robotPos is transmitted by reference
  updateCovMatrix( this->oldPos, this->robotPos );

  this->oldPos = this->robotPos;

  // release mutex
  mutexRobotPos.release();

  // </asteck>

  cnt += sizeof(short);

  lvel = (short)
    rint(((short)(buffer[cnt] | (buffer[cnt+1] << 8))) * VelConvFactor);
  cnt += sizeof(short);

  rvel = (short)
    rint(((short)(buffer[cnt] | (buffer[cnt+1] << 8))) * VelConvFactor);
  cnt += sizeof(short);

  battery = buffer[cnt];
  cnt += sizeof(unsigned char);

  lwstall = buffer[cnt] & 0x01;
  rearbumpers = buffer[cnt] >> 1;
  cnt += sizeof(unsigned char);

  rwstall = buffer[cnt] & 0x01;
  frontbumpers = buffer[cnt] >> 1;
  cnt += sizeof(unsigned char);

  control = (short)
    rint(((short)(buffer[cnt] | (buffer[cnt+1] << 8))) * AngleConvFactor);
  cnt += sizeof(short);

  ptu = (buffer[cnt] | (buffer[cnt+1] << 8));
  cnt += sizeof(short);

  if(buffer[cnt] != 255 && buffer[cnt] != 0 && buffer[cnt] != 181)
    compass = (buffer[cnt]-1)*2;
  cnt += sizeof(unsigned char);

  sonarreadings = buffer[cnt];
  cnt += sizeof(unsigned char);

  //printf("%hu sonar readings:\n", sonarreadings);
  for(unsigned char i = 0;i < sonarreadings;i++) {
    sonars[buffer[cnt]]=   (unsigned short)
      rint((buffer[cnt+1] | (buffer[cnt+2] << 8)) * RangeConvFactor);
    //printf("%d %hu:",buffer[cnt],*((unsigned short *)&buffer[cnt+1]));
    //
    //printf("%hu %hu %hu\n", buffer[cnt], buffer[cnt+1], buffer[cnt+2]);
    //printf("index %d value %hu\n", buffer[cnt], sonars[buffer[cnt]]);
    cnt += 3*sizeof(unsigned char);
  }
  //printf("\n");

  timer = (buffer[cnt] | (buffer[cnt+1] << 8));
  cnt += sizeof(short);

  analog = buffer[cnt];
  cnt += sizeof(unsigned char);

  digin = buffer[cnt];
  cnt += sizeof(unsigned char);

  digout = buffer[cnt];
  cnt += sizeof(unsigned char);
//> taken from player

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// this function just calculates the covMatric for pos1
bool Robot::updateCovMatrix( CommBasicObjects::CommBasePosition pos0, CommBasicObjects::CommBasePosition &pos1 )
{
//< probabilitic (Andreas Steck 07/2008)

  // maybe some of the piToPiRad() calls are not necesarry.

  // robot orientation (radiant) !!!
  double phiK  = pos0.get_base_alpha();
  double phiK1 = pos1.get_base_alpha();

  phiK  = piToPiRad( phiK );
  phiK1 = piToPiRad( phiK1 );

  // robot motion
  double deltaX = pos1.get_x() - pos0.get_x();
  double deltaY = pos1.get_y() - pos0.get_y();
  double d = sqrt( (deltaX*deltaX) + (deltaY*deltaY) ); // euclidic distance betwenn old and new position

  double delta = 0.0;
  double deltaAlpha1 = 0.0;
  double deltaAlpha2 = 0.0;

  // delta existst only if d > 0
  if( deltaX > 0 && deltaY > 0 )
  {
    delta = atan( deltaY/deltaX ); // angle of d (angular average of robot motion)
  }
  delta = piToPiRad( delta );

  // both in radiant
  deltaAlpha1 = delta - phiK;  // angular difference
  deltaAlpha2 = phiK1 - delta; // angular difference

  // calculate new covariance matrix just if there is some motion !!!
  // if covM will be calculated and there is no motion covM will be increased, but should be constant;
  // this is because of the fabs() in the calculation of sigmaDeltaAlpha1 and sigmaDeltaAlpha2
  // the problem occurs by calculating sigmaQ2; sigmaQ2(1,1) and sigmaQ2(2,2) will be positiv and thus increasing covM
  // without the fabs() covM will decrease in some situations, although this should never happen
  if( d > 0.0 || fabs(phiK1-phiK) > 0.0 )
  {
    boost::numeric::ublas::matrix<double> covM(3, 3);
    covM(0,0) = pos0.get_cov(0,0);
    covM(0,1) = pos0.get_cov(0,1);
    covM(0,2) = pos0.get_cov(0,2);
    covM(1,0) = pos0.get_cov(1,0);
    covM(1,1) = pos0.get_cov(1,1);
    covM(1,2) = pos0.get_cov(1,2);
    covM(2,0) = pos0.get_cov(2,0);
    covM(2,1) = pos0.get_cov(2,1);
    covM(2,2) = pos0.get_cov(2,2);

    deltaAlpha1 = piToPiRad( deltaAlpha1 );
    deltaAlpha2 = piToPiRad( deltaAlpha2 );

    double sigmaD           = fabs(d) * lamdaSigmaD;
    double sigmaDeltaAlpha1 = fabs(deltaAlpha1) * lamdaSigmaDeltaAlpha;
    double sigmaDeltaAlpha2 = fabs(deltaAlpha2) * lamdaSigmaDeltaAlpha;
    double sigmaDeltaBeta   = fabs(d) * lamdaSigmaDeltaBeta;

    boost::numeric::ublas::matrix<double> nablaFq1(3, 3);
    nablaFq1(0,0) = 1;
    nablaFq1(0,1) = 0;
    nablaFq1(0,2) = -d * sin( phiK + deltaAlpha1 );
    nablaFq1(1,0) = 0;
    nablaFq1(1,1) = 1;
    nablaFq1(1,2) = d * cos( phiK + deltaAlpha1 )  ;
    nablaFq1(2,0) = 0;
    nablaFq1(2,1) = 0;
    nablaFq1(2,2) = 1;

    boost::numeric::ublas::matrix<double> nablaFq2(3, 4);
    nablaFq2(0,0) = cos( phiK + deltaAlpha1 );
    nablaFq2(0,1) = -d * sin( phiK + deltaAlpha1 );
    nablaFq2(0,2) = 0;
    nablaFq2(0,3) = 0;
    nablaFq2(1,0) = sin( phiK + deltaAlpha1 );
    nablaFq2(1,1) = d * cos( phiK + deltaAlpha1 );
    nablaFq2(1,2) = 0;
    nablaFq2(1,3) = 0;
    nablaFq2(2,0) = 0;
    nablaFq2(2,1) = 1;
    nablaFq2(2,2) = 1;
    nablaFq2(2,3) = 1;

    boost::numeric::ublas::matrix<double> sigmaQ1(3, 3);
    sigmaQ1 = covM;

    boost::numeric::ublas::matrix<double> sigmaQ2(4, 4);
    sigmaQ2(0,0) = sigmaD;
    sigmaQ2(0,1) = 0;
    sigmaQ2(0,2) = 0;
    sigmaQ2(0,3) = 0;

    sigmaQ2(1,0) = 0;
    sigmaQ2(1,1) = sigmaDeltaAlpha1;
    sigmaQ2(1,2) = 0;
    sigmaQ2(1,3) = 0;

    sigmaQ2(2,0) = 0;
    sigmaQ2(2,1) = 0;
    sigmaQ2(2,2) = sigmaDeltaAlpha2;
    sigmaQ2(2,3) = 0;

    sigmaQ2(3,0) = 0;
    sigmaQ2(3,1) = 0;
    sigmaQ2(3,2) = 0;
    sigmaQ2(3,3) = sigmaDeltaBeta;

    boost::numeric::ublas::matrix<double> tmp3x3(3, 3);
    boost::numeric::ublas::matrix<double> tmp3x3_2(3, 3);
    boost::numeric::ublas::matrix<double> tmp3x4(3, 4);
    boost::numeric::ublas::matrix<double> nablaFq1_T(3, 3);
    boost::numeric::ublas::matrix<double> nablaFq2_T(4, 3);

    nablaFq1_T = boost::numeric::ublas::trans( nablaFq1 );
    nablaFq2_T = boost::numeric::ublas::trans( nablaFq2 );

    boost::numeric::ublas::axpy_prod( nablaFq1, sigmaQ1, tmp3x3, true ); // tmp =  nablaFq1 * sigmaQ1
    boost::numeric::ublas::axpy_prod( tmp3x3, nablaFq1_T, tmp3x3_2, true ); // tmp =  tmp * nablaFq1_T

    covM.clear();
    covM = tmp3x3_2;

    boost::numeric::ublas::axpy_prod( nablaFq2, sigmaQ2, tmp3x4, true);
    boost::numeric::ublas::axpy_prod( tmp3x4, nablaFq2_T, tmp3x3, true);

    covM += tmp3x3;

    pos1.set_cov(0,0, covM(0,0) );
    pos1.set_cov(0,1, covM(0,1) );
    pos1.set_cov(0,2, covM(0,2) );
    pos1.set_cov(1,0, covM(1,0) );
    pos1.set_cov(1,1, covM(1,1) );
    pos1.set_cov(1,2, covM(1,2) );
    pos1.set_cov(2,0, covM(2,0) );
    pos1.set_cov(2,1, covM(2,1) );
    pos1.set_cov(2,2, covM(2,2) );

    return true;

  }
  // if theres was no motion the above calculations will not be done - thus set the old valuse
  // no motion --> no change in covMatrix
  else
  {
    pos1.set_cov(0,0, pos0.get_cov(0,0) );
    pos1.set_cov(0,1, pos0.get_cov(0,1) );
    pos1.set_cov(0,2, pos0.get_cov(0,2) );
    pos1.set_cov(1,0, pos0.get_cov(1,0) );
    pos1.set_cov(1,1, pos0.get_cov(1,1) );
    pos1.set_cov(1,2, pos0.get_cov(1,2) );
    pos1.set_cov(2,0, pos0.get_cov(2,0) );
    pos1.set_cov(2,1, pos0.get_cov(2,1) );
    pos1.set_cov(2,2, pos0.get_cov(2,2) );

    return false;
  }

//>

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Robot::updatePosition( CommBasicObjects::CommBasePositionUpdate update )
{
  bool isCovUpdated = false;

  CommBasicObjects::CommBasePosition upd_oldPos          = update.get_old_position();
  CommBasicObjects::CommBasePosition upd_correctedPos    = update.get_corrected_position();
  CommBasicObjects::CommBasePosition newCorrectedPos;

  // robot motion between current position and the position the laserscan (selfloc-scan) was taken
  double deltaX = this->getBasePosition().get_x() - upd_oldPos.get_x();
  double deltaY = this->getBasePosition().get_y() - upd_oldPos.get_y();
  double deltaA = piToPiRad( this->getBasePosition().get_base_alpha() )  - piToPiRad( upd_oldPos.get_base_alpha() );
  deltaA = piToPiRad( deltaA );

  double dAlpha = piToPiRad(upd_correctedPos.get_base_alpha()) -  piToPiRad( upd_oldPos.get_base_alpha() );

  double a1 = cos(dAlpha);
  double a2 = (-1.0)*sin(dAlpha);
  double a3 = 0;

  double a4 = sin(dAlpha);
  double a5 = cos(dAlpha);
  double a6 = 0;

  double a7 = 0;
  double a8 = 0;
  double a9 = 1;

  newCorrectedPos.set_x( upd_correctedPos.get_x() + (a1*deltaX + a2*deltaY + a3*deltaA) );
  newCorrectedPos.set_y( upd_correctedPos.get_y() + (a4*deltaX + a5*deltaY + a6*deltaA) );
  newCorrectedPos.set_base_alpha( piToPiRad(upd_correctedPos.get_base_alpha() +  (a7*deltaX + a8*deltaY + a9*deltaA)) );

  // calculate covMatrix
  isCovUpdated = updateCovMatrix( upd_correctedPos, newCorrectedPos );
  // now in newCorrectedPos exists the new covMatrix

  // robot motion once more. this is because of the motion while calculating covM
//<hochdorfer,lutz>
  deltaX = this->getBasePosition().get_x() - upd_oldPos.get_x();
  deltaY = this->getBasePosition().get_y() - upd_oldPos.get_y();
  deltaA = piToPiRad( this->getBasePosition().get_base_alpha() ) - piToPiRad( upd_oldPos.get_base_alpha() );
  deltaA = piToPiRad( deltaA );

  cout<<"new: "<<newCorrectedPos.get_x()      <<" "<<newCorrectedPos.get_y()      <<" "<<newCorrectedPos.get_base_alpha()<<endl;
  cout<<"old: "<<upd_correctedPos.get_x() + deltaX<<" "<<upd_correctedPos.get_y() + deltaY<<" "<< piToPiRad( piToPiRad(upd_correctedPos.get_base_alpha()) + deltaA)<<endl;
//  newCorrectedPos.set_base_alpha( correctedPos.get_base_alpha() + deltaA );


//</hochdorfer,lutz>
  newCorrectedPos.set_cov_invalid(upd_correctedPos.get_cov_invalid());

  // update of the robot Position
  mutexRobotPos.acquire();
  this->robotPos = newCorrectedPos;
  this->oldPos = this->robotPos;

  printf("this Pos        (cnt=%lu) ( %9.4f %9.4f %6.2f deg)\n", upd_correctedPos.get_update_count(),
           this->getBasePosition().get_x(), this->getBasePosition().get_y(), this->getBasePosition().get_base_alpha() /M_PI*180.0 );

  printf("corrected covM  (0,0)(1,1)(2,2): %8.1f; %8.1f; %8.1f \n", upd_correctedPos.get_cov(0,0),
           upd_correctedPos.get_cov(1,1), upd_correctedPos.get_cov(2,2) );

  printf("this covM       (0,0)(1,1)(2,2): %8.1f; %8.1f; %8.1f \n",  this->getBasePosition().get_cov(0,0),
           this->getBasePosition().get_cov(1,1), this->getBasePosition().get_cov(2,2) );
  std::cout<<"Set Cov invalid: "<<this->getBasePosition().get_cov_invalid()<<std::endl;
  mutexRobotPos.release();

  return 0;
}


int Robot::resetPosition()
{

  // reset of the robot Position
  mutexRobotPos.acquire();

  this->closeSerial();

  this->robotPos.set_x(0.0);
  this->robotPos.set_y(0.0);
  this->robotPos.set_base_alpha(0.0);

  this->rawPos.set_x(0.0);
  this->rawPos.set_y(0.0);
  this->rawPos.set_base_alpha(0.0);

  updateV = false;
  updateOmega = false;

  this->oldPos.set_x(0.0);
  this->oldPos.set_y(0.0);
  this->oldPos.set_base_alpha(0.0);

  oldth = 0;
  oldxpos = 0;
  oldypos = 0;
  totalDistance = 0;
  totalRotationLeft = 0;
  totalRotationRight = 0;

  // initialize covariance matrix
  this->oldPos.set_cov(0,0, 50*50);
  this->oldPos.set_cov(1,1, 50*50);
  this->oldPos.set_cov(2,2, 5*5/180.0*M_PI);
  this->robotPos.set_cov(0,0, oldPos.get_cov(0,0) );
  this->robotPos.set_cov(1,1, oldPos.get_cov(1,1) );
  this->robotPos.set_cov(2,2, oldPos.get_cov(2,2) );

  // uncertainity of robot
  lamdaSigmaD = 50*50/1000.0; // TODO
  lamdaSigmaDeltaAlpha = (5*5/360.0) /180.0 * M_PI; // TODO
  lamdaSigmaDeltaBeta = (2*2/1000.0) /180.0 * M_PI; // TODO

  this->openSerial(param_serialport , param_enable_motors, param_enable_sonar );
  mutexRobotPos.release();

  return 0;

}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// -PI <= a <= PI
double Robot::piToPiRad( double a )
{
  a+=M_PI;
  bool was_neg = a<0;
  a = fmod(a, 2*M_PI );
  if (was_neg) a+=2*M_PI;
  a-=M_PI;
  return a;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CommBasicObjects::CommBasePosition Robot::getBasePosition()
{
  return robotPos;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CommBasicObjects::CommBasePosition Robot::getBaseRawPosition()
{
  return rawPos;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double Robot::getBatteryVoltage()
{
  return battery / 10.0;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Robot::getV()
{
  return (int)((rvel + lvel) / 2.0);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Robot::setV( int v )
{
  if( v > this->maxVel ) v = this->maxVel;
  newV = v;
  updateV = true;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double Robot::getOmegaRad()
{
 return (rvel - lvel) / 2.0 * DiffConvFactor;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Robot::setOmegaRad( double omega )
{
  setOmegaDeg( omega/M_PI*180.0 );
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double Robot::getOmegaDeg()
{
 return (rvel - lvel) / 2.0 * DiffConvFactor * 180.0 / M_PI;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Robot::setOmegaDeg( double omega )
{
  if( omega > maxRotVel ) omega = maxRotVel;
  newOmega = (int)omega;
  updateOmega = true;
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double Robot::getDistance()
{
  return totalDistance;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double Robot::getTotalRotationLeft()
{
  return totalRotationLeft;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double Robot::getTotalRotationRight()
{
  return totalRotationRight;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Robot::isLeftWheelStall()
{
  return lwstall;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Robot::isRightWheelStall()
{
  return rwstall;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Robot::setParameters( int maxVel, int maxRotVel, int maxVelAcc, int maxVelDecel, int maxRotVelAcc, int maxRotVelDecel )
{
  P2OSPacket packet;
  unsigned char command[20];

  this->maxVel = maxVel;
  this->maxRotVel = maxRotVel;

  if( serial_fd >= 0 )
  {
    // set max velovity
    command[0] = SETV;
    command[1] = ARGINT;
    command[2] = maxVel & 0x00FF;
    command[3] = (maxVel & 0xFF00) >> 8;
    packet.Build(command, 4);
    packet.Send(serial_fd);
    usleep(P2OS_CYCLETIME_USEC);

    // set max rotational velocity
    command[0] = SETRV;
    command[1] = ARGINT;
    command[2] = maxRotVel & 0x00FF;
    command[3] = (maxRotVel & 0xFF00) >> 8;
    packet.Build(command, 4);
    packet.Send(serial_fd);
    usleep(P2OS_CYCLETIME_USEC);

    // set acceleration (positiv)
    command[0] = SETA;
    command[1] = ARGINT;
    command[2] = maxVelAcc & 0x00FF;
    command[3] = (maxVelAcc & 0xFF00) >> 8;
    packet.Build(command, 4);
    packet.Send(serial_fd);
    usleep(P2OS_CYCLETIME_USEC);

    // set deceleration (negative)
    command[0] = SETA;
    command[1] = ARGINT;
    command[2] = maxVelDecel & 0x00FF;
    command[3] = (maxVelDecel & 0xFF00) >> 8;
    packet.Build(command, 4);
    packet.Send(serial_fd);
    usleep(P2OS_CYCLETIME_USEC);

    // set acceleration (positiv)
    command[0] = SETRA;
    command[1] = ARGINT;
    command[2] = maxRotVelAcc & 0x00FF;
    command[3] = (maxRotVelAcc & 0xFF00) >> 8;
    packet.Build(command, 4);
    packet.Send(serial_fd);
    usleep(P2OS_CYCLETIME_USEC);

    // set acceleration (positiv)
    command[0] = SETRA;
    command[1] = ARGINT;
    command[2] = maxRotVelDecel & 0x00FF;
    command[3] = (maxRotVelAcc & 0xFF00) >> 8;
    packet.Build(command, 4);
    packet.Send(serial_fd);
    usleep(P2OS_CYCLETIME_USEC);
  }
  else
  {
    printf("cannnot set Parameters!\n");
  }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Robot::svc()
{
  P2OSPacket receivedpacket;
  P2OSPacket packet;
  unsigned char command[20];

  std::cout << "start...\n";

  while(1)
  {
    // wait for packet
    if(receivedpacket.Receive(serial_fd))
    {
      std::cout << "error";
      fflush(stdout);
    }
    else
    {

      if(receivedpacket.packet[0] == 0xFA && receivedpacket.packet[1] == 0xFB &&
        (receivedpacket.packet[3] == 0x30 || receivedpacket.packet[3] == 0x31) ||
        (receivedpacket.packet[3] == 0x32 || receivedpacket.packet[3] == 0x33) ||
        (receivedpacket.packet[3] == 0x34))
      {

        // process the sip-packet
        parse( &receivedpacket.packet[3] );

      }
    }

    if( updateV )
    {
       command[0] = VEL;
       command[1] = ARGINT;
       command[2] = newV & 0x00FF;
       command[3] = (newV & 0xFF00) >> 8;
       packet.Build(command, 4);
       packet.Send(serial_fd);
       //usleep(P2OS_CYCLETIME_USEC);
       updateV = false;
    }

    if( updateOmega )
    {
       command[0] = RVEL;
       command[1] = ARGINT;
       command[2] = newOmega & 0x00FF;
       command[3] = (newOmega & 0xFF00) >> 8;
       packet.Build(command, 4);
       packet.Send(serial_fd);
       //usleep(P2OS_CYCLETIME_USEC);
       updateOmega = false;
    }

  } // while
  return 0;
}

