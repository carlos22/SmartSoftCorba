//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft CDL component".
//  It provides navigation services based on the CDL
//  Curvature Distance Lookup approach.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------


#include "ParameterHandler.hh"
#include "gen/SmartCdlServer.hh"

#include <iostream>

void ParameterHandler::handleSend(const CommNavigationObjects::CommCdlParameter &r) throw()
{
	CommNavigationObjects::CdlTagType tag;

    int p1,p2,p3,p4,p5;
    r.get(tag,p1,p2,p3,p4,p5);




    //CommNavigationObjects::CdlTagType p1(ip1);
    //CommNavigationObjects::CdlTagType p2,p3,p4,p5;

    switch (tag)
    {
      /////////////////////////////////////////////////////////////////////
      // CDL_SET_MODE_STRATEGY
      case CommNavigationObjects::CdlTagType::CDL_SET_MODE_STRATEGY:
      {
        COMP->CdlGlobalLock.acquire();
        COMP->globalState.strategy = (CommNavigationObjects::CdlTagType::literal) p1;
        COMP->CdlGlobalLock.release();
        std::cout << "CDL_SET_MODE_STRATEGY: ";
        if( p1 == CommNavigationObjects::CdlTagType::CDL_REACTIVE )
        {
          std::cout << "CDL_REACTIVE selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_JOYSTICK )
        {
          std::cout << "CDL_JOYSTICK selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_TURN )
        {
          std::cout << "CDL_TURN selected\n";
        }
	else if( p1 == CommNavigationObjects::CdlTagType::CDL_APPROACH_FLAT_SURF )
        {
          std::cout << "CDL_APPROACH_FLAT_SURF selected\n";
	  COMP->CdlGlobalLock.acquire();
          COMP->globalState.count=0;
          COMP->CdlGlobalLock.release();
	}
	else if( p1 == CommNavigationObjects::CdlTagType::CDL_APPROACH_HALT )
        {
          std::cout << "CDL_APPROACH_HALT selected\n";
        }
	else if( p1 == CommNavigationObjects::CdlTagType::CDL_APPROACH )
        {
          std::cout << "CDL_APPROACH selected\n";
	}
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_ROTATE )
        {
          std::cout << "CDL_ROTATE selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_FOLLOW )
        {
          std::cout << "CDL_FOLLOW selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_BACKWARD )
        {
          std::cout << "CDL_BACKWARD selected\n";
        }
        else
        {
          std::cout << "unsupported parameter\n";
        }


        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_FREE_BEHAVIOR
      case CommNavigationObjects::CdlTagType::CDL_SET_FREE_BEHAVIOR:
      {
        COMP->CdlGlobalLock.acquire();
        COMP->globalState.freeBehavior = (CommNavigationObjects::CdlTagType::literal) p1;
        COMP->CdlGlobalLock.release();
        std::cout << "CDL_SET_FREE_BEHAVIOR: ";
        if( p1 == CommNavigationObjects::CdlTagType::CDL_NO_FREE_BEHAVIOR )
        {
          std::cout << "CDL_NO_FREE_BEHAVIOR selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_FREE_BEHAVIOR )
        {
          std::cout << "CDL_FREE_BEHAVIOR selected\n";
        }
        else
        {
          std::cout << "unsupported parameter\n";
        }

        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_LOOKUP_TABLE
      case CommNavigationObjects::CdlTagType::CDL_SET_LOOKUP_TABLE:
      {
        COMP->CdlGlobalLock.acquire();
        COMP->globalState.lookupTable = (CommNavigationObjects::CdlTagType::literal) p1;;
        COMP->CdlGlobalLock.release();
        std::cout << "CDL_SET_LOOKUP_TABLE: ";
        if( p1 == CommNavigationObjects::CdlTagType::CDL_DEFAULT_LOOKUP )
        {
          std::cout << "CDL_DEFAULT_LOOKUP selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_SECOND_LOOKUP )
        {
          std::cout << "CDL_SECOND_LOOKUP selected\n";
        }
        else
        {
          std::cout << "unsupported parameter\n";
        }

        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_TRANS_VELOCITY
      case CommNavigationObjects::CdlTagType::CDL_SET_TRANS_VELOCITY:
      {
        COMP->CdlGlobalLock.acquire();

        // set vmin
        if( p1 < CDL_V_TRA_MIN)
        {
          COMP->globalState.vmin = CDL_V_TRA_MIN;
        }
        else
        {
          COMP->globalState.vmin = p1;
        }

        // set vmax
        if( p2 > CDL_V_TRA_MAX)
        {
          COMP->globalState.vmax = CDL_V_TRA_MAX;
        }
        else
        {
          COMP->globalState.vmax = p2;
        }

        COMP->CdlGlobalLock.release();

        std::cout << "CDL_SET_TRANS_VELOCITY: "
                  << "Parameters: " << p1 << " " << p2 << " \n";
        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_ROT_VELOCITY
      case CommNavigationObjects::CdlTagType::CDL_SET_ROT_VELOCITY:
      {
        COMP->CdlGlobalLock.acquire();

        // set wmin
        if( p1 < CDL_V_ROT_MIN)
        {
          COMP->globalState.wmin = CDL_V_ROT_MIN*M_PI/180.0;
        }
        else
        {
          COMP->globalState.wmin = p1*M_PI/180.0;
        }

        // set vmax
        if( p2 > CDL_V_ROT_MAX)
        {
          COMP->globalState.wmax = CDL_V_ROT_MAX*M_PI/180.0;
        }
        else
        {
          COMP->globalState.wmax = p2*M_PI/180.0;
        }

        COMP->CdlGlobalLock.release();

        std::cout << "CDL_SET_ROT_VELOCITY: "
                  << "Parameters: " << p1 << " " << p2 << " \n";
        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_MODE_GOAL
      case CommNavigationObjects::CdlTagType::CDL_SET_MODE_GOAL:
      {
        COMP->CdlGlobalLock.acquire();
        COMP->globalState.goalSpec = (CommNavigationObjects::CdlTagType::literal) p1;
        COMP->CdlGlobalLock.release();
        std::cout << "CDL_SET_MODE_GOAL: ";
        if( p1 == CommNavigationObjects::CdlTagType::CDL_ABSOLUTE )
        {
          std::cout << "CDL_ABSOLUTE selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_PLANNER )
        {
          std::cout << "CDL_PLANNER selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_PERSON )
        {
          std::cout << "CDL_PERSON selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_SAVED )
        {
          std::cout << "CDL_SAVED selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_ANGLE_ABSOLUTE )
        {
          std::cout << "CDL_ANGLE_ABSOLUTE selected\n";
        }
        else if( p1 == CommNavigationObjects::CdlTagType::CDL_ANGLE_RELATIVE )
        {
          std::cout << "CDL_ANGLE_RELATIVE selected\n";
        }
        else
        {
          std::cout << "unsupported parameter\n";
        }

        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_GOAL
      case CommNavigationObjects::CdlTagType::CDL_SET_GOAL:
      {
        COMP->CdlGlobalLock.acquire();

	COMP->globalState.goalX =p1;
        COMP->globalState.goalY =p2;
        COMP->globalState.goalA =p3*M_PI/180.0;
        COMP->globalState.goalId =p4;

        //<lutz>
        CommNavigationObjects::CdlGoalEventState cdlGoalEventState;
        cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_NOT_REACHED);
        COMP->goalEventServer->put(cdlGoalEventState);
        std::cout<<"CDL EVENT CDL_GOAL_NOT_REACHED!"<<std::endl;
        //<lutz>

        COMP->CdlGlobalLock.release();
        std::cout << "CDL_SET_GOAL: "
                  << "Parameters: x:" << p1 << " y:" << p2 << " a:"<< p3 << " id:"<< p4 <<" \n";
        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_APPROACH_DIST
      case CommNavigationObjects::CdlTagType::CDL_SET_APPROACH_DIST:
      {
        COMP->CdlGlobalLock.acquire();

        COMP->globalState.approachDistance =p1;

	COMP->CdlGlobalLock.release();

        std::cout << "CDL_SET_APPROACH_DIST: "
                  << "Parameters: " << p1 <<" \n";
        break;
      }



      /////////////////////////////////////////////////////////////////////
      // CDL_SET_ID
      case CommNavigationObjects::CdlTagType::CDL_SET_ID:
      {
        COMP->CdlGlobalLock.acquire();

        COMP->globalState.id =p1;

        COMP->CdlGlobalLock.release();
        //<lutz>
        //cdlGoalEventState.set(CDL_GOAL_NOT_REACHED);
        //cdlGoalEventServer->put(cdlGoalEventState);
        //std::cout<<"CDL EVENT CDL_GOAL_NOT_REACHED!"<<std::endl;
        //<lutz>
        std::cout << "CDL_SET_ID: "
                  << "Parameters: " << p1 <<" \n";
        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SAVE_CURRENT_POS
      case CommNavigationObjects::CdlTagType::CDL_SAVE_CURRENT_POS:
      {
        COMP->CdlGlobalLock.acquire();

        COMP->globalState.saveFlag = 1;
        COMP->globalState.goalId = p1;

        COMP->CdlGlobalLock.release();

        std::cout << "CDL_SAVE_CURRENT_POS\n";
        break;
      }


      /////////////////////////////////////////////////////////////////////
      // CDL_SET_SAFETY_CLEARANCE
      case CommNavigationObjects::CdlTagType::CDL_SET_SAFETY_CLEARANCE:
      {

        COMP->cdlLookup->setSafetyClearance(p1);

        std::cout << "CDL_SET_SAFETY_CLEARANCE: "
                  << "Parameters: " << p1 <<" \n";
        break;
      }


      /////////////////////////////////////////////////////////////////////
      // default
      default:
      {
        break;
      }

    } // switch
}
