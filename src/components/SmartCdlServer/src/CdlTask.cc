//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft CDL component".
//  It provides navigation services based on the CDL
//  Curvature Distance Lookup approach.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "CdlTask.hh"
#include "gen/SmartCdlServer.hh"

#include <iostream>

#include <CommBasicObjects/commMobileLaserScan.hh>
#include <CommBasicObjects/commBasePosition.hh>
#include <CommBasicObjects/commNavigationVelocity.hh>
#include <CommNavigationObjects/commPlannerGoal.hh>
#include <CommTrackingObjects/commTrackingGoal.hh>

// -------------------------------------------------------------
//
// -------------------------------------------------------------
double angle00(double a)
{
	if (a < -M_PI || a >= M_PI)
	{
		a = a - 2*M_PI * floor(a / (2*M_PI));
		while(a < -M_PI) a += 2*M_PI;
		while(a >= M_PI) a -= 2*M_PI;
	}

	return(a);
}

CdlTask::CdlTask()
{
	std::cout << "constructor CdlTask\n";
}

int CdlTask::svc()
{
	CommBasicObjects::CommMobileLaserScan    scan;
	CommBasicObjects::CommNavigationVelocity vel;
	CHS::StatusCode               status;

	CommNavigationObjects::CommPlannerGoal        plannerGoal;

	/* <asteck>
  SmartBasePositionClass spos;
  VisionVehUpdNewClass   visionGoal;
  TrackVehUpdNewClass    trackGoal;
  CylGoalClass           cylinderGoal;
	 */ // </asteck>


	double v,w,vres,wres,vaccres,waccres;
	double vmin,vmax,wmin,wmax;
	double distance,heading;//,transSpeed;
	//double visionSpeed,visionAngle,visionDistance;
	double x, y, a; //z;
	double raw_x, raw_y, raw_a; // raw_z;
	//double alpha1,alpha2,alpha3;
	double goalX,goalY,goalA;
	double wayPointX,wayPointY,wayPointA;
	//long   goalId;

	double trackAngle,trackDistance,trackX,trackY;//,trackA;
	bool trackFlag;
	bool approachFlag;
	CdlEvalFunctionType evalFunction = CDL_EVAL_STANDARD;
	long goalFlag;

	//static int scannumber=0;

	struct timeval beginStalledTime;
	struct timeval currentTime;
	int            stalledFlag;       // 0 not stalled, 1 stalled
	double         timeDiff;
	int            turnDirection;

	CommTrackingObjects::CommTrackingGoal trackingGoal;
	CommNavigationObjects::CdlGoalEventState cdlGoalEventState;

	stalledFlag = 0;

	// ------------------------------------------------------------
	// now start processing
	// ------------------------------------------------------------
	while(1)
	{
		// ----------------------------------------------------------
		// wait for activation
		// ("moverobot")
		// ----------------------------------------------------------
		status = COMP->stateServer->acquire("moverobot");
		if (status == CHS::SMART_OK)
		{
			// wait for the next timed trigger

			COMP->CdlTriggerLock.acquire();
			COMP->CdlTrigger.wait();
			COMP->CdlTriggerLock.release();

			// ----------------------------------------------------------
			// access the global configuration information
			// ----------------------------------------------------------
			COMP->CdlGlobalLock.acquire();
			COMP->localState = COMP->globalState;
			COMP->CdlGlobalLock.release();

			// ----------------------------------------------------------
			// the module has been activated
			// ----------------------------------------------------------

			// select the correct lookup table
			if (COMP->localState.lookupTable == CommNavigationObjects::CdlTagType::CDL_SECOND_LOOKUP)
			{
				COMP->cdlLookup = &(COMP->cdlLookupSecond);
			}
			else
			{
				COMP->cdlLookup = &(COMP->cdlLookupDefault);
			}

			// we have to ask for the current velocities


			//smartBase.getRotateVelocity(w);     ???
			//smartBase.getTranslateVelocity(v);  ???
			//smartBase.getPos(spos);             ???

			// dont wait for scan (PushNewest)
			status = COMP->laserClient->getUpdate( scan );
			if (status != CHS::SMART_OK)
			{
				std::cout << "blocking wait status " << CHS::StatusCodeConversion(status) << " not ok => retry ..." << std::endl;
			}
			else
			{
				v = scan.get_base_state().get_base_velocity().get_v();
				w = scan.get_base_state().get_base_velocity().get_omega_base();
				x = scan.get_base_state().get_base_position().get_x();
				y = scan.get_base_state().get_base_position().get_y();
				a = scan.get_base_state().get_base_position().get_base_alpha();

				raw_x = scan.get_base_state().get_base_raw_position().get_x();
				raw_y = scan.get_base_state().get_base_raw_position().get_y();
				raw_a = scan.get_base_state().get_base_raw_position().get_base_alpha();

				COMP->CdlGlobalLock.acquire();
				if (COMP->globalState.saveFlag == 1)
				{
					COMP->globalState.savedPosX = x;
					COMP->globalState.savedPosY = y;
					COMP->globalState.savedPosA = a;

					COMP->globalState.saveFlag = 0;
					COMP->localState = COMP->globalState;
				}
				COMP->CdlGlobalLock.release();

				// --------------------------------------------------------
				// cdl-loop
				// --------------------------------------------------------
				switch(COMP->localState.strategy)
				{

				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_ROTATE
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_ROTATE:
				{
					// ----------------------------------------------------
					// head into the given direction and report this by
					// the goal reached event
					// ----------------------------------------------------

					approachFlag = false;

					if (COMP->localState.goalId == COMP->localState.id)
					{

						COMP->cdlLookup->setLaserscan(scan);
						COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);

						switch(COMP->localState.goalSpec)
						{
						case CommNavigationObjects::CdlTagType::CDL_ABSOLUTE:
						{
							// -------------------------------------------------
							// heading is given by absolute position
							// -------------------------------------------------
							COMP->cdlLookup->setGoalPosition(COMP->localState.goalX,COMP->localState.goalY);
							heading  = angle00(atan2(COMP->localState.goalY-y,COMP->localState.goalX-x)-a);
							std::cout<<" COMP->localState.goalX: "<<COMP->localState.goalX<<" x: "<<x<<" COMP->localState.goalY: "<< COMP->localState.goalY<<" y: "<<y<<" a: "<<a<<std::endl;
							approachFlag=true;
							break;
						}

						case CommNavigationObjects::CdlTagType::CDL_ANGLE_ABSOLUTE:
						{
							// -------------------------------------------------
							// heading is given by angle (absolut)
							// -------------------------------------------------
							COMP->localState.goalA = angle00(COMP->localState.goalA);
							COMP->localState.goalX = x + cos(COMP->localState.goalA) * 1000.0;
							COMP->localState.goalY = y + sin(COMP->localState.goalA) * 1000.0;

							COMP->cdlLookup->setGoalPosition(COMP->localState.goalX,COMP->localState.goalY);
							heading  = angle00(atan2(COMP->localState.goalY-y,COMP->localState.goalX-x)-a);
							approachFlag=true;
							break;
						}

						case CommNavigationObjects::CdlTagType::CDL_ANGLE_RELATIVE:
						{
							// -------------------------------------------------
							// heading is given by angle (relative) -- goalA
							// -------------------------------------------------
							COMP->localState.goalA = angle00(COMP->localState.goalA + COMP->localState.savedPosA);
							COMP->localState.goalX = COMP->localState.savedPosX + cos(COMP->localState.goalA) * 1000.0;
							COMP->localState.goalY = COMP->localState.savedPosY + sin(COMP->localState.goalA) * 1000.0;

							COMP->cdlLookup->setGoalPosition(COMP->localState.goalX,COMP->localState.goalY);
							heading  = angle00(atan2(COMP->localState.goalY-y,COMP->localState.goalX-x)-a);
							approachFlag=true;

							std::cout<<"COMP->localState.goalA: "<<COMP->localState.goalA<<" a: "<<a<<" COMP->localState.goalX: "<<COMP->localState.goalX<<" x: "<<x<<" COMP->localState.goalY: "<< COMP->localState.goalY<<" y: "<<y<<std::endl;
							break;
						}

						default:
						{
							approachFlag=false;
							break;
						}
						}
					} // if (COMP->localState.goalId == COMP->localState.id)


					if (approachFlag==false)
					{
						vres = 0.0;
						wres = 0.0;
					}
					else
					{
						// second case: heading > (-1 * COMP->localState.rotateError)
						if ((heading < COMP->localState.rotateError) && (heading > (-COMP->localState.rotateError) ))
						{
							// heading ok, stop turning
							vres = 0.0;
							wres = 0.0;

							stalledFlag = 0;

							cout << "Heading OK, stop\n";

							// -------------------------------------------
							// put event into object
							// -------------------------------------------
							//<lutz>
							if(w == 0)
							{
								//<lutz>
								cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
								COMP->goalEventServer->put(cdlGoalEventState);
								std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;
							}
						} else {
							// not inside goal region
							COMP->cdlLookup->setMaxDistance(CDL_MAX_DISTANCE);
							COMP->cdlLookup->calculateSpeedValues(v,w,x,y,a,0.0,0.0,
									COMP->localState.wmin,COMP->localState.wmax,
									CDL_STRATEGY_11,CDL_EVAL_STANDARD,
									vres,wres,vaccres,waccres);
							cout << "Heading NOT OK diff: "<<heading<<" \n";
						}
					}

					break;
				} // case CDL_ROTATE


				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_REACTIVE
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_REACTIVE:
				{
					// ----------------------------------------------------
					// drive into that direction which allows high
					// translational velocity and provides large
					// remaining travel distance
					// ----------------------------------------------------

					std::cout << "reactive \n";

					COMP->cdlLookup->setLaserscan(scan);

					COMP->cdlLookup->setHeading(0.0);
					COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);
					COMP->cdlLookup->setMaxDistance(CDL_MAX_DISTANCE);
					COMP->cdlLookup->setDesiredTranslationalSpeed(COMP->localState.vmax);

					COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_2, CDL_EVAL_STANDARD, vres, wres, vaccres, waccres);


					break;
				} // case CDL_REACTIVE



				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_JOYSTICK
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_JOYSTICK:
				{

					COMP->cdlLookup->setLaserscan(scan);

					COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);
					COMP->cdlLookup->setMaxDistance(CDL_MAX_DISTANCE);

					COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax,
							CDL_STRATEGY_5, CDL_EVAL_STANDARD, vres, wres, vaccres, waccres);


					break;
				} // case CDL_JOYSTICK



				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_TURN
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_TURN:
				{
					// ----------------------------------------------------

					COMP->cdlLookup->setLaserscan(scan);

					COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);
					COMP->cdlLookup->setMaxDistance(CDL_MAX_DISTANCE);
					COMP->cdlLookup->setDesiredTranslationalSpeed(COMP->localState.vmax);

					COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax,
							CDL_STRATEGY_11, CDL_EVAL_STANDARD, vres, wres, vaccres, waccres);

					break;
				}



				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_APPROACH_HALT
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_APPROACH_HALT:
				{

					approachFlag = false;

					COMP->cdlLookup->setLaserscan(scan);
					COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);

					switch(COMP->localState.goalSpec)
					{

					case CommNavigationObjects::CdlTagType::CDL_ABSOLUTE:
					{
						// goal specified directly in this module

						approachFlag = true;
						evalFunction = CDL_EVAL_STOPPING;
						goalX     = COMP->localState.goalX;
						goalY     = COMP->localState.goalY;
						COMP->cdlLookup->setGoalPosition(goalX,goalY);
						COMP->cdlLookup->setEvalStopping(3000.0,2000.0,800.0,200.0,50.0,2000.0);
						vmin = COMP->localState.vmin;
						vmax = COMP->localState.vmax;
						wmin = COMP->localState.wmin;
						wmax = COMP->localState.wmax;
						break;
					}

					case CommNavigationObjects::CdlTagType::CDL_PLANNER:
					{
						// goal specification from planner
						// don't use getWait because the cycle time of the cdl process
						// is higher than the planner cycle time.
						//
						status =  COMP->plannerClient->getUpdate(plannerGoal);
						plannerGoal.get_goal(wayPointX,wayPointY,wayPointA,goalX,goalY,goalA,COMP->localState.goalId,goalFlag);

						//std::cout<<"CDL COMP->localState.id: "<<COMP->localState.id<<" goalID: "<<goalId<<std::endl;
						if (COMP->localState.goalId != COMP->localState.id)
						{
							// received not yet the actual data
							approachFlag=false;
						}
						else if (goalFlag != 0)
						{
							// currently no valid goal available
							approachFlag=false;
						}
						else
						{
							approachFlag=true;
							COMP->cdlLookup->setGoalPosition(wayPointX,wayPointY);
							distance = sqrt((wayPointX-goalX)*(wayPointX-goalX)
									+(wayPointY-goalY)*(wayPointY-goalY));
							if (distance < 100.0)
							{
								//std::cout<<"CDL_EVAL_STOPPING"<<endl;
								// approach final destination
								// the final goal point and the next way point are very close to
								// each other
								evalFunction = CDL_EVAL_STOPPING;
								if (COMP->localState.lookupTable==CommNavigationObjects::CdlTagType::CDL_SECOND_LOOKUP)
								{
									COMP->cdlLookup->setEvalStopping(2500.0,1000.0,
											500.0, 200.0,200.0,
											1500.0);
								}
								else
								{
									COMP->cdlLookup->setEvalStopping(1000.0,500.0,
											800.0, 400.0,100.0,
											1500.0);
									//COMP->cdlLookup->setEvalStopping(2500.0,1000.0,
											//                          800.0, 300.0,100.0,
											//                       1500.0);

								}
							}
							else
							{
								// approach intermediate way point
								//std::cout<<"CDL_EVAL_PASSING"<<endl;
								evalFunction = CDL_EVAL_PASSING;
								if (COMP->localState.lookupTable==CommNavigationObjects::CdlTagType::CDL_SECOND_LOOKUP)
								{
									COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
											500.0, 500.0,500.0,
											1500.0);
								}
								else
								{
									COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
											800.0, 600.0,600.0,
											1500.0);
									//COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
											//                         800.0, 400.0,200.0,
											//                      1500.0);
								}
							}
						}
						vmin = COMP->localState.vmin;
						vmax = COMP->localState.vmax;
						wmin = COMP->localState.wmin;
						wmax = COMP->localState.wmax;
						break;
					}

					default:
					{
						approachFlag = false;
						vmin         = 0.0;
						vmax         = 0.0;
						wmin         = 0.0;
						wmax         = 0.0;
						break;
					} // default

					}//switch(COMP->localState.goalSpec)

					if (approachFlag==false)
					{
						vres = 0.0;
						wres = 0.0;
					}
					else
					{
						distance = sqrt((goalX-x)*(goalX-x)+(goalY-y)*(goalY-y));
						std::cout<<"Distance to Goal: "<<distance<<" approachDistance: "<<COMP->localState.approachDistance<<std::endl;
						if (distance < COMP->localState.approachDistance)
						{
							// goal reached, stop robot
							vres = 0.0;
							wres = 0.0;

							// this stop is intended, since the goal has been reached
							stalledFlag = 0;

							// -------------------------------------------
							// put event into object
							// -------------------------------------------
							cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
							COMP->goalEventServer->put(cdlGoalEventState);
							std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

							std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
							std::cout << "             goal   " << COMP->localState.goalX << " " << COMP->localState.goalY << "\n";
							std::cout << "CDL COMP->localState.id: " << COMP->localState.id << " goalID: " << COMP->localState.goalId << "\n";

						}
						else
						{
							//COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_6, evalFunction, vres, wres, vaccres, waccres);
							COMP->cdlLookup->setDesiredTranslationalSpeed(COMP->localState.vmax);
							COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_12, evalFunction, vres, wres, vaccres, waccres);
							std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << std::endl;
							double gainDist = distance / 750.0;
							if(gainDist>1.0) gainDist=1.0;

							vres *= gainDist;
							if(vres > 20 && vres < 150) vres = 150;
							std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << std::endl;
							std::cout << "---------------------------------------------------------------------------\n\n\n";
						}
					}

					break;
				} //case CommNavigationObjects::CdlTagType::CDL_APPROACH_HALT




				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_APPROACH
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_APPROACH:
				{
					approachFlag = false;

					COMP->cdlLookup->setLaserscan(scan);
					COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);

					switch(COMP->localState.goalSpec)
					{

					case CommNavigationObjects::CdlTagType::CDL_ABSOLUTE:
					{
						goalX = COMP->localState.goalX;
						goalY = COMP->localState.goalY;
						distance = sqrt((goalX-x)*(goalX-x)+
								(goalY-y)*(goalY-y));
						heading  = angle00(atan2(goalY-y,goalX-x)-a);
						approachFlag=true;
						cout << "Approach Goal (ABS) dist heading " << distance << " " << heading*180.0/M_PI << "\n";
						break;
					} // CommNavigationObjects::CdlTagType::CDL_ABSOLUTE


					case CommNavigationObjects::CdlTagType::CDL_PLANNER:
					{
						// goal specification from planner
						// don't use getWait because the cycle time of the cdl process
						// is higher than the planner cycle time.
						//
						status =  COMP->plannerClient->getUpdate(plannerGoal);
						plannerGoal.get_goal(wayPointX,wayPointY,wayPointA,goalX,goalY,goalA,COMP->localState.goalId,goalFlag);

						//std::cout<<"CDL COMP->localState.id: "<<COMP->localState.id<<" goalID: "<<goalId<<std::endl;
						if (COMP->localState.goalId != COMP->localState.id)
						{
							// received not yet the actual data
							approachFlag=false;
							std::cout << "strategy: PLANNER -- received not yet the actual data (COMP->localState.goalId != COMP->localState.id)\n";
						}
						else if (goalFlag != 0)
						{
							// currently no valid goal available
							approachFlag=false;
							std::cout << "strategy: PLANNER -- currently no valid goal available (goalFlag != 0)\n";
						}
						else
						{
							approachFlag=true;
							COMP->cdlLookup->setGoalPosition(wayPointX,wayPointY);
							distance = sqrt((wayPointX-goalX)*(wayPointX-goalX)
									+(wayPointY-goalY)*(wayPointY-goalY));

							evalFunction = CDL_EVAL_PASSING;
							if (COMP->localState.lookupTable==CommNavigationObjects::CdlTagType::CDL_SECOND_LOOKUP)
							{
								COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
										500.0, 500.0,500.0,
										1500.0);
							}
							else
							{
								COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
										800.0, 600.0,600.0,
										1500.0);
							}
						}
						break;
					} // CommNavigationObjects::CdlTagType::CDL_PLANNER


					default:
					{
						approachFlag = false;
						break;
					} // default

					}//switch(COMP->localState.goalSpec)

					if (approachFlag==false)
					{
						vres = 0.0;
						wres = 0.0;
						std::cout << "approachFlag==false\n";
					}
					else
					{
						distance = sqrt((goalX-x)*(goalX-x)+(goalY-y)*(goalY-y));
						std::cout<<"Distance to Goal: "<<distance<<" approachDistance: "<<COMP->localState.approachDistance<<std::endl;
						if (distance < COMP->localState.approachDistance)
						{
							// goal reached, DO NOT STOP robot but switch to
							// reactive bahviour
							COMP->CdlGlobalLock.acquire();
							COMP->globalState.strategy = CommNavigationObjects::CdlTagType::CDL_REACTIVE;
							COMP->CdlGlobalLock.release();



							// -------------------------------------------
							// put event into object
							// -------------------------------------------
							cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
							COMP->goalEventServer->put(cdlGoalEventState);
							std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

							std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
							std::cout << "             goal   " << goalX << " " << goalY << "\n";
							std::cout << "CDL COMP->localState.id: " << COMP->localState.id << " goalID: " << COMP->localState.goalId << "\n";
						}
						else
						{
							COMP->cdlLookup->setDesiredTranslationalSpeed(COMP->localState.vmax);
							COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_12, evalFunction, vres, wres, vaccres, waccres);
							//std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << std::endl;
						}
					}

					break;
				} //case CommNavigationObjects::CdlTagType::CDL_APPROACH



				/////////////////////////////////////////////////////////////////////////////////////////
				// CDL_FOLLOW
				/////////////////////////////////////////////////////////////////////////////////////////
				case CommNavigationObjects::CdlTagType::CDL_FOLLOW:
				{
					// ----------------------------------------------------
					// try to drive into the given direction with the
					// given translational velocity
					// ----------------------------------------------------
					COMP->cdlLookup->setLaserscan(scan);

					switch(COMP->localState.goalSpec)
					{
					case CommNavigationObjects::CdlTagType::CDL_PERSON:
					{
						COMP->trackingClient->getUpdate(trackingGoal);
						trackingGoal.get( trackAngle, trackDistance, trackX, trackY, trackFlag);

						//std::cout << "Track x: " << trackX << "; y: " << trackY << "; Angle: " << ((trackAngle*180.0)/M_PI) << "; dist: " << trackDistance << "; flag: " << trackFlag << "\n";

						trackAngle = angle00(atan2( trackY - raw_y,  trackX- raw_x) - raw_a);
						trackDistance = sqrt( (raw_x-trackX)*(raw_x-trackX) + (raw_y-trackY)*(raw_y-trackY) );

						//std::cout << "Track x: " << trackX << "; y: " << trackY << "; Angle: " << ((trackAngle*180.0)/M_PI) << "; dist: " << trackDistance << "; flag: " << trackFlag << "\n";
						if (trackFlag == false)
						{
							// no valid goal information from track server
							std::cout << "no valid goal information\n";
							vres=0.0;
							wres=0.0;
							stalledFlag = 0;

						}
						else
						{
							//TODO hytsteresis distance 50 mm and angle with 5 deg --> move to ini
							if(COMP->globalState.followHysteresis==true && trackDistance < (COMP->localState.approachDistance + 50) && fabs(trackAngle-w) < (15.0/180.0*M_PI) ){
								// goal reached, stop robot
								vres = 0.0;
								wres = 0.0;
								// this stop is intended, since the goal has been reached
								stalledFlag = 0;
							}
							else
							{

								COMP->globalState.followHysteresis = false;
								COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);
								COMP->cdlLookup->setHeading(trackAngle);
								COMP->cdlLookup->setMaxDistance(CDL_MAX_DISTANCE);
								COMP->cdlLookup->setDesiredTranslationalSpeed(COMP->localState.vmax);
								COMP->cdlLookup->calculateSpeedValues(v,w,0.0,0.0,0.0,COMP->localState.vmin,COMP->localState.vmax,COMP->localState.wmin,COMP->localState.wmax,CDL_STRATEGY_7,CDL_EVAL_STANDARD,vres,wres,vaccres,waccres);

								double gainDist = trackDistance / (800.0+COMP->localState.approachDistance);
								if(gainDist > 1.0) gainDist=1.0;
								vres *= gainDist;
								//if(vres > 20 && vres < 150) vres = 150;
								if(vres > 30 && vres < 100) vres = 100;
								//std::cout << "dist to person: " << trackDistance << "  ---   v: " << v << " --- w: "<< w <<std::endl;

								//if( trackDistance < COMP->localState.approachDistance)
								if( trackDistance < COMP->localState.approachDistance && fabs(trackAngle-w) < (10.0/180.0*M_PI)   )
								{
									COMP->globalState.followHysteresis=true;
									// goal reached, stop robot
									vres = 0.0;
									wres = 0.0;

									// this stop is intended, since the goal has been reached
									stalledFlag = 0;
								}

							}

						}
						break;
					}

					default:
					{
						// set everything to harmless values
						COMP->cdlLookup->setHeading(0.0);
						COMP->cdlLookup->setMaxDistance(0.0);
						COMP->cdlLookup->setDesiredTranslationalSpeed(0.0);
						COMP->cdlLookup->calculateSpeedValues(v,w,0.0,0.0,0.0,COMP->localState.vmin,COMP->localState.vmax,COMP->localState.wmin,COMP->localState.wmax,CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres,wres,vaccres,waccres);
						break;
					}
					}
					//smartBase.setAccelerations(COMP->localState.rotAcc,COMP->localState.transAcc);

					break; //case follow


					/////////////////////////////////////////////////////////////////////////////////////////
					// CDL_APPROACH_FLAT_SURF
					/////////////////////////////////////////////////////////////////////////////////////////
					case CommNavigationObjects::CdlTagType::CDL_APPROACH_FLAT_SURF:
					{


						// this stop is intended, since the goal has been reached
						stalledFlag = 0;
						COMP->cdlLookup->setLaserscan(scan);
						COMP->cdlLookup->setParameterRobot(COMP->localState.tcalc,COMP->localState.transAcc,COMP->localState.rotAcc);


						evalFunction = CDL_EVAL_STOPPING;
						COMP->cdlLookup->setEvalStopping(3000.0,2000.0,800.0,200.0,50.0,2000.0);
						vmin = COMP->localState.vmin;
						vmax = COMP->localState.vmax;
						wmin = COMP->localState.wmin;
						wmax = COMP->localState.wmax;


						COMP->CdlGlobalLock.acquire();
						int tmp = COMP->globalState.count;
						COMP->CdlGlobalLock.release();

						if(tmp > 12)
						{
							// goal reached, stop robot
							vres = 0.0;
							wres = 0.0;

							// -------------------------------------------
							// put event into object
							// -------------------------------------------
							cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
							COMP->goalEventServer->put(cdlGoalEventState);
							std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;
						}
						else
						{
							COMP->cdlLookup->setDesiredTranslationalSpeed(COMP->localState.vmax);
							COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_13, evalFunction, vres, wres, vaccres, waccres);

							COMP->CdlGlobalLock.acquire();

							if(vres==0)
							{
								COMP->globalState.count++;
							}
							else
							{
								COMP->globalState.count=0;
							}

							//std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << "count: "<<COMP->globalState.count<<std::endl;
							//std::cout << "---------------------------------------------------------------------------\n\n\n";

							COMP->CdlGlobalLock.release();
						}

						break;
					} //case CommNavigationObjects::CdlTagType::CDL_APPROACH_FLAT_SURF



					/////////////////////////////////////////////////////////////////////////////////////////
					// CDL_BACKWARD
					/////////////////////////////////////////////////////////////////////////////////////////

					case CommNavigationObjects::CdlTagType::CDL_BACKWARD:
						// ----------------------------------------------------
						// move straight back until distance to goal point is
						// big enough
						//
						// that behavior is in some sense stupid as NO correct
						// CDL takes place !!! The robot just drives backwards
						// towards the specified goal point and stops as soon
						// as the goal circle is reached.
						//    CDL_SAVED
						// ----------------------------------------------------
						approachFlag = false;

						if (COMP->localState.goalId == COMP->localState.id)
						{
							switch(COMP->localState.goalSpec)
							{
							case CommNavigationObjects::CdlTagType::CDL_SAVED:
							{
								// -------------------------------------------------
								// heading is given by absolute position
								// -------------------------------------------------
								distance = sqrt((COMP->localState.savedPosX-x)*(COMP->localState.savedPosX-x)
										+(COMP->localState.savedPosY-y)*(COMP->localState.savedPosY-y));
								if (distance < COMP->localState.approachDistance) {
									approachFlag = true;
									vres = -150.0;
									wres =    0.0;
								}
								else
								{
									approachFlag = false;
									stalledFlag = 0;
									// -------------------------------------------
									// put event into object
									// -------------------------------------------
									cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
									COMP->goalEventServer->put(cdlGoalEventState);
									std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

									std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
									std::cout << "             goal   " << COMP->localState.goalX << " " << COMP->localState.goalY << "\n";
								}
								break;
							}

							default:
							{
								approachFlag=false;
								break;
							}
							} // switch(COMP->localState.goalSpec)
						} // if (COMP->localState.goalId == COMP->localState.id)

						if (approachFlag==false)
						{
							vres = 0.0;
							wres = 0.0;
						}
						break;
				}



				/////////////////////////////////////////////////////////////////////////////////////////
				// default -> no strategy selected
				/////////////////////////////////////////////////////////////////////////////////////////
				default:
				{
					break;
				} // case default

				} // switch(COMP->localState.strategy)

				// ----------------------------------------------------------
				// now send commands directly to the base
				// ----------------------------------------------------------

				// TODO this is for backward driving with Joystick -> can surely be done better !!
				double speed = COMP->cdlLookup->getDesiredTranslationalSpeed();
				if( COMP->localState.strategy == CommNavigationObjects::CdlTagType::CDL_JOYSTICK && speed <= 0 )
				{
					if( speed < COMP->localState.vmin ) speed = COMP->localState.vmin;
					vel.set_v(speed, 0.001);
					double wspeed = COMP->cdlLookup->getHeading();
					if( wspeed < -20.0 ) wspeed = -20.0;
					if( wspeed >  20.0 ) wspeed =  20.0;
					vel.set_omega( wspeed );
				}
				else
				{
					vel.set_v(vres, 0.001);
					vel.set_omega(wres);
				}

				COMP->navVelSendClient->send(vel);
				//std::cout << "send " << vel << std::endl;



				// -----------------------------------------------------------
				// now check whether stalled behaviour occured
				// -----------------------------------------------------------
				if (COMP->localState.freeBehavior == CommNavigationObjects::CdlTagType::CDL_FREE_BEHAVIOR)
				{
					if ((vres == 0.0) && (wres == 0.0) && (v == 0.0) && (w == 0.0))
					{
						// robot stops and cannot move anymore
						if (stalledFlag == 0)
						{
							// first occurence of stalling situation
							stalledFlag = 1;
							gettimeofday(&beginStalledTime,0);
						}
						else
						{
							// not the first occurence of stalling situation
							gettimeofday(&currentTime,0);
							timeDiff  = (double)(currentTime.tv_usec - beginStalledTime.tv_usec)/1000000.0;
							timeDiff += (double)(currentTime.tv_sec  - beginStalledTime.tv_sec);

							// if (timeDiff > 2.0)
							if (timeDiff > 0.5)
							{
								stalledFlag = 0;
								if (COMP->localState.lookupTable == CommNavigationObjects::CdlTagType::CDL_SECOND_LOOKUP)
								{
									//status = COMP->cdlLookup->freeBehavior(700.0,turnDirection);
									COMP->cdlLookup->freeBehavior(250.0,turnDirection);
								}
								else
								{
									//status = COMP->cdlLookup->freeBehavior(500.0,turnDirection);
									COMP->cdlLookup->freeBehavior(250.0,turnDirection);
								}

								static int lastTurn = 1;

								switch (turnDirection)
								{
								case CDL_FREE_TURN_LEFT:
								{
									cout << "STALLED ==> turn left\n";
									wres = 20.0*M_PI/180.0;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									sleep(1);
									//smartBase.setVelocities(0.0,0.0);
									wres = 0.0;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									lastTurn = 1;
									break;
								}

								case CDL_FREE_TURN_RIGHT:
								{
									cout << "STALLED ==> turn right\n";
									wres = -20.0*M_PI/180.0;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									sleep(1);
									wres = 0.0;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									lastTurn = -1;
									break;
								}

								case CDL_FREE_NO_TURN:
								{
									//cout << "STALLED ==> no chance to free robot\n";
									cout << "STALLED ==> free no turn ?!\n";
									wres = 20.0*M_PI/180.0 * lastTurn;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									sleep(1);
									wres = 0.0;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									break;
								}

								case CDL_FREE_BOTH:
								{
									cout << "STALLED ==> both free ?!\n";
									wres = 20.0*M_PI/180.0 * lastTurn;
									vres = 0.0;
									//wres = 0.0;
									//vres = -30.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									sleep(1);
									wres = 0.0;
									vres = 0.0;
									vel.set_v(vres, 0.001);
									vel.set_omega(wres);
									COMP->navVelSendClient->send(vel);
									break;
								}
								} // switch(turnDirection)
							} // if (timeDiff > 2.0)
						} // if (stalledFlag == 0)
					} // if ((vres == 0.0) && (wres == 0.0) && (v == 0.0) && (w == 0.0))
				} // if (COMP->localState.freeBehavior == CDL_FREE_BEHAVIOR)
			} // if (status != CHS::SMART_OK) <<<---- status = laserClient->getUpdate( scan );
		} // if (status == CHS::SMART_OK) <<<---- status = state->acquire("moverobot");
		// -----------------------------------------------------
		// unlock state at end of while loop
		// -----------------------------------------------------
		status = COMP->stateServer->release("moverobot");

	} // while(1)

	return 0;
} // CDLThread::svc
