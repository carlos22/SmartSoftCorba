//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.8.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#include "SmartOpenRave.hh"

// constructor
SmartOpenRave::SmartOpenRave() {
	std::cout << "constructor SmartOpenRave\n";

	ini.taskPlanningSendServer.serviceName = "taskPlanning";
	ini.eventServer.serviceName = "eventServer";
	ini.pathPlanningSendServer.serviceName = "pathPlanning";
	ini.parameterServer.serviceName = "param";
	ini.stateServer.serviceName = "stateServer";
	ini.manipulatorStatePushTimedClient.serverName = "SmartKatanaServer";
	ini.manipulatorStatePushTimedClient.serviceName = "currentPose";
	ini.manipulatorStatePushTimedClient.interval = 1;
	ini.environmentQueryClient.serverName = "Smart3dPointCloudObjectRecognition";
	ini.environmentQueryClient.serviceName = "environment";
	ini.manipulatorEventClient.serverName = "SmartKatanaServer";
	ini.manipulatorEventClient.serviceName = "eventServer";
	ini.objectQueryClient.serverName = "Smart3dPointCloudObjectRecognition";
	ini.objectQueryClient.serviceName = "objectFeatures";
	ini.trajectorySendClient.serverName = "SmartKatanaServer";
	ini.trajectorySendClient.serviceName = "performTrajectory";
	ini.PortParameter.withManipulator = true;
	ini.PortParameter.withObjectRecognition = true;
	ini.OpenRave.defaultEnvironmentPath = "defaultOpenRave.env.xml";
	ini.OpenRave.robotName = "Katana";
	ini.OpenRave.debugOpenRave = false;
	ini.OpenRave.showCompleteTrajectory = false;
	ini.OpenRave.storedEnvironmentName = "storedEnvironment";
	ini.OpenRave.gui_active = true;
	ini.OpenRave.saveObjectsToFile = false;
	ini.OpenRave.robotPath = "robots/katana.robot.xml";
	ini.OpenRave.storedEnvironmentPath = "";
	ini.OpenRave.saveTrajectoryToFile = false;
	ini.OpenRave.debugSend = false;
}

void SmartOpenRave::init(int argc, char *argv[]) {
	try {
		component = new CHS::SmartComponent("SmartOpenRave", argc, argv);
		loadParameter(argc, argv);

		// create ports
		manipulatorStatePushTimedClient = new CHS::PushTimedClient<CommManipulatorObjects::CommMobileManipulatorState>(component);
		environmentQueryClient = new CHS::QueryClient<CommObjectRecognitionObjects::CommObjectRecognitionId,
				CommObjectRecognitionObjects::CommObjectRecognitionEnvironment>(component);

		taskPlanningSendServer = new CHS::SendServer<CommManipulationPlannerObjects::CommManipulationTaskPlanning>(component,
				ini.taskPlanningSendServer.serviceName, taskPlanningSendHandler);

		manipulatorEventClient = new CHS::EventClient<CommManipulatorObjects::CommManipulatorEventParameter,
				CommManipulatorObjects::CommManipulatorEventResult>(component, manipulatorEventClientHandler);

		objectQueryClient = new CHS::QueryClient<CommObjectRecognitionObjects::CommObjectRecognitionId,
				CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties>(component);
		eventServer = new CHS::EventServer<CommManipulationPlannerObjects::CommManipulationPlannerEventParameter,
				CommManipulationPlannerObjects::CommManipulationPlannerEventResult,
				CommManipulationPlannerObjects::CommManipulationPlannerEventState>(component, ini.eventServer.serviceName,
				eventServerHandler);

		threadPathPlanningSendHandler = new CHS::ThreadQueueSendHandler<CommManipulatorObjects::CommManipulatorTrajectory>(
				pathPlanningSendHandler);
		pathPlanningSendServer = new CHS::SendServer<CommManipulatorObjects::CommManipulatorTrajectory>(component,
				ini.pathPlanningSendServer.serviceName, *threadPathPlanningSendHandler);

		trajectorySendClient = new CHS::SendClient<CommManipulatorObjects::CommManipulatorTrajectory>(component);

		// Added because Handler has to be active but currently it is not possible in the ToolChain
		threadParameterServerHandler = new CHS::ThreadQueueSendHandler<
				CommManipulationPlannerObjects::CommManipulationPlannerParameter>(parameterServerHandler);
		parameterServer = new CHS::SendServer<CommManipulationPlannerObjects::CommManipulationPlannerParameter>(component,
				ini.parameterServer.serviceName, *threadParameterServerHandler);
		// End Add

		stateServer = new CHS::SmartStateServer(component, ini.stateServer.serviceName, stateChangeHandler);
		// define states for stateServer (CHS::SmartStateServer)
		if (stateServer->defineStates("trajectory", "trajectory") != CHS::SMART_OK)
			std::cerr << "ERROR: define state" << std::endl;
		if (stateServer->defineStates("simulation", "simulation") != CHS::SMART_OK)
			std::cerr << "ERROR: define state" << std::endl;
		if (stateServer->defineStates("demonstration", "demonstration") != CHS::SMART_OK)
			std::cerr << "ERROR: define state" << std::endl;

	} catch (const CORBA::Exception &) {
		std::cerr << "Uncaught CORBA exception" << std::endl;
	} catch (...) {
		std::cerr << "Uncaught exception" << std::endl;
	}
}

// run the component
void SmartOpenRave::run() {
	compHandler.onStartup();
	component->run();
	delete component;
}

void SmartOpenRave::loadParameter(int argc, char *argv[]) {
	/*
	 Parameters can be specified via command line -filename=<filename>

	 With this parameter present:
	 - The component will look for the file in the current working directory,
	 a path relative to the current directory or any absolute path
	 - The component will use the default values if the file cannot be found

	 With this parameter absent:
	 - <Name of Component>.ini will be read from current working directory, if found there
	 - $SMART_ROOT/etc/<Name of Component>.ini will be read otherwise
	 - Default values will be used if neither found in working directory or /etc
	 */
	CHS::SmartParameter parameter;

	// load parameters
	try {
		// check if paramfile is given as argument
		bool paramFile = false;
		std::string str;
		for (int i = 0; i < argc; i++) {
			str = argv[i];
			if (str.find("filename") != std::string::npos)
				paramFile = true;
		}

		// if paramfile is given as argument
		if (paramFile == true) {
			std::cout << "load parameter file from argv \n";
			parameter.addFile(argc, argv, "filename", false);
		}
		// else load standard paramfile
		else {
			std::cout << "load SmartOpenRave.ini parameter file\n";
			parameter.addFile("SmartOpenRave.ini");
		}

		// than add command line arguments to allow overwriting of parameters
		// from file
		parameter.addCommandLine("", argc, argv);

		// print all known parameters
		parameter.print(); // TODO remove this


		// load parameter
		parameter.getString("taskPlanningSendServer", "serviceName", ini.taskPlanningSendServer.serviceName);
		parameter.getString("eventServer", "serviceName", ini.eventServer.serviceName);
		parameter.getString("pathPlanningSendServer", "serviceName", ini.pathPlanningSendServer.serviceName);
		parameter.getString("parameterServer", "serviceName", ini.parameterServer.serviceName);
		parameter.getString("stateServer", "serviceName", ini.stateServer.serviceName);
		parameter.getString("manipulatorStatePushTimedClient", "serverName", ini.manipulatorStatePushTimedClient.serverName);
		parameter.getString("manipulatorStatePushTimedClient", "serviceName", ini.manipulatorStatePushTimedClient.serviceName);
		parameter.getInt("manipulatorStatePushTimedClient", "interval", ini.manipulatorStatePushTimedClient.interval);
		parameter.getString("environmentQueryClient", "serverName", ini.environmentQueryClient.serverName);
		parameter.getString("environmentQueryClient", "serviceName", ini.environmentQueryClient.serviceName);
		parameter.getString("manipulatorEventClient", "serverName", ini.manipulatorEventClient.serverName);
		parameter.getString("manipulatorEventClient", "serviceName", ini.manipulatorEventClient.serviceName);
		parameter.getString("objectQueryClient", "serverName", ini.objectQueryClient.serverName);
		parameter.getString("objectQueryClient", "serviceName", ini.objectQueryClient.serviceName);
		parameter.getString("trajectorySendClient", "serverName", ini.trajectorySendClient.serverName);
		parameter.getString("trajectorySendClient", "serviceName", ini.trajectorySendClient.serviceName);
		parameter.getTruthValue("PortParameter", "withManipulator", ini.PortParameter.withManipulator);
		parameter.getTruthValue("PortParameter", "withObjectRecognition", ini.PortParameter.withObjectRecognition);
		parameter.getString("OpenRave", "defaultEnvironmentPath", ini.OpenRave.defaultEnvironmentPath);
		parameter.getString("OpenRave", "robotName", ini.OpenRave.robotName);
		parameter.getTruthValue("OpenRave", "debugOpenRave", ini.OpenRave.debugOpenRave);
		parameter.getTruthValue("OpenRave", "showCompleteTrajectory", ini.OpenRave.showCompleteTrajectory);
		parameter.getString("OpenRave", "storedEnvironmentName", ini.OpenRave.storedEnvironmentName);
		parameter.getTruthValue("OpenRave", "gui_active", ini.OpenRave.gui_active);
		parameter.getTruthValue("OpenRave", "saveObjectsToFile", ini.OpenRave.saveObjectsToFile);
		parameter.getString("OpenRave", "robotPath", ini.OpenRave.robotPath);
		parameter.getString("OpenRave", "storedEnvironmentPath", ini.OpenRave.storedEnvironmentPath);
		parameter.getTruthValue("OpenRave", "saveTrajectoryToFile", ini.OpenRave.saveTrajectoryToFile);
		parameter.getTruthValue("OpenRave", "debugSend", ini.OpenRave.debugSend);

	} catch (const CORBA::Exception &) {
		std::cerr << "Uncaught CORBA exception" << std::endl;
	} catch (const CHS::ParameterError & e) {
		std::cerr << "Exception from parameter handling: " << e << std::endl;
	} catch (...) {
		std::cerr << "Uncaught exception" << std::endl;
	}
}

