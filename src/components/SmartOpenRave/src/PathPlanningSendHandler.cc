//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//  Copyright (C) 2010 Jonas Brich
//
//        brich@mail.hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartOpenRave component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//------------------------------------------------------------------------

#include "PathPlanningSendHandler.hh"
#include "gen/SmartOpenRave.hh"

#include <iostream>
#include "OpenRave.hh"
#include "ManipulatorFactory.hh"

void PathPlanningSendHandler::handleSend(const CommManipulatorObjects::CommManipulatorTrajectory &r) throw () {

	try {
		// ------------------------------------------------
		// check if activated. If not, do nothing with the
		// trajectory otherwise perform it.
		// ------------------------------------------------
		if ((COMP->stateServer->tryAcquire("trajectory") == CHS::SMART_OK) || (COMP->stateServer->tryAcquire("simulation")
				== CHS::SMART_OK)) {
			// release trajectory state so a state change can happen
			COMP->stateServer->release("trajectory");
			COMP->stateServer->release("simulation");
			ErrorHandler::handleMessage("PathPlanningSendHandler called and state TRAJECTORY || SIMULATION", ErrorHandler::INFO,
					COMP->ini.OpenRave.debugSend);

			COMP->manipulatorMode = COMP->SEND_TRAJECTORY;

			try {
				OPENRAVE->applyParameters();
			} catch (std::exception& e) {
				ErrorHandler::handleMessage("Parameters could not be applied. [handleSend in PathPlanningSendHandler]",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
				return;
			} catch (...) {
				ErrorHandler::handleMessage("UnkownError: applyParameters() [handleSend in PathPlanningSendHandler]",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
			}

			// Create temporal variables which are needed for calculation
			OpenRAVE::TrajectoryBasePtr openraveTrajectory;
			std::vector<double> angles;
			CommManipulatorObjects::CommManipulatorTrajectory manipulatorTrajectory;

			CHS::StatusCode status;
			CHS::EventId eventId;
			CommManipulatorObjects::CommManipulatorEventParameter katanaEventParameter;

			SpecificManipulator::Manipulator* specificManipulator = NULL;
			// Create specific Manipulator
			try {
				specificManipulator = MANIPULATORFACTORY->createManipulatorClass(COMP->ini.OpenRave.robotName);
			} catch (std::exception& e) {
				ErrorHandler::handleMessage(
						"Specific Manipulator class could not be created. [handleSend in PathPlanningSendHandler]",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
				return;
			} catch (...) {
				ErrorHandler::handleMessage("UnkownError: createManipulatorClass() [handleSend in PathPlanningSendHandler]",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
			}

			// Set default parameters into the trajectory which will be sent to the Manipulator
			manipulatorTrajectory.set_gripper_action(r.get_gripper_action());
			manipulatorTrajectory.set_wait_until_each_pose_reached(false);
			manipulatorTrajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);

			if (COMP->ini.PortParameter.withManipulator) {
				// Set event to "Goal_not_reached" of the Manipulator so that every other event is recognized
				katanaEventParameter.set_event(CommManipulatorObjects::ManipulatorEvent::GOAL_NOT_REACHED);
				status = COMP->manipulatorEventClient->activate(CHS::continuous, katanaEventParameter, eventId);
				if (status != CHS::SMART_OK) {
					ErrorHandler::handleMessage(
							"Could not activate EventClient of Manipulator. [handleSend in PathPlanningSendHandler]",
							CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
					return;
				}
			} else {
				CHS::SmartGuard guard(COMP->ManipulatorModeMutex);
				COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
				guard.release();
			}

			try {
				OPENRAVE->syncManipulator();
			} catch (openrave_exception& e) {
				ErrorHandler::handleMessage(e.message(),
						CommManipulationPlannerObjects::ManipulationPlannerEvent::MANIPULATOR_SYNC_FAIL, ErrorHandler::ERROR);
				return;
			} catch (...) {
				ErrorHandler::handleMessage("UnkownError: syncManipulator() [handleSend in PathPlanningSendHandler]",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::MANIPULATOR_SYNC_FAIL, ErrorHandler::ERROR);
			}

			// Set component into PLANNING_PATH mode
			ErrorHandler::handleMessage("Planning Path. [handleSend in PathPlanningSendHandler]",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::PLANNING_PATH, ErrorHandler::INFO,
					COMP->ini.OpenRave.debugSend);

			/*
			 * Iterate over the whole trajectory which came on the port but we have a break at the end of the loop.
			 * This means we only take the first values.
			 *
			 * For angle just calculate the path, for point calculate IK and then path.
			 */
			for (uint32_t i = 0; i < r.get_trajectory_size(); ++i) {

				try {
					if (r.get_gripper_action() == CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE
							|| r.get_gripper_action()
									== CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER) {
						OPENRAVE->openGripper();
					} else if (r.get_gripper_action() == CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE
							|| r.get_gripper_action()
									== CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE_OPEN_AFTER) {
						OPENRAVE->closeGripper();
					}
				} catch (openrave_exception& e) {
					ErrorHandler::handleMessage(e.message(), CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN,
							ErrorHandler::ERROR);
					return;
				} catch (...) {
					ErrorHandler::handleMessage("UnkownError: open/close gripper [handleSend in PathPlanningSendHandler]",
							CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
				}

				/*
				 * JOINT_ANGLES in the incoming trajectory
				 */
				if (r.get_valid_values() == CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES) {
					for (uint32_t j = 0; j < r.get_joint_count(); ++j) {
						angles.push_back(r.get_joint_angle(i, j));
					}
					if (!specificManipulator->convertRealAnglesToOpenRaveAngles(angles, angles)) {
						ErrorHandler::handleMessage(
								"Could not convert RealAngles into OpenRaveAngles. [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
						return;
					}
					try {
						if (OPENRAVE->getParameter().simulation_test_ik_only && (COMP->stateServer->tryAcquire("simulation")
								== CHS::SMART_OK)) {
							COMP->stateServer->release("simulation");
							ErrorHandler::handleMessage(
									"IK Solution Found with SIMULATION_TEST_IK_ONLY parameter. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, ErrorHandler::INFO,
									COMP->ini.OpenRave.debugSend);
							return;
						}
						if (!OPENRAVE->planPath(angles, openraveTrajectory)) {
							ErrorHandler::handleMessage("Path planning failed. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
							return;
						}
					} catch (openrave_exception& e) {
						ErrorHandler::handleMessage(e.message(),
								CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
						return;
					} catch (...) {
						ErrorHandler::handleMessage("UnkownError: planPath() for Angles [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
					}
				}
				/*
				 * POSES in the incoming trajectory
				 */
				else if (r.get_valid_values() == CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES) {
					double x = 0;
					double y = 0;
					double z = 0;
					double phi = 0;
					double theta = 0;
					double psi = 0;
					// Get TCP Pose in roboter coordinate system
					r.get_pose_TCP_robot(i, x, y, z, phi, theta, psi, 1);
					cout << "r.get_pose_TCP_robot(i, x, y, z, phi, theta, psi): " << i << "  " << x << "  " << y << "  " << z
							<< "  " << phi << "  " << theta << "  " << psi << std::endl;

					try {
						if (OPENRAVE->getParameter().grasping_simple) {
							if (!OPENRAVE->iterateToGetGraspingIKSolution(x, y, z, angles)) {
								ErrorHandler::handleMessage(
										"Iteration exceeded to find grasping IK solution. [handleSend in PathPlanningSendHandler]",
										CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_IKSOLUTION_FOUND,
										ErrorHandler::ERROR);
								return;
							}
						} else {
							if (!OPENRAVE->calculateIKSolution(x, y, z, phi, theta, psi, angles)) {
								ErrorHandler::handleMessage(
										"IK solution cannot be calculated. [handleSend in PathPlanningSendHandler]",
										CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_IKSOLUTION_FOUND,
										ErrorHandler::ERROR);
								return;
							}
						}
						if (!specificManipulator->removeDummyJointAngles(angles)) {
							ErrorHandler::handleMessage("Could not remove dummy joint. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
							return;
						}
						if (OPENRAVE->getParameter().simulation_test_ik_only && (COMP->stateServer->tryAcquire("simulation")
								== CHS::SMART_OK)) {
							COMP->stateServer->release("simulation");
							ErrorHandler::handleMessage(
									"IK Solution Found with SIMULATION_TEST_IK_ONLY parameter. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, ErrorHandler::INFO,
									COMP->ini.OpenRave.debugSend);
							return;
						}
						if (!OPENRAVE->planPath(angles, openraveTrajectory)) {
							ErrorHandler::handleMessage("Path planning failed. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
							return;
						}
					} catch (openrave_exception& e) {
						ErrorHandler::handleMessage(e.message(),
								CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
						return;
					} catch (...) {
						ErrorHandler::handleMessage("UnkownError: planPath() for Pose [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
					}
				}
				manipulatorTrajectory.set_trajectory_size(openraveTrajectory->GetPoints().size());
				if (r.get_gripper_action() == CommManipulatorObjects::ManipulatorGripperAction::ANGLE) {
					manipulatorTrajectory.set_gripper_angle(i, r.get_gripper_angle(i));
				}
				manipulatorTrajectory.set_joint_count(openraveTrajectory->GetDOF());

				angles.clear();
				angles.resize(openraveTrajectory->GetDOF());
				/*
				 * Iterate over the trajectory calculated by OpenRave and
				 * convert the angles into the real manipulator angles and
				 * set the converted angles into the trajectory sent to the manipulator
				 */
				for (uint32_t j = 0; j < openraveTrajectory->GetPoints().size(); ++j) {
					// Iterate over the joint angles and get them from the calculated trajectory, transform them and store them into the new Comm Object
					if (!specificManipulator->convertOpenRaveAnglesToRealAngles(openraveTrajectory->GetPoints()[j].q, angles)) {
						ErrorHandler::handleMessage(
								"Could not convert OpenRaveAngles into RealAngles. [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
						return;
					}
					for (int32_t k = 0; k < openraveTrajectory->GetDOF(); ++k) {
						manipulatorTrajectory.set_joint_angle(j, k, angles[k]);
					}
				}

				// If i == 0 the while-loop will not work this is because the first trajectory is sent
				// because we assume the arm is stationary at that point.
				/*
				 * At this point the component waits till the manipulator has finished its trajectory
				 * which has been sent before.
				 *
				 * If i == 0 the trajectory is sent directly because we assume the arm is stationary.
				 *
				 * Otherwise it tries to look what the  Manipulator Mode is set to.
				 * If it is set to SEND_TRAJECTORY the trajectory will be sent.
				 * Otherwise it tests if a FAILURE has occurred within the manipulator and
				 * exits properly.
				 */
				CHS::SmartGuard guard(COMP->ManipulatorModeMutex);
				while (COMP->manipulatorMode != COMP->SEND_TRAJECTORY) {
					if (COMP->manipulatorMode == COMP->FAILURE) {

						ErrorHandler::handleMessage(
								"Something wrong with the Manipulator. [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND, ErrorHandler::ERROR);
						return;
					}
					guard.release();
					COMP->ManipulatorWaitSem.acquire();
					guard.acquire();
				}
				guard.release();

				/*
				 * If parallelization mode is true we have to move the manipulator in OpenRAVE to represent the reality.
				 */
				try {
					if (COMP->ini.OpenRave.showCompleteTrajectory || OPENRAVE->getParameter().parallelization) {
						OPENRAVE->moveManipulatorToPosition(openraveTrajectory, false);

						if (r.get_gripper_action() == CommManipulatorObjects::ManipulatorGripperAction::OPEN_AFTER
								|| r.get_gripper_action()
										== CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE_OPEN_AFTER) {
							OPENRAVE->openGripper();
						} else if (r.get_gripper_action() == CommManipulatorObjects::ManipulatorGripperAction::CLOSE_AFTER
								|| r.get_gripper_action()
										== CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER) {
							OPENRAVE->closeGripper();
						}
					}
				} catch (openrave_exception& e) {
					ErrorHandler::handleMessage(e.message(), CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN,
							ErrorHandler::ERROR);
					return;
				} catch (...) {
					ErrorHandler::handleMessage(
							"UnkownError: moveManipulatorToPosition() [handleSend in PathPlanningSendHandler]",
							CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
				}

				if (COMP->stateServer->tryAcquire("trajectory") == CHS::SMART_OK) {
					COMP->stateServer->release("trajectory");
					std::cout << "component is in state TRAJECTORY -> check withManipulator \n";
					if (COMP->ini.PortParameter.withManipulator) {
						/*
						 * Send calculated Trajectory to the Manipulator
						 */
						std::cout << "Send trajectory to manipulator ...\n";
						status = COMP->trajectorySendClient->send(manipulatorTrajectory);
						if (status != CHS::SMART_OK) {
							ErrorHandler::handleMessage(
									"Send of trajectory to Katana component failed. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
							return;
						}
					} else {
						std::cout << "Component is in state TRAJECTORY, but withManipulator is false \n";
					}
				}
				angles.clear();

				/**
				 * We take only the first values of the sent trajectory
				 */
				break;
			}

			// If all points or joint angles in the incoming trajectory has been processed we send the event PATH_FOUND.
			ErrorHandler::handleMessage("Path Planning successful. [handleSend in PathPlanningSendHandler]",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, ErrorHandler::INFO,
					COMP->ini.OpenRave.debugSend);
		} else {
			ErrorHandler::handleMessage("Component not in \"trajectory\" state.\n", ErrorHandler::WARNING);
		}

		std::cout << "PathPlanningSendHandler FINISHED \n\n";
	} catch (openrave_exception& e) {
		ErrorHandler::handleMessage(e.message(), CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN,
				ErrorHandler::ERROR);
	} catch (...) {
		ErrorHandler::handleMessage("UnkownError in [handleSend in PathPlanningSendHandler]",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, ErrorHandler::ERROR);
	}
}
