//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//  Copyright (C) 2010 Jonas Brich
//
//        brich@mail.hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartOpenRave component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//------------------------------------------------------------------------

#include "PathPlanningSendHandler.hh"
#include "gen/SmartOpenRave.hh"

#include <iostream>
#include "OpenRave.hh"
#include "ManipulatorFactory.hh"

void PathPlanningSendHandler::handleSend(const Smart::CommManipulatorTrajectory &r) throw () {

	// ------------------------------------------------
	// check if activated. If not, do nothing with the
	// trajectory otherwise perform it.
	// ------------------------------------------------
	if (COMP->stateServer->tryAcquire("trajectory") == CHS::SMART_OK) {
		// release trajectory state so a state change can happen
		COMP->stateServer->release("trajectory");

		// Create temporal variables which are needed for calculation
		OpenRAVE::TrajectoryBasePtr openraveTrajectory;
		std::vector<double> angles;
		Smart::CommManipulatorTrajectory manipulatorTrajectory;

		CHS::StatusCode status;
		CHS::EventId eventId;
		Smart::CommManipulatorEventParameter katanaEventParameter;

		SpecificManipulator::Manipulator* specificManipulator = NULL;
		// Create specific Manipulator
		try {
			specificManipulator = MANIPULATORFACTORY->createManipulatorClass(COMP->ini.OpenRave.robotName);
		} catch (std::exception& e) {
			return;
		}

		// Set default parameters into the trajectory which will be sent to the Manipulator
		manipulatorTrajectory.set_gripper_action(r.get_gripper_action());
		manipulatorTrajectory.set_wait_until_each_pose_reached(false);
		manipulatorTrajectory.set_valid_values(Smart::JOINT_ANGLES);

		if (COMP->ini.PortParameter.withManipulator) {
			// Set event to "Goal_not_reached" of the Manipulator so that every other event is recognized
			katanaEventParameter.set_event(Smart::GOAL_NOT_REACHED);
			status = COMP->manipulatorEventClient->activate(CHS::continuous, katanaEventParameter, eventId);
			if (status != CHS::SMART_OK) {
				ErrorHandler::handleMessage(
						"Could not activate EventClient of Manipulator. [handleSend in PathPlanningSendHandler]",
						ErrorHandler::ERROR);
				return;
			}
		} else {
			COMP->ManipulatorModeMutex.acquire();
			COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			COMP->ManipulatorModeMutex.release();
		}

		try {
			// Sync OpenRave with the Real Manipulator
			OPENRAVE->syncManipulator();
		} catch (openrave_exception& e) {
			ErrorHandler::handleMessage(e.message(), ErrorHandler::ERROR);
			OPENRAVE->unlockEnvironment();
			return;
		}

		// Set component into PLANNING_PATH mode
		ErrorHandler::handleMessage("Planning Path. [handleSend in PathPlanningSendHandler]", Smart::PLANNING_PATH,
				ErrorHandler::INFO, COMP->ini.OpenRave.debugSend);

		/*
		 * Iterate over the whole trajectory which came on the port.
		 * Calculate for each point or angle in the incoming trajectory a path.
		 * For angle just calculate the path, for point calculate IK and then path.
		 */
		for (uint32_t i = 0; i < r.get_trajectory_size(); ++i) {
			/*
			 * JOINT_ANGLES in the incoming trajectory
			 */
			if (r.get_valid_values() == Smart::JOINT_ANGLES) {
				for (uint32_t j = 0; j < r.get_joint_count(); ++j) {
					angles.push_back(r.get_joint_angle(i, j));
				}
				if (!specificManipulator->convertRealAnglesToOpenRaveAngles(angles, angles)) {
					ErrorHandler::handleMessage(
							"Could not convert RealAngles into OpenRaveAngles. [handleSend in PathPlanningSendHandler]",
							ErrorHandler::ERROR);
					return;
				}
				try {
					if (!OPENRAVE->planPath(angles, openraveTrajectory)) {
						ErrorHandler::handleMessage("Path planning failed. [handleSend in PathPlanningSendHandler]",
								Smart::NO_PATH_FOUND, ErrorHandler::ERROR);
						return;
					}
				} catch (openrave_exception& e) {
					ErrorHandler::handleMessage(e.message(), ErrorHandler::ERROR);
					OPENRAVE->unlockEnvironment();
					return;
				}
			}
			/*
			 * POSES in the incoming trajectory
			 */
			else if (r.get_valid_values() == Smart::POSES) {
				double x = 0;
				double y = 0;
				double z = 0;
				double phi = 0;
				double theta = 0;
				double psi = 0;
				// Get TCP Pose in roboter coordinate system
				r.get_pose_TCP_robot(i, x, y, z, phi, theta, psi, 1);

				try {
					if (!OPENRAVE->calculateIKSolution(x, y, z, phi, theta, psi, angles)) {
						ErrorHandler::handleMessage("IK solution cannot be calculated. [handleSend in PathPlanningSendHandler]",
								Smart::NO_IKSOLUTION_FOUND, ErrorHandler::ERROR);
						return;
					}
					if (!specificManipulator->removeDummyJointAngles(angles)) {
						ErrorHandler::handleMessage("Could not remove dummy joint. [handleSend in PathPlanningSendHandler]",
								Smart::NO_PATH_FOUND, ErrorHandler::ERROR);
						return;
					}
					if (!OPENRAVE->planPath(angles, openraveTrajectory)) {
						ErrorHandler::handleMessage("Path planning failed. [handleSend in PathPlanningSendHandler]",
								Smart::NO_PATH_FOUND, ErrorHandler::ERROR);
						return;
					}
				} catch (openrave_exception& e) {
					ErrorHandler::handleMessage(e.message(), ErrorHandler::ERROR);
					OPENRAVE->unlockEnvironment();
					return;
				}
			}
			manipulatorTrajectory.set_trajectory_size(openraveTrajectory->GetPoints().size());
			if (r.get_gripper_action() == Smart::ANGLE) {
				manipulatorTrajectory.set_gripper_angle(i, r.get_gripper_angle(i));
			}
			manipulatorTrajectory.set_joint_count(openraveTrajectory->GetDOF());

			angles.clear();
			angles.resize(openraveTrajectory->GetDOF());
			/*
			 * Iterate over the trajectory calculated by OpenRave and
			 * convert the angles into the real manipulator angles and
			 * set the converted angles into the trajectory sent to the manipulator
			 */
			for (uint32_t j = 0; j < openraveTrajectory->GetPoints().size(); ++j) {
				// Iterate over the joint angles and get them from the calculated trajectory, transform them and store them into the new Comm Object
				if (!specificManipulator->convertOpenRaveAnglesToRealAngles(openraveTrajectory->GetPoints()[j].q, angles)) {
					ErrorHandler::handleMessage(
							"Could not convert OpenRaveAngles into RealAngles. [handleSend in PathPlanningSendHandler]",
							ErrorHandler::ERROR);
					return;
				}
				for (int32_t k = 0; k < openraveTrajectory->GetDOF(); ++k) {
					manipulatorTrajectory.set_joint_angle(j, k, angles[k]);
				}
			}

			// If i == 0 the while-loop will not work this is because the first trajectory is sent
			// because we assume the arm is stationary at that point.
			/*
			 * At this point the component waits till the manipulator has finished its trajectory
			 * which has been sent before.
			 *
			 * If i == 0 the trajectory is sent directly because we assume the arm is stationary.
			 *
			 * Otherwise it tries to look what the  Manipulator Mode is set to.
			 * If it is set to SEND_TRAJECTORY the trajectory will be sent.
			 * Otherwise it tests if a FAILURE has occurred within the manipulator and
			 * exits properly.
			 */
			COMP->ManipulatorModeMutex.acquire();
			while (i > 0 && COMP->manipulatorMode != COMP->SEND_TRAJECTORY) {
				if (COMP->manipulatorMode == COMP->FAILURE) {
					COMP->ManipulatorModeMutex.release();

					ErrorHandler::handleMessage("Something wrong with the Manipulator. [handleSend in PathPlanningSendHandler]",
							Smart::NO_PATH_FOUND, ErrorHandler::ERROR);
					return;
				}
				COMP->ManipulatorModeMutex.release();
				COMP->ManipulatorWaitSem.acquire();
				COMP->ManipulatorModeMutex.acquire();
			}
			COMP->ManipulatorModeMutex.release();

			/*
			 * If the incoming trajectory contains more than one point or set of joint angles,
			 * the manipulator in OpenRave has to be moved to represent the reality.
			 */
			if (r.get_trajectory_size() >= 1) {
				try {
					OPENRAVE->moveManipulatorToPosition(openraveTrajectory, false);
				} catch (openrave_exception& e) {
					ErrorHandler::handleMessage(e.message(), ErrorHandler::ERROR);
					OPENRAVE->unlockEnvironment();
					return;
				}
			}

			if (COMP->ini.PortParameter.withManipulator) {
				/*
				 * Send calculated Trajectory to the Manipulator
				 */
				status = COMP->trajectorySendClient->send(manipulatorTrajectory);
				if (status != CHS::SMART_OK) {
					ErrorHandler::handleMessage(
							"Send of trajectory to Katana component failed. [handleSend in PathPlanningSendHandler]",
							ErrorHandler::ERROR);
					return;
				}
			}
			angles.clear();
		}

		// If all points or joint angles in the incoming trajectory has been processed we send the event PATH_FOUND.
		ErrorHandler::handleMessage("Path Planning successful. [handleSend in PathPlanningSendHandler]", Smart::PATH_FOUND,
				ErrorHandler::INFO, COMP->ini.OpenRave.debugSend);
	} else {
		ErrorHandler::handleMessage("Component not in \"trajectory\" state.\n", ErrorHandler::WARNING);
	}
}
