//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartKatanaTestClient component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "TestTask.hh"
#include "gen/SmartKatanaTestClient.hh"

#include "data/ObjectSet.hh"
#include "data/Color.hh"

#include <CommObjectRecognitionObjects/commObjectRecognitionParameter.hh>
#include <CommObjectRecognitionObjects/commObjectRecognitionEventResult.hh>
#include <CommObjectRecognitionObjects/commObjectRecognitionObjectProperties.hh>
#include <CommObjectRecognitionObjects/commObjectRecognitionId.hh>

#include <CommManipulationPlannerObjects/commManipulationPlannerParameter.hh>
#include <CommManipulationPlannerObjects/commManipulationPlannerEventParameter.hh>
#include <CommManipulationPlannerObjects/commManipulationPlannerEventResult.hh>

#include <CommManipulatorObjects/commMobileManipulatorState.hh>
#include <CommManipulatorObjects/commManipulatorEventParameter.hh>
#include <CommManipulatorObjects/commManipulatorEventResult.hh>

#include <CommBasicObjects/commMobileLaserScan.hh>
#include <CommBasicObjects/commPose3d.hh>
#include <CommBasicObjects/commVoid.hh>

#include <CommVisionObjects/comm3dPointCloud.hh>

#include <mrpt/core.h>

#include <iostream>
#include <ctime>

using namespace mrpt::math;

TestTask::TestTask() {
	std::cout << "constructor TestTask\n";
}

int TestTask::svc() {
	int mainMenuItem;

	std::cout << "------------------------------------------------------------------------\n";
	std::cout << "| SmartKatanaTestClient                                                |\n";
	std::cout << "| ZAFH Servicerobotik Ulm                                              |\n";
	std::cout << "| Copyright (C) 2010 Christian Schlegel, Manuel Wopfner                |\n";

	while (1) {
		// main menu
		std::cout << "\n------------------------------------------------------------------------\n";
		std::cout << "Main Menu:\n";

		std::cout << " --- Manipulator ----\n";
		std::cout << " 01 - move between two points\n";
		std::cout << " 02 - reproduce trajectory\n";
		std::cout << " 03 - demonstration mode (will not return)\n";
		std::cout << " 04 - test Hokuyo laser (will not return)\n";
		std::cout << " 05 - show laser scan (requires opengl window in init file)\n";
		std::cout << " 06 - show 3d point cloud (requires opengl window in init file)\n";
		std::cout << " 07 - recognize objects\n";
		std::cout << " --- OpenRave -------\n";
		std::cout << " 08 - change states\n";
		std::cout << " 09 - save OpenRave\n";
		std::cout << " 10 - load OpenRave\n";
		std::cout << " 11 - delete Object\n";
		std::cout << " 12 - calculate grasp table\n";
		std::cout << " 13 - move Object\n";
		std::cout << " 14 - add known Object\n";
		std::cout << " 19 - test simulation\n";
		std::cout << " --- Scenarios ------\n";
		std::cout << " 20- stack mugs\n";
		std::cout << " --- ObjectRecognition ------\n";
		std::cout << " 30 - learn new object\n";

		std::cout << " <ctrl> + <c> for exit\n";
		std::cout << "------------------------------------------------------------------------\n";

		std::cout << "\nplease choose number:  ";
		cin >> mainMenuItem;

		// sub menu
		switch (mainMenuItem) {

		// 1 - Mapper state
		case 1:
			move2Points();
			break;

		case 2:
			reproduceTrajectory();
			break;

		case 3:
			demonstration();
			break;

		case 4:
			laserTest();
			break;

		case 5:
			showLaserScan();
			break;

		case 6:
			show3dPointCloud();
			break;

		case 7:
			recognizeObjects();
			break;

		case 8:
			openRaveChangeState();
			break;

		case 9:
			openRaveSave();
			break;

		case 10:
			openRaveLoad();
			break;

		case 11:
			openRaveDeleteObject();
			break;

		case 12:
			openRaveComputeGraspTable();
			break;

		case 13:
			openRaveMoveObject();
			break;

		case 14:
			openRaveAddObject();
			break;

		case 19:
			openRaveTestSimulation();
			break;

		case 20:
			stackMugs();
			break;

		case 30:
			learnNewObject();
			break;
		}
	}
	return 0;
}

void TestTask::move2Points() {
	ObjectSet::getInstance().clearAll();
	ObjectSet::getInstance().drawBaseCoord();
	COMP->manipulatorStateClient->setWaitState("trajectory");

	double x, y, z, azimuth, elevation, roll;

	CommManipulatorObjects::CommManipulatorTrajectory trajectory;
	//	trajectory.set_valid_values(Smart::POSES);
	//	trajectory.set_trajectory_size(1);
	//	trajectory.set_wait_until_each_pose_reached(false);

	std::cout << ">> move to point 1\n";
	trajectory.set_pose_TCP_robot(0, 55.8827, -484.092, 1232.6513, 0.172917, -0.0665965, 1.61083);
	// OpenRave Test Point Seite Rechts
	//		trajectory.set_pose_TCP_robot(0, 216.976, -342.156, 731.209, 0.62494, -0.00921316, 1.60154);
	// OpenRave Test Point Unten Rechts
	//	trajectory.set_pose_TCP_robot(0, 229.141, -294.318, 457.664, 0.709226, -0.00646269, 2.67087);
	// OpenRave Test Point Greifposi vorne
	//trajectory.set_pose_TCP_robot(0, 484.307, 6.42404, 767.694, 1.57909, -1.09944, 1.57551);

	//trajectory.set_pose_TCP_robot(0, -23.2687, -296.799, 130.154, 0.0301376, 0.00039049, 3.08931);
	//trajectory.set_pose_TCP_robot(0, 402.39, -309.891, 456.489, 0.962235, 0.0918086, 1.71466);
	//trajectory.set_pose_TCP_robot(0, 317.139, -444.842, 445.375, 0.679218, 0.0623768, 1.83056);
	//trajectory.set_pose_TCP_robot(0, 55.8827, -484.092, 632.6513, 0.172917, -0.0665965, 1.61083);
	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE_OPEN_AFTER);
	COMP->manipulatorTrajectorySendClient->send(trajectory);

	//	sleep(1);

	// OpenRave End Point
	//	trajectory.set_pose_TCP_robot(0, -60.7063, -1.79866, 1040.53, 1.65256, 0.00620259, -0.260621);
	trajectory.set_pose_TCP_robot(0, 55.8827, -484.092, 632.6513, 0.172917, -0.0665965, 1.61083);

	trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
	trajectory.set_trajectory_size(2);
	trajectory.set_joint_count(5);
	trajectory.set_wait_until_each_pose_reached(false);
	// End Point
	trajectory.set_joint_angle(1, 0, 3.10524);
	trajectory.set_joint_angle(1, 1, 2.13827);
	trajectory.set_joint_angle(1, 2, 0.932138);
	trajectory.set_joint_angle(1, 3, 1.11356);
	trajectory.set_joint_angle(1, 4, 3.07568);
	// Start Point
	trajectory.set_joint_angle(0, 0, 3.45499);
	trajectory.set_joint_angle(0, 1, 1.12093);
	trajectory.set_joint_angle(0, 2, 1.81154);
	trajectory.set_joint_angle(0, 3, 2.95507);
	trajectory.set_joint_angle(0, 4, 3.15446);
	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER);
	COMP->manipulatorTrajectorySendClient->send(trajectory);

	return;

	trajectory.get_pose_TCP_robot(0, x, y, z, azimuth, elevation, roll, 1);
	CommBasicObjects::CommPose3d tcp_pose1(x, y, z, azimuth, elevation, roll, 1);
	ObjectSet::getInstance().drawCoord(tcp_pose1, 0.1);

	sleep(5);

	std::cout << ">> move to point 2\n";
	trajectory.set_pose_TCP_robot(0, -112.343, -5.01603, 1030.504, 1.69581, 0.0262978, -0.388376);
	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
	COMP->manipulatorTrajectorySendClient->send(trajectory);

	trajectory.get_pose_TCP_robot(0, x, y, z, azimuth, elevation, roll, 1);
	CommBasicObjects::CommPose3d tcp_pose2(x, y, z, azimuth, elevation, roll, 1);
	ObjectSet::getInstance().drawCoord(tcp_pose2, 0.1);

	sleep(5);
}

void TestTask::reproduceTrajectory() {
	ObjectSet::getInstance().clearAll();
	COMP->manipulatorStateClient->setWaitState("demonstration");

	uint32_t trajectorySize = 100;

	CommManipulatorObjects::CommManipulatorTrajectory trajectory;
	trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::ANGLE);
	trajectory.set_trajectory_size(trajectorySize);
	trajectory.set_joint_count(5);
	trajectory.set_wait_until_each_pose_reached(false);

	bool firstValue = true;

	CommManipulatorObjects::CommManipulatorTrajectory startPosition;
	startPosition.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
	startPosition.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE);
	startPosition.set_trajectory_size(1);
	startPosition.set_joint_count(5);
	startPosition.set_wait_until_each_pose_reached(true);

	// activate event
	CHS::EventId id;
	CHS::StatusCode status;
	CommManipulatorObjects::CommManipulatorEventResult result;
	CommManipulatorObjects::CommManipulatorEventParameter parameter;

	parameter.set_event(CommManipulatorObjects::ManipulatorEvent::GOAL_REACHED);
	COMP->manipulatorEventClient->activate(CHS::continuous, parameter, id);

	uint32_t counter = 0;
	CommManipulatorObjects::CommMobileManipulatorState state;
	while (counter < trajectorySize) {
		COMP->manipulatorPosePushTimedClient->getUpdateWait(state);

		if (state.is_valid()) {
			ObjectSet::getInstance().clearLines();
			ObjectSet::getInstance().drawBaseCoord();

			double x, y, z, azimuth, elevation, roll;
			state.get_manipulator_state().get_pose_TCP_manipulator(x, y, z, azimuth, elevation, roll, 1);

			CommBasicObjects::CommPose3d tcp_pose(x, y, z, azimuth, elevation, roll, 1);
			ObjectSet::getInstance().drawCoord(tcp_pose, 0.1);

			ObjectSet::getInstance().addPoint(x, y, z, Color::SlateBlue1);

			if (counter == 0) {
				for (uint32_t i = 0; i < state.get_manipulator_state().get_joint_count(); ++i) {
					startPosition.set_joint_angle(counter, i, state.get_manipulator_state().get_joint_angle(i));
				}

				firstValue = false;
			}

			for (uint32_t i = 0; i < state.get_manipulator_state().get_joint_count(); ++i) {
				trajectory.set_joint_angle(counter, i, state.get_manipulator_state().get_joint_angle(i));
			}

			state.get_manipulator_state().print();
			std::cout.flush();
			counter++;
		} else {
			std::cout << "invalid state\n";
		}
	}

	std::cout << "switch state to trajectory\n";
	COMP->manipulatorStateClient->setWaitState("trajectory");

	// start position
	std::cout << "move to start pos\n";
	COMP->manipulatorTrajectorySendClient->send(startPosition);

	std::cout << "wait for goal\n";
	status = COMP->manipulatorEventClient->getEvent(id, result);
	if (status == CHS::SMART_OK) {
		std::cout << ">> Goal Reached!\n";
	}

	sleep(1);

	// reproduce recorded trajectory
	std::cout << "send trajectory\n";
	COMP->manipulatorTrajectorySendClient->send(trajectory);

	COMP->katanaGoalReached = false;
	while (!COMP->katanaGoalReached) {
		std::cout << "wait for state\n";
		COMP->manipulatorPosePushTimedClient->getUpdateWait(state);

		if (state.is_valid()) {
			ObjectSet::getInstance().clearLines();
			ObjectSet::getInstance().drawBaseCoord();

			double x, y, z, azimuth, elevation, roll;
			state.get_manipulator_state().get_pose_TCP_manipulator(x, y, z, azimuth, elevation, roll, 1);

			std::cout << x << ", " << y << ", " << z << ", " << azimuth << ", " << elevation << ", " << roll << "\n";

			CommBasicObjects::CommPose3d tcp_pose(x, y, z, azimuth, elevation, roll, 1);
			ObjectSet::getInstance().drawCoord(tcp_pose, 0.1);

			ObjectSet::getInstance().addPoint(x, y, z, Color::DarkOrange);

			state.get_manipulator_state().print();
			std::cout.flush();
		} else {
			std::cout << "invalid state\n";
		}

	}

	std::cout << "switch state to neutral ...\n";
	COMP->manipulatorStateClient->setWaitState("neutral");
	std::cout << "switch state to neutral done\n";
}

void TestTask::demonstration() {
	ObjectSet::getInstance().clearAll();
	COMP->manipulatorStateClient->setWaitState("demonstration");
	COMP->openRaveStateClient->setWaitState("demonstration");

	CommManipulatorObjects::CommMobileManipulatorState state;
	while (true) {
		if (CHS::SMART_OK == COMP->manipulatorPosePushTimedClient->getUpdateWait(state)) {
			state.get_manipulator_state().print();
			std::cout.flush();

			if (COMP->ini.connect_services.continous_scan)
				ObjectSet::getInstance().clearLines();
			else
				ObjectSet::getInstance().clearAll();
			ObjectSet::getInstance().drawBaseCoord();

			CommBasicObjects::CommPose3d base_pose = state.get_base_state().get_base_position().get_base_pose3d();
			ObjectSet::getInstance().drawCoord(base_pose, 0.15);

			double x, y, z, azimuth, elevation, roll;
			state.get_manipulator_state().get_pose_manipulator(x, y, z, azimuth, elevation, roll, 1);
			CommBasicObjects::CommPose3d manipulator_pose(x, y, z, azimuth, elevation, roll, 1);
			ObjectSet::getInstance().drawCoord(base_pose.getHomogeneousMatrix(1)
					* manipulator_pose.getHomogeneousMatrix(1), 0.1);

			state.get_manipulator_state().get_pose_TCP_robot(x, y, z, azimuth, elevation, roll, 1);
			CommBasicObjects::CommPose3d tcp_pose(x, y, z, azimuth, elevation, roll, 1);
			//tcp_pose.print();
			ObjectSet::getInstance().drawCoord(base_pose.getHomogeneousMatrix(1) * tcp_pose.getHomogeneousMatrix(1),
					0.1);

			if (COMP->ini.connect_services.continous_scan) {
				arma::vec point(4);
				point[0] = x;
				point[1] = y;
				point[2] = z;
				point[3] = 1;
				point = base_pose.getHomogeneousMatrix(1) * point;
				ObjectSet::getInstance().addPoint(point[0], point[1], point[2], Color::SlateBlue1);
			}

		} else {
			std::cerr << "could not read manipulator state\n";
		}
	}
}

void TestTask::laserTest() {

	int mainMenuItem;

	std::cout << "\n------------------------------------------------------------------------\n";
	std::cout << "laser test Menu:\n";

	std::cout << " 01 - push timed\n";
	std::cout << " 02 - query (single shot)\n";

	std::cout << " <ctrl> + <c> for exit\n";
	std::cout << "------------------------------------------------------------------------\n";

	std::cout << "\nplease choose number:  ";
	cin >> mainMenuItem;

	switch (mainMenuItem) {
	case 1: {
		std::cout << "PUSH TIMED\n";
		COMP->laserStateClient->setWaitState("active");
		CommBasicObjects::CommMobileLaserScan scan;
		while (true) {
			if (CHS::SMART_OK == COMP->laserPushTimedClient->getUpdateWait(scan) && scan.get_scan_size() > 0) {
				const unsigned int index = scan.get_scan_size() / 2;
				std::cout << "Scan Position " << index << "/" << scan.get_scan_size() << " = "
						<< scan.get_scan_distance(index) << " mm" << std::endl;
			} else {
				std::cerr << "could not read laser scan\n";
				sleep(1);
			}

		}
		break;
	}
	case 2: {
		std::cout << "QUERY\n";

		COMP->laserStateClient->setWaitState("active");
		CommBasicObjects::CommVoid request;
		CommBasicObjects::CommMobileLaserScan scan;

		// wait for first scan
		sleep(1);

		if (CHS::SMART_OK == COMP->laserQueryClient->query(request, scan) && scan.get_scan_size() > 0) {

			int counter = 0;
			for (CommBasicObjects::CommMobileLaserScan::const_polar_iterator iter = scan.polar_begin(); iter != scan.polar_end(); iter++) {
				std::cout << counter << "| angle = " << (*iter).angle << " [rad], dist = " << (*iter).distance
						<< " [mm]" << std::endl;
				counter++;
			}

		} else {
			std::cerr << "could not read laser scan\n";
			sleep(1);
		}

		break;
	}
	}
}

void TestTask::showLaserScan() {
	int mainMenuItem;

	std::cout << "\n------------------------------------------------------------------------\n";
	std::cout << "Show laser scan Menu:\n";

	std::cout << " 01 - show in sensor coordinate system\n";
	std::cout << " 02 - show in robot coordinate system\n";
	std::cout << " 03 - show in world coordinate system\n";

	std::cout << " <ctrl> + <c> for exit\n";
	std::cout << "------------------------------------------------------------------------\n";

	std::cout << "\nplease choose number:  ";
	cin >> mainMenuItem;

	ObjectSet::getInstance().clearAll();
	ObjectSet::getInstance().drawBaseCoord();

	COMP->laserStateClient->setWaitState("active");
	COMP->manipulatorStateClient->setWaitState("trajectory");
	CommBasicObjects::CommMobileLaserScan scan;

	double x, y, z = 0;
	switch (mainMenuItem) {
	case 1:
		while (true) {
			if (CHS::SMART_OK == COMP->laserPushTimedClient->getUpdateWait(scan)) {

				ObjectSet::getInstance().clearPoints();
				for (uint32_t i = 0; i < scan.get_scan_size(); ++i) {
					scan.get_scan_cartesian_point_scanner(i, x, y, 1);
					ObjectSet::getInstance().addPoint(x, y, 0, Color::Red);
				}

			} else {
				std::cerr << "could not read laser scan\n";
				sleep(1);
			}

		}
		break;
	case 2:
		while (true) {
			if (CHS::SMART_OK == COMP->laserPushTimedClient->getUpdateWait(scan)) {

				if (COMP->ini.connect_services.continous_scan)
					ObjectSet::getInstance().clearLines();
				else
					ObjectSet::getInstance().clearAll();
				ObjectSet::getInstance().drawBaseCoord();

				CommBasicObjects::CommPose3d sensor_pose = scan.get_sensor_pose();
				ObjectSet::getInstance().drawCoord(sensor_pose, 0.1);

				for (uint32_t i = 0; i < scan.get_scan_size(); ++i) {
					scan.get_scan_cartesian_3dpoint_robot(i, x, y, z, 1);
					ObjectSet::getInstance().addPoint(x, y, z, Color::Red);
				}

			} else {
				std::cerr << "could not read laser scan\n";
				sleep(1);
			}

		}
		break;
	case 3:
		while (true) {
			if (CHS::SMART_OK == COMP->laserPushTimedClient->getUpdateWait(scan)) {

				if (COMP->ini.connect_services.continous_scan)
					ObjectSet::getInstance().clearLines();
				else
					ObjectSet::getInstance().clearAll();
				ObjectSet::getInstance().drawBaseCoord();

				CommBasicObjects::CommPose3d base_pose = scan.get_base_state().get_base_position().get_base_pose3d();
				ObjectSet::getInstance().drawCoord(base_pose, 0.15);

				CommBasicObjects::CommPose3d sensor_pose = scan.get_sensor_pose();
				arma::mat mat_world_sensor = base_pose.getHomogeneousMatrix(1) * sensor_pose.getHomogeneousMatrix(1);
				ObjectSet::getInstance().drawCoord(mat_world_sensor, 0.1);

				for (uint32_t i = 0; i < scan.get_scan_size(); ++i) {
					scan.get_scan_cartesian_3dpoint_world(i, x, y, z, 1);
					ObjectSet::getInstance().addPoint(x, y, z, Color::Red);
				}

			} else {
				std::cerr << "could not read laser scan\n";
				sleep(1);
			}

		}
		break;

	}
}

void TestTask::show3dPointCloud() {
	int mainMenuItem;

	std::cout << "\n------------------------------------------------------------------------\n";
	std::cout << "Show point cloud Menu:\n";

	std::cout << " 01 - capture new point cloud (mode 1)\n";
	std::cout << " 02 - capture new point cloud (mode 2)\n";
	std::cout << " 03 - get point cloud from katana\n";
	std::cout << " 04 - get point cloud from katana and save to \"point_cloud.csv\"\n";

	std::cout << " <ctrl> + <c> for exit\n";
	std::cout << "------------------------------------------------------------------------\n";

	std::cout << "\nplease choose number:  ";
	cin >> mainMenuItem;

	CommManipulatorObjects::CommManipulatorRequestScan3d scanRequest;
	CommManipulatorObjects::CommManipulatorId scanId;
	CommVisionObjects::Comm3dPointCloud cloud;

	CommBasicObjects::CommVoid parameter;
	CHS::EventId id;

	switch (mainMenuItem) {
	case 1: {
		COMP->manipulatorStateClient->setWaitState("scan");
		COMP->laserStateClient->setWaitState("active");

		scanRequest.set_laser_begin_angle(5.5);
		scanRequest.set_laser_end_angle(1.5);

		scanRequest.set_joint_count(5);

		scanRequest.set_begin_joint_angle(0, 4.3);
		scanRequest.set_end_joint_angle(0, 2.2);

		scanRequest.set_begin_joint_angle(1, 1.96);
		scanRequest.set_end_joint_angle(1, 1.96);

		scanRequest.set_begin_joint_angle(2, 2.76);
		scanRequest.set_end_joint_angle(2, 2.76);

		scanRequest.set_begin_joint_angle(3, 4.68);
		scanRequest.set_end_joint_angle(3, 4.68);

		scanRequest.set_begin_joint_angle(4, 4.75);
		scanRequest.set_end_joint_angle(4, 4.75);

		scanRequest.set_step_count(200);

		std::cout << "start scanning ...\n";

		timeval a;
		timeval b;
		gettimeofday(&a, 0);
		COMP->manipulatorRequestScan3dSendClient->send(scanRequest);

		COMP->manipulatorScanEventClient->activate(CHS::single, parameter, id);
		COMP->manipulatorScanEventClient->getEvent(id, scanId);

		gettimeofday(&b, 0);
		std::cout << "time for scan: " << (b.tv_sec - a.tv_sec) << " s\n";

		COMP->manipulatorStateClient->setWaitState("trajectory");

		std::cout << ">> move to standby position\n";
		CommManipulatorObjects::CommManipulatorTrajectory trajectory;
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
		trajectory.set_trajectory_size(1);
		trajectory.set_joint_count(5);
		trajectory.set_wait_until_each_pose_reached(false);

		trajectory.set_joint_angle(0, 0, 3.1412);
		trajectory.set_joint_angle(0, 1, 2.13688);
		trajectory.set_joint_angle(0, 2, 0.934839);
		trajectory.set_joint_angle(0, 3, 1.11344);
		trajectory.set_joint_angle(0, 4, 3.10611);

		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
		COMP->manipulatorTrajectorySendClient->send(trajectory);

		COMP->laserStateClient->setWaitState("neutral");
		break;
	}
	case 2: {
		COMP->manipulatorStateClient->setWaitState("scan");
		COMP->laserStateClient->setWaitState("active");

		//scanRequest.set_laser_begin_angle(5.5);
		//scanRequest.set_laser_end_angle(1.5);

		scanRequest.set_joint_count(5);

		scanRequest.set_begin_joint_angle(0, 4.7);
		scanRequest.set_end_joint_angle(0, 4);

		scanRequest.set_begin_joint_angle(1, 1.96);
		scanRequest.set_end_joint_angle(1, 1.96);

		scanRequest.set_begin_joint_angle(2, 2.76);
		scanRequest.set_end_joint_angle(2, 2.76);

		scanRequest.set_begin_joint_angle(3, 4.68);
		scanRequest.set_end_joint_angle(3, 4.68);

		scanRequest.set_begin_joint_angle(4, 4.7);
		scanRequest.set_end_joint_angle(4, 5.6);

		scanRequest.set_step_count(200);

		std::cout << "start scanning ...\n";
		COMP->manipulatorRequestScan3dSendClient->send(scanRequest);

		COMP->manipulatorScanEventClient->activate(CHS::single, parameter, id);
		COMP->manipulatorScanEventClient->getEvent(id, scanId);

		COMP->manipulatorStateClient->setWaitState("trajectory");

		std::cout << ">> move to standby position\n";
		CommManipulatorObjects::CommManipulatorTrajectory trajectory;
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
		trajectory.set_trajectory_size(1);
		trajectory.set_joint_count(5);
		trajectory.set_wait_until_each_pose_reached(false);

		trajectory.set_joint_angle(0, 0, 3.1412);
		trajectory.set_joint_angle(0, 1, 2.13688);
		trajectory.set_joint_angle(0, 2, 0.934839);
		trajectory.set_joint_angle(0, 3, 1.11344);
		trajectory.set_joint_angle(0, 4, 3.10611);

		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
		COMP->manipulatorTrajectorySendClient->send(trajectory);

		COMP->laserStateClient->setWaitState("neutral");
		break;
	}
	case 3: {
		uint32_t pointCloudId;
		cout << "\nEnter point cloud id: ";
		cin >> pointCloudId;

		scanId.set_id(pointCloudId);
		scanId.set_valid(true);

		break;
	}
	case 4: {
		uint32_t pointCloudId;
		cout << "\nEnter point cloud id: ";
		cin >> pointCloudId;

		scanId.set_id(pointCloudId);
		scanId.set_valid(true);

		COMP->manipulatorScan3dQueryClient->query(scanId, cloud);

		//save cloud to csv file
		std::cout << "save point cloud to file\n";
		ofstream csv_file;
		csv_file.open("data/point_cloud.csv");

		double x, y, z;
		for (uint32_t i = 0; i < cloud.get_size(); ++i) {
			cloud.get_point(i, x, y, z);
			csv_file << x << "," << y << "," << z << "\n";
		}
		csv_file.close();

		break;
	}
	}

	if (scanId.is_valid()) {
		std::cout << "Scan Id: " << scanId.get_id() << "\n";

		std::cout << "get point cloud...\n";
		COMP->manipulatorScan3dQueryClient->query(scanId, cloud);

		double x, y, z;
		ObjectSet::getInstance().clearAll();
		ObjectSet::getInstance().drawBaseCoord();

		std::cout << "point cloud size: " << cloud.get_size() << "\n";
		for (uint32_t i = 0; i < cloud.get_size(); ++i) {
			cloud.get_point(i, x, y, z, 1);
			ObjectSet::getInstance().addPoint(x, y, z, Color::Red);
		}
	}

}

void TestTask::recognizeObjects() {
	CommManipulatorObjects::CommManipulatorRequestScan3d scanRequest;
	CommManipulatorObjects::CommManipulatorId scanId;
	CommVisionObjects::Comm3dPointCloud cloud;

	int mainMenuItem;

	std::cout << "\n------------------------------------------------------------------------\n";
	std::cout << "Show point cloud Menu:\n";

	std::cout << " 01 - capture new point cloud\n";
	std::cout << " 02 - get point cloud from katana\n";

	std::cout << " <ctrl> + <c> for exit\n";
	std::cout << "------------------------------------------------------------------------\n";

	std::cout << "\nplease choose number:  ";
	cin >> mainMenuItem;

	switch (mainMenuItem) {
	case 1: {
		CHS::EventId id;
		CommBasicObjects::CommVoid parameter;

		// capture laser scan
		COMP->manipulatorStateClient->setWaitState("scan");
		COMP->laserStateClient->setWaitState("active");

		scanRequest.set_laser_begin_angle(5.5);
		scanRequest.set_laser_end_angle(1.5);

		scanRequest.set_joint_count(5);

		scanRequest.set_begin_joint_angle(0, 4.3);
		scanRequest.set_end_joint_angle(0, 2.2);

		scanRequest.set_begin_joint_angle(1, 1.96);
		scanRequest.set_end_joint_angle(1, 1.96);

		scanRequest.set_begin_joint_angle(2, 2.76);
		scanRequest.set_end_joint_angle(2, 2.76);

		scanRequest.set_begin_joint_angle(3, 4.68);
		scanRequest.set_end_joint_angle(3, 4.68);

		scanRequest.set_begin_joint_angle(4, 4.75);
		scanRequest.set_end_joint_angle(4, 4.75);

		scanRequest.set_step_count(200);

		timeval a;
		timeval b;
		gettimeofday(&a, 0);

		std::cout << "start scanning ...\n";
		COMP->manipulatorScanEventClient->activate(CHS::single, parameter, id);
		COMP->manipulatorRequestScan3dSendClient->send(scanRequest);

		COMP->manipulatorScanEventClient->getEvent(id, scanId);

		gettimeofday(&b, 0);
		std::cout << "time for scan: " << (b.tv_sec - a.tv_sec) << " s\n";

		COMP->laserStateClient->setWaitState("neutral");
		COMP->manipulatorStateClient->setWaitState("trajectory");

		CommManipulatorObjects::CommManipulatorTrajectory trajectory;
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES);
		trajectory.set_trajectory_size(1);
		trajectory.set_wait_until_each_pose_reached(false);

		std::cout << ">> move to standby position\n";
		trajectory.set_pose_TCP_robot(0, -80.919, -3.17711, 1030.74, -0.00959797, -0.384639, 0.0183387);

		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
		COMP->manipulatorTrajectorySendClient->send(trajectory);
		break;
	}
	case 2: {
		uint32_t pointCloudId;
		cout << "\nEnter point cloud id: ";
		cin >> pointCloudId;

		scanId.set_id(pointCloudId);
		scanId.set_valid(true);

		break;
	}
	}

	// show laser scan
	if (scanId.is_valid()) {
		std::cout << "Scan Id: " << scanId.get_id() << "\n";

		std::cout << "get point cloud...\n";
		COMP->manipulatorScan3dQueryClient->query(scanId, cloud);

		double x, y, z;
		ObjectSet::getInstance().clearAll();
		ObjectSet::getInstance().drawBaseCoord();

		std::cout << "point cloud size: " << cloud.get_size() << "\n";
		for (uint32_t i = 0; i < cloud.get_size(); ++i) {
			cloud.get_point(i, x, y, z, 1);
			ObjectSet::getInstance().addPoint(x, y, z, Color::Red);
		}

		//////////////////////////////////////
		// perform object recognition
		//////////////////////////////////////
		std::cout << "start object recognition...\n";

		// activate recognition
		COMP->recognitionStateClient->setWaitState("active");

		CommObjectRecognitionObjects::CommObjectRecognitionParameter param;

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::CLOUD);
		param.set_cloud_id(scanId.get_id());
		COMP->recognitionParameterClient->send(param);

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::BEHAVIOR);
		param.set_behavior(CommObjectRecognitionObjects::ObjectRecognitionBehavior::FULLSEARCH);
		//		param.set_behavior(Smart::SEARCH);
		COMP->recognitionParameterClient->send(param);

		//		param.set_mode(Smart::CONFIG);
		//		param.set_type("cup");
		//		COMP->recognitionParameterClient->send(param);

		// activate recognition event
		CHS::EventId id;
		CHS::StatusCode status;
		CommBasicObjects::CommVoid eventParameter;
		CommObjectRecognitionObjects::CommObjectRecognitionEventResult eventResult;
		CommObjectRecognitionObjects::CommObjectRecognitionId objectId;
		CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties objectProperties;
		COMP->recognitionEventClient->activate(CHS::continuous, eventParameter, id);

		// start recognition
		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::RECOGNIZE);
		COMP->recognitionParameterClient->send(param);

		std::cout << "wait for events\n";
		status = COMP->recognitionEventClient->getEvent(id, eventResult);
		if (status != CHS::SMART_OK) {
			std::cerr << "ERROR during object recognition\n";
			return;
		}

		Color::init_random();
		std::cout << "found objects: " << eventResult.get_object_id_size() << " \n";
		for (uint32_t i = 0; i < eventResult.get_object_id_size(); ++i) {
			objectId.set_id(eventResult.get_object_id(i));
			COMP->recognitionPropertyQueryClient->query(objectId, objectProperties);

			std::cout << objectProperties << "\n";
			double x, y, z;
			objectProperties.get_dimension(x, y, z, 1);
			ObjectSet::getInstance().drawCoord(objectProperties.get_pose(), 0.02);
			ObjectSet::getInstance().addBoundingBox(objectProperties.get_pose(), x, y, z, Color::random());
		}

		if (COMP->ini.connect_services.object_recognition_connected) {
			CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
			std::stringstream stream;
			stream << "LOADENV ";
			stream << eventResult.get_environment_id();
			std::string tmp;
			tmp = stream.str();
			manipulatorParam.set(tmp);
			std::cout << "Loading Env from Object Recognition with ID: " << eventResult.get_environment_id()
					<< std::endl;
			COMP->openRaveParameterClient->send(manipulatorParam);
		}

	} else {
		std::cout << "invalid scan id\n";
	}

}

void TestTask::learnNewObject() {

	int menuItem = 0;
	std::vector<std::vector<double> > samples;

	do {
		CommManipulatorObjects::CommManipulatorRequestScan3d scanRequest;
		CommManipulatorObjects::CommManipulatorId scanId;
		CommVisionObjects::Comm3dPointCloud cloud;

		CHS::EventId id;
		CommBasicObjects::CommVoid parameter;

		// capture laser scan
		COMP->manipulatorStateClient->setWaitState("scan");
		COMP->laserStateClient->setWaitState("active");

		scanRequest.set_laser_begin_angle(5.5);
		scanRequest.set_laser_end_angle(1.5);

		scanRequest.set_joint_count(5);

		scanRequest.set_begin_joint_angle(0, 3.3);
		scanRequest.set_end_joint_angle(0, 2.6);

		scanRequest.set_begin_joint_angle(1, 1.96);
		scanRequest.set_end_joint_angle(1, 1.96);

		scanRequest.set_begin_joint_angle(2, 2.76);
		scanRequest.set_end_joint_angle(2, 2.76);

		scanRequest.set_begin_joint_angle(3, 4.68);
		scanRequest.set_end_joint_angle(3, 4.68);

		scanRequest.set_begin_joint_angle(4, 4.75);
		scanRequest.set_end_joint_angle(4, 4.75);

		scanRequest.set_step_count(100);

		timeval a;
		timeval b;
		gettimeofday(&a, 0);

		std::cout << "start scanning ...\n";
		COMP->manipulatorScanEventClient->activate(CHS::single, parameter, id);
		COMP->manipulatorRequestScan3dSendClient->send(scanRequest);

		COMP->manipulatorScanEventClient->getEvent(id, scanId);

		gettimeofday(&b, 0);
		std::cout << "time for scan: " << (b.tv_sec - a.tv_sec) << " s\n";

		COMP->laserStateClient->setWaitState("neutral");
		COMP->manipulatorStateClient->setWaitState("trajectory");

		CommManipulatorObjects::CommManipulatorTrajectory trajectory;
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES);
		trajectory.set_trajectory_size(1);
		trajectory.set_wait_until_each_pose_reached(false);

		std::cout << ">> move to standby position\n";
		trajectory.set_pose_TCP_robot(0, -80.919, -3.17711, 1030.74, -0.00959797, -0.384639, 0.0183387);

		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
		COMP->manipulatorTrajectorySendClient->send(trajectory);

		// show laser scan
		if (scanId.is_valid()) {
			std::cout << "Scan Id: " << scanId.get_id() << "\n";

			std::cout << "get point cloud...\n";
			COMP->manipulatorScan3dQueryClient->query(scanId, cloud);

			double x, y, z;
			ObjectSet::getInstance().clearAll();
			ObjectSet::getInstance().drawBaseCoord();

			std::cout << "point cloud size: " << cloud.get_size() << "\n";
			for (uint32_t i = 0; i < cloud.get_size(); ++i) {
				cloud.get_point(i, x, y, z, 1);
				ObjectSet::getInstance().addPoint(x, y, z, Color::Red);
			}

			//////////////////////////////////////
			// perform object recognition
			//////////////////////////////////////
			std::cout << "start object recognition...\n";

			// activate recognition
			COMP->recognitionStateClient->setWaitState("active");

			CommObjectRecognitionObjects::CommObjectRecognitionParameter param;

			param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::CLOUD);
			param.set_cloud_id(scanId.get_id());
			COMP->recognitionParameterClient->send(param);

			param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::BEHAVIOR);
			param.set_behavior(CommObjectRecognitionObjects::ObjectRecognitionBehavior::FULLSEARCH);
			//		param.set_behavior(Smart::SEARCH);
			COMP->recognitionParameterClient->send(param);

			//		param.set_mode(Smart::CONFIG);
			//		param.set_type("cup");
			//		COMP->recognitionParameterClient->send(param);

			// activate recognition event
			CHS::EventId id;
			CHS::StatusCode status;
			CommBasicObjects::CommVoid eventParameter;
			CommObjectRecognitionObjects::CommObjectRecognitionEventResult eventResult;
			CommObjectRecognitionObjects::CommObjectRecognitionId objectId;
			CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties objectProperties;
			COMP->recognitionEventClient->activate(CHS::continuous, eventParameter, id);

			// start recognition
			param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::RECOGNIZE);
			COMP->recognitionParameterClient->send(param);

			std::cout << "wait for events\n";
			status = COMP->recognitionEventClient->getEvent(id, eventResult);
			if (status != CHS::SMART_OK) {
				std::cerr << "ERROR during object recognition\n";
				return;
			}

			Color::init_random();
			std::cout << "found objects: " << eventResult.get_object_id_size() << " \n";
			for (uint32_t i = 0; i < eventResult.get_object_id_size(); ++i) {
				objectId.set_id(eventResult.get_object_id(i));
				COMP->recognitionPropertyQueryClient->query(objectId, objectProperties);

				std::cout << objectProperties << "\n";
				double x, y, z;
				objectProperties.get_dimension(x, y, z, 1);
				ObjectSet::getInstance().drawCoord(objectProperties.get_pose(), 0.02);
				ObjectSet::getInstance().addBoundingBox(objectProperties.get_pose(), x, y, z, Color::random());
			}

			//////////////////////////////////////
			{
				int objId;
				std::cout << "\nspecify object od:  ";
				cin >> objId;

				objectId.set_id(objId);
				COMP->recognitionPropertyQueryClient->query(objectId, objectProperties);

				double x, y, z;
				objectProperties.get_dimension(x, y, z, 1);

				std::vector<double> sample;
				sample.push_back(x);
				sample.push_back(y);
				sample.push_back(z);
				samples.push_back(sample);
			}
			//////////////////////////////////////

		} else {
			std::cout << "invalid scan id\n";
		}

		std::cout << "-----------------------------\n";
		std::cout << "--- " << samples.size() << " samples ---\n";
		std::cout << "1 - further scan\n";
		std::cout << "2 - stop and show mean and covariance\n";

		std::cout << "\nplease choose number:  ";
		cin >> menuItem;

	} while (menuItem == 1);

	double means[3];
	CMatrixD covars(3, 3);
	covariancesAndMean(samples, covars, means);

	std::cout << "mean: " << means[0] << ", " << means[1] << ", " << means[2] << "\n";
	std::cout << "covar: " << covars << "\n";

}

//----------------------------------------------------------------
// OpenRave
//----------------------------------------------------------------

void TestTask::openRaveChangeState() {
	std::string in;
	std::cout << "State [neutral, demonstration, trajectory, simulation].\n";
	std::cin >> in;
	COMP->openRaveStateClient->setWaitState(in);
}

void TestTask::openRaveSave() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
	std::string tmp;
	tmp = "ENV_SAVE_FILE 1";
	manipulatorParam.set(tmp);
	std::cout << "Saving Env with ID: 1" << std::endl;
	COMP->openRaveParameterClient->send(manipulatorParam);
}

void TestTask::openRaveLoad() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
	std::string tmp;
	tmp = "ENV_LOAD_FILE 1";
	manipulatorParam.set(tmp);
	std::cout << "Loading Env with ID: 1" << std::endl;
	COMP->openRaveParameterClient->send(manipulatorParam);
}

void TestTask::openRaveDeleteObject() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
	std::string tmp("OBJ_DELETE");

	int number;
	std::cout << "\nEnter Number of Object: ";
	cin >> number;

	std::stringstream stream;
	stream << tmp << " " << number;

	tmp = stream.str();
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);
}

void TestTask::openRaveAddObject() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
	std::string tmp("OBJ_ADD");
	std::stringstream stream;

	int number;
	std::string type;
	std::cout << "\nEnter Number of Object: ";
	cin >> number;
	stream << tmp << " " << number;

	std::cout << "\nEnter Type of Object: ";
	cin >> type;
	stream << tmp << " " << type;

	tmp = stream.str();
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);
}

void TestTask::openRaveMoveObject() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
	std::string tmp("OBJ_MOVE");
	std::stringstream stream;

	int number;
	double coord;
	std::cout << "\nEnter Number of Object: ";
	cin >> number;
	stream << tmp << " " << number;

	std::cout << "\nEnter x coord: ";
	cin >> coord;
	stream << tmp << " " << coord;

	std::cout << "\nEnter y coord: ";
	cin >> coord;
	stream << tmp << " " << coord;

	std::cout << "\nEnter z coord: ";
	cin >> coord;
	stream << tmp << " " << coord;

	tmp = stream.str();
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);
}

void TestTask::openRaveComputeGraspTable() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;
	std::string tmp;

	int number;
	std::cout << "\nEnter Number of Object: ";
	cin >> number;

	std::stringstream stream;
	stream << "OBJ_COMPUTEGRASPTABLE ";
	stream << number;

	tmp = stream.str();
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);
}

void TestTask::openRaveMoveBetweenTwoPoints() {
	COMP->openRaveStateClient->setWaitState("trajectory");
	COMP->manipulatorStateClient->setWaitState("trajectory");

	CommManipulatorObjects::CommManipulatorTrajectory trajectory;
	trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES);
	trajectory.set_trajectory_size(1);
	trajectory.set_wait_until_each_pose_reached(false);

	std::cout << ">> move to point 1\n";
	trajectory.set_pose_TCP_robot(0, 422.978, 140.254, 760.09, 1.87175, -0.0196366, 1.5359);
	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE_OPEN_AFTER);
	COMP->openRaveTrajectorySendClient->send(trajectory);

	sleep(3);

	trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
	trajectory.set_trajectory_size(1);
	trajectory.set_joint_count(5);
	trajectory.set_wait_until_each_pose_reached(false);

	trajectory.set_joint_angle(0, 0, 3.1412);
	trajectory.set_joint_angle(0, 1, 2.13688);
	trajectory.set_joint_angle(0, 2, 0.934839);
	trajectory.set_joint_angle(0, 3, 1.11344);
	trajectory.set_joint_angle(0, 4, 3.10611);

	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER);
	COMP->openRaveTrajectorySendClient->send(trajectory);

}

void TestTask::openRaveTestSimulation() {
	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;

	std::string tmp = "ENV_CLEAR";
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);

	tmp = "PARALLELIZATION_ON";
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);

	// SIMULATION_PLAN_ALL is normal behaviour
	// SIMULATION_TEST_IK_ONLY tests only the ik without path planning
	//	tmp = "SIMULATION_PLAN_ALL";
	//	manipulatorParam.set(tmp);
	//	COMP->openRaveParameterClient->send(manipulatorParam);

	/**
	 * Scan and recognize objects
	 */

	CommManipulatorObjects::CommManipulatorId scanId;
	CommVisionObjects::Comm3dPointCloud cloud;

	CHS::EventId id;
	CommBasicObjects::CommVoid parameter;

	// capture laser scan
	COMP->manipulatorStateClient->setWaitState("scan");

	std::cout << "start scanning ...\n";

	COMP->manipulatorStateClient->setWaitState("trajectory");

	CommObjectRecognitionObjects::CommObjectRecognitionId objectId;
	CommObjectRecognitionObjects::CommObjectRecognitionEventResult eventResult;
	CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties objectProperties;

	// manipulate objects
	std::string manipulateObject = "ikea-cup-kalas";
	std::vector<CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties> objects;

	if (!COMP->ini.connect_services.manipulator_connected) {
		scanId.set_id(1);
		scanId.set_valid(true);
	}

	// show laser scan
	if (scanId.is_valid()) {
		std::cout << "Scan Id: " << scanId.get_id() << "\n";

		//////////////////////////////////////
		// perform object recognition
		//////////////////////////////////////
		std::cout << "start object recognition...\n";

		CommObjectRecognitionObjects::CommObjectRecognitionParameter param;

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::CLOUD);
		param.set_cloud_id(scanId.get_id());
		COMP->recognitionParameterClient->send(param);

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::BEHAVIOR);
		param.set_behavior(CommObjectRecognitionObjects::ObjectRecognitionBehavior::FULLSEARCH);
		//		param.set_behavior(Smart::SEARCH);
		COMP->recognitionParameterClient->send(param);

		// activate recognition event
		CHS::EventId id;
		CHS::StatusCode status;
		CommBasicObjects::CommVoid eventParameter;
		COMP->recognitionEventClient->activate(CHS::continuous, eventParameter, id);

		// start recognition
		COMP->recognitionStateClient->setWaitState("active");

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::RECOGNIZE);
		COMP->recognitionParameterClient->send(param);

		std::cout << "wait for events\n";
		status = COMP->recognitionEventClient->getEvent(id, eventResult);
		if (status != CHS::SMART_OK) {
			std::cerr << "ERROR during object recognition\n";
			return;
		}

		Color::init_random();
		std::cout << "found objects: " << eventResult.get_object_id_size() << " \n";
		for (uint32_t i = 0; i < eventResult.get_object_id_size(); ++i) {
			objectId.set_id(eventResult.get_object_id(i));
			COMP->recognitionPropertyQueryClient->query(objectId, objectProperties);

			// Save Cups
			string objectType;
			objectProperties.get_type(objectType);
			if (objectType == manipulateObject) {
				objects.push_back(objectProperties);
			}
			std::cout << objectProperties << "\n";
		}

		COMP->recognitionStateClient->setWaitState("neutral");

	}

	/**
	 * Stack Mugs
	 */

	// activate manipulator event
	CHS::StatusCode status;
	CommManipulationPlannerObjects::CommManipulationPlannerEventParameter openRaveEventParameter;
	CommManipulationPlannerObjects::CommManipulationPlannerEventResult openRaveEventResult;
	openRaveEventParameter.set_event(CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);

	CommManipulatorObjects::CommManipulatorEventParameter manipulatorEventParameter;
	CommManipulatorObjects::CommManipulatorEventResult manipulatorEventResult;

	CommManipulatorObjects::CommManipulatorTrajectory trajectory;

	COMP->openRaveEventClient->activate(CHS::continuous, openRaveEventParameter, id);

	// Load Environment into OpenRave
	std::stringstream stream;
	stream << "ENV_LOAD_OBJECTRECOGNITION ";
	stream << eventResult.get_environment_id();
	tmp = stream.str();
	manipulatorParam.set(tmp);
	std::cout << "Loading Env with ID: " << eventResult.get_environment_id() << std::endl;
	COMP->openRaveParameterClient->send(manipulatorParam);

	COMP->openRaveStateClient->setWaitState("simulation");

	// Look how much cups are found
	if (objects.size() > 0) {
		std::stringstream message;

		if (objects.size() == 1)
			message << "I have found " << objects.size() << " cup.";
		if (objects.size() > 1)
			message << "I have found " << objects.size() << " cups.";

		std::cout << message.str() << std::endl;

		size_t j = 0;
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES);
		trajectory.set_trajectory_size(1);
		trajectory.set_wait_until_each_pose_reached(false);

		double x = 0;
		double y = 0;
		double z = 0;
		double azimuth = 0;
		double elevation = 0;
		double roll = 0;

		for (; j < objects.size() - 1;) {

			COMP->openRaveStateClient->setWaitState("neutral");

			if (!stackMugs_SetGrasping(id, true)) {
				break;
			}

			COMP->openRaveStateClient->setWaitState("simulation");

			double v = sqrt(objects[j].get_pose().get_x(1) * objects[j].get_pose().get_x(1)
					+ objects[j].get_pose().get_y(1) * objects[j].get_pose().get_y(1));
			double vnew = v;

			x = (objects[j].get_pose().get_x(1) / v) * vnew;
			y = (objects[j].get_pose().get_y(1) / v) * vnew;
			z = objects[j].get_pose().get_z(1) + 0.02;

			azimuth = atan(y / x) + M_PI_2;
			elevation = M_PI_2;
			roll = 0;

			trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER);
			trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
			COMP->openRaveTrajectorySendClient->send(trajectory);

			if (!this->stackMugs_WaitForOpenRave(id)) {
				break;
			}

			COMP->openRaveStateClient->setWaitState("neutral");

			/**
			 * Grasp object
			 */
			this->stackMugs_GraspObject(objects[j].get_id(), id);

			COMP->openRaveStateClient->setWaitState("simulation");

			/**
			 * Calculate lift of Position
			 */
			std::cout << "Send lift of position.\n";
			trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
			trajectory.get_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
			trajectory.set_pose_TCP_robot(0, x, y, z + 0.02, azimuth, roll, elevation, 1);
			COMP->openRaveTrajectorySendClient->send(trajectory);

			if (!this->stackMugs_WaitForOpenRave(id)) {
				break;
			}

			/**
			 * Calculate second cup position
			 */
			x = objects[j + 1].get_pose().get_x(1);
			y = objects[j + 1].get_pose().get_y(1);
			z = objects[j + 1].get_pose().get_z(1) + 0.12;
			azimuth = atan(y / x) + M_PI_2;

			std::cout << "Send Second cup position.\n";
			trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_AFTER);
			trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
			COMP->openRaveTrajectorySendClient->send(trajectory);

			if (!this->stackMugs_WaitForOpenRave(id)) {
				break;
			}

			COMP->openRaveStateClient->setWaitState("neutral");

			/**
			 * Release Object
			 */
			stream.str("");
			stream << "OPENRAVE_RELEASEOBJ ";
			stream << objects[j].get_id();
			tmp = stream.str();
			manipulatorParam.set(tmp);
			std::cout << "Releasing Object with ID: " << objects[j].get_id() << std::endl;
			COMP->openRaveParameterClient->send(manipulatorParam);

			/**
			 * Delete Object
			 */
			stream.str("");
			stream << "OBJ_DELETE ";
			stream << objects[j].get_id();
			tmp = stream.str();
			manipulatorParam.set(tmp);
			std::cout << "Deleting Object with ID: " << objects[j].get_id() << std::endl;
			COMP->openRaveParameterClient->send(manipulatorParam);

			COMP->openRaveStateClient->setWaitState("simulation");

			j++;
		}

		COMP->openRaveStateClient->setWaitState("neutral");

		if (!stackMugs_SetGrasping(id, true)) {
			return;
		}

		COMP->openRaveStateClient->setWaitState("simulation");

		double v = sqrt(objects[j].get_pose().get_x(1) * objects[j].get_pose().get_x(1)
				+ objects[j].get_pose().get_y(1) * objects[j].get_pose().get_y(1));
		double vnew = v;

		x = (objects[j].get_pose().get_x(1) / v) * vnew;
		y = (objects[j].get_pose().get_y(1) / v) * vnew;
		z = objects[j].get_pose().get_z(1) + 0.02;

		azimuth = atan(y / x) + M_PI_2;
		elevation = M_PI_2;
		roll = 0;

		std::cout << "Manipulate last Object.\n";
		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER);
		trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
		COMP->openRaveTrajectorySendClient->send(trajectory);

		if (!this->stackMugs_WaitForOpenRave(id)) {
			return;
		}

		COMP->openRaveStateClient->setWaitState("neutral");

		this->stackMugs_GraspObject(objects[j].get_id(), id);

		if (!stackMugs_SetGrasping(id, false)) {
			return;
		}

		COMP->openRaveStateClient->setWaitState("simulation");

		// Sent hold position of cups
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
		trajectory.set_trajectory_size(1);
		trajectory.set_joint_count(5);

		trajectory.set_joint_angle(0, 0, 3.13322);
		trajectory.set_joint_angle(0, 1, 2.13827);
		trajectory.set_joint_angle(0, 2, 2.87904);
		trajectory.set_joint_angle(0, 3, 4.98754);
		trajectory.set_joint_angle(0, 4, 3.1406);
		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
		COMP->openRaveTrajectorySendClient->send(trajectory);

		if (!this->stackMugs_WaitForOpenRave(id)) {
			return;
		}

		return;
	}

	std::cout << "No Cup found.\n";

	return;
}

//----------------------------------------------------------------
// Scenario
//----------------------------------------------------------------


int TestTask::stackMugs() {

	COMP->openRaveStateClient->setWaitState("neutral");
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;

	std::string tmp = "ENV_CLEAR";
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);

	tmp = "PARALLELIZATION_OFF";
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);

	/**
	 * Scan and recognize objects
	 */

	CommManipulatorObjects::CommManipulatorRequestScan3d scanRequest;
	CommManipulatorObjects::CommManipulatorId scanId;
	CommVisionObjects::Comm3dPointCloud cloud;

	CHS::EventId id;
	CommBasicObjects::CommVoid parameter;

	// capture laser scan
	COMP->manipulatorStateClient->setWaitState("scan");

	scanRequest.set_laser_begin_angle(5.5);
	scanRequest.set_laser_end_angle(1.5);

	scanRequest.set_joint_count(5);

	scanRequest.set_begin_joint_angle(0, 4.3);
	scanRequest.set_end_joint_angle(0, 2.2);

	scanRequest.set_begin_joint_angle(1, 1.96);
	scanRequest.set_end_joint_angle(1, 1.96);

	scanRequest.set_begin_joint_angle(2, 2.76);
	scanRequest.set_end_joint_angle(2, 2.76);

	scanRequest.set_begin_joint_angle(3, 4.68);
	scanRequest.set_end_joint_angle(3, 4.68);

	scanRequest.set_begin_joint_angle(4, 4.75);
	scanRequest.set_end_joint_angle(4, 4.75);

	scanRequest.set_step_count(200);

	timeval a;
	timeval b;
	gettimeofday(&a, 0);

	std::cout << "start scanning ...\n";
	COMP->manipulatorRequestScan3dSendClient->send(scanRequest);

	COMP->manipulatorScanEventClient->activate(CHS::single, parameter, id);
	COMP->manipulatorScanEventClient->getEvent(id, scanId);

	gettimeofday(&b, 0);
	std::cout << "time for scan: " << (b.tv_sec - a.tv_sec) << " s\n";

	COMP->manipulatorStateClient->setWaitState("trajectory");

	CommManipulatorObjects::CommManipulatorTrajectory trajectory;
	trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES);
	trajectory.set_trajectory_size(1);
	trajectory.set_wait_until_each_pose_reached(false);

	std::cout << ">> move to standby position\n";
	trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
	trajectory.set_trajectory_size(1);
	trajectory.set_joint_count(5);
	trajectory.set_wait_until_each_pose_reached(false);

	trajectory.set_joint_angle(0, 0, 3.1412);
	trajectory.set_joint_angle(0, 1, 2.13688);
	trajectory.set_joint_angle(0, 2, 0.934839);
	trajectory.set_joint_angle(0, 3, 1.11344);
	trajectory.set_joint_angle(0, 4, 3.10611);

	//	trajectory.set_pose_TCP_robot(0, -112.343, -5.01603, 1030.504, 1.69581, 0.0262978, -0.388376);
	trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
	COMP->manipulatorTrajectorySendClient->send(trajectory);

	CommObjectRecognitionObjects::CommObjectRecognitionId objectId;
	CommObjectRecognitionObjects::CommObjectRecognitionEventResult eventResult;
	CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties objectProperties;

	// manipulate objects
	std::string manipulateObject = "ikea-cup-kalas";
	std::vector<CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties> objects;

	if (!COMP->ini.connect_services.manipulator_connected) {
		scanId.set_id(1);
		scanId.set_valid(true);
	}

	// show laser scan
	if (scanId.is_valid()) {
		std::cout << "Scan Id: " << scanId.get_id() << "\n";

		//////////////////////////////////////
		// perform object recognition
		//////////////////////////////////////
		std::cout << "start object recognition...\n";

		CommObjectRecognitionObjects::CommObjectRecognitionParameter param;

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::CLOUD);
		param.set_cloud_id(scanId.get_id());
		COMP->recognitionParameterClient->send(param);

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::BEHAVIOR);
		param.set_behavior(CommObjectRecognitionObjects::ObjectRecognitionBehavior::FULLSEARCH);
		//		param.set_behavior(Smart::SEARCH);
		COMP->recognitionParameterClient->send(param);

		// activate recognition event
		CHS::EventId id;
		CHS::StatusCode status;
		CommBasicObjects::CommVoid eventParameter;
		COMP->recognitionEventClient->activate(CHS::continuous, eventParameter, id);

		// start recognition
		COMP->recognitionStateClient->setWaitState("active");

		param.set_mode(CommObjectRecognitionObjects::ObjectRecognitionMode::RECOGNIZE);
		COMP->recognitionParameterClient->send(param);

		std::cout << "wait for events\n";
		status = COMP->recognitionEventClient->getEvent(id, eventResult);
		if (status != CHS::SMART_OK) {
			std::cerr << "ERROR during object recognition\n";
			return -1;
		}

		Color::init_random();
		std::cout << "found objects: " << eventResult.get_object_id_size() << " \n";
		for (uint32_t i = 0; i < eventResult.get_object_id_size(); ++i) {
			objectId.set_id(eventResult.get_object_id(i));
			COMP->recognitionPropertyQueryClient->query(objectId, objectProperties);

			// Save Cups
			string objectType;
			objectProperties.get_type(objectType);
			if (objectType == manipulateObject) {
				objects.push_back(objectProperties);
			}
			std::cout << objectProperties << "\n";
		}

		COMP->recognitionStateClient->setWaitState("neutral");

	}

	COMP->openRaveStateClient->setWaitState("neutral");

	/**
	 * Stack Mugs
	 */

	// activate manipulator event
	CHS::StatusCode status;
	CommManipulationPlannerObjects::CommManipulationPlannerEventParameter openRaveEventParameter;
	CommManipulationPlannerObjects::CommManipulationPlannerEventResult openRaveEventResult;
	openRaveEventParameter.set_event(CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);

	CommManipulatorObjects::CommManipulatorEventParameter manipulatorEventParameter;
	CommManipulatorObjects::CommManipulatorEventResult manipulatorEventResult;

	COMP->openRaveEventClient->activate(CHS::continuous, openRaveEventParameter, id);

	// Load Environment into OpenRave
	std::stringstream stream;
	stream << "ENV_LOAD_OBJECTRECOGNITION ";
	stream << eventResult.get_environment_id();
	tmp = stream.str();
	manipulatorParam.set(tmp);
	std::cout << "Loading Env with ID: " << eventResult.get_environment_id() << std::endl;
	COMP->openRaveParameterClient->send(manipulatorParam);

	//	status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);
	//
	//	if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PARAMETER_SUCCESS == openRaveEventResult.get_event()) {
	//		std::cout << "Parameter Success\n";
	//	} else {
	//		std::cout << "Error\n";
	//	}

	// Look how much cups are found
	if (objects.size() > 0) {
		std::stringstream message;

		if (objects.size() == 1)
			message << "I have found " << objects.size() << " cup.";
		if (objects.size() > 1)
			message << "I have found " << objects.size() << " cups.";

		std::cout << message.str() << std::endl;

		size_t j = 0;
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::POSES);
		trajectory.set_trajectory_size(1);
		trajectory.set_wait_until_each_pose_reached(false);

		double x = 0;
		double y = 0;
		double z = 0;
		double azimuth = 0;
		double elevation = 0;
		double roll = 0;

		for (; j < objects.size() - 1;) {

			COMP->openRaveStateClient->setWaitState("neutral");

			if (!stackMugs_SetGrasping(id, true)) {
				break;
			}

			COMP->openRaveStateClient->setWaitState("trajectory");

			double v = sqrt(objects[j].get_pose().get_x(1) * objects[j].get_pose().get_x(1)
					+ objects[j].get_pose().get_y(1) * objects[j].get_pose().get_y(1));
			double vnew = v;

			x = (objects[j].get_pose().get_x(1) / v) * vnew;
			y = (objects[j].get_pose().get_y(1) / v) * vnew;
			z = objects[j].get_pose().get_z(1) + 0.02;

			azimuth = atan(y / x) + M_PI_2;
			elevation = M_PI_2;
			roll = 0;

			trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER);
			trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
			COMP->openRaveTrajectorySendClient->send(trajectory);

			if (!this->stackMugs_WaitForOpenRave(id)) {
				break;
			}

			COMP->openRaveStateClient->setWaitState("neutral");

			/**
			 * Grasp object
			 */
			this->stackMugs_GraspObject(objects[j].get_id(), id);

			if (!stackMugs_SetGrasping(id, false)) {
				break;
			}

			COMP->openRaveStateClient->setWaitState("trajectory");

			// Wait for real manipulator to finish
			if (COMP->ini.connect_services.manipulator_connected) {
				manipulatorEventParameter.set_event(CommManipulatorObjects::ManipulatorEvent::UNKNOWN);
				COMP->manipulatorEventClient->activate(CHS::continuous, manipulatorEventParameter, id);

				COMP->manipulatorEventClient->getEvent(id, manipulatorEventResult);
			}

			/**
			 * Calculate lift of Position
			 */
			std::cout << "Send lift of position.\n";
			trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
			trajectory.get_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
			trajectory.set_pose_TCP_robot(0, x, y, z + 0.02, azimuth, roll, elevation, 1);
			COMP->openRaveTrajectorySendClient->send(trajectory);

			if (!this->stackMugs_WaitForOpenRave(id)) {
				break;
			}

			if (COMP->ini.connect_services.manipulator_connected) {
				COMP->manipulatorEventClient->getEvent(id, manipulatorEventResult);
			}

			/**
			 * Calculate second cup position
			 */
			x = objects[j + 1].get_pose().get_x(1);
			y = objects[j + 1].get_pose().get_y(1);
			z = objects[j + 1].get_pose().get_z(1) + 0.12;
			azimuth = atan(y / x) + M_PI_2;

			std::cout << "Send Second cup position.\n";
			trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_AFTER);
			trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
			COMP->openRaveTrajectorySendClient->send(trajectory);

			if (!this->stackMugs_WaitForOpenRave(id)) {
				break;
			}

			if (COMP->ini.connect_services.manipulator_connected) {
				COMP->manipulatorEventClient->getEvent(id, manipulatorEventResult);
			}

			COMP->openRaveStateClient->setWaitState("neutral");

			/**
			 * Release Object
			 */
			stream.str("");
			stream << "OPENRAVE_RELEASEOBJ ";
			stream << objects[j].get_id();
			tmp = stream.str();
			manipulatorParam.set(tmp);
			std::cout << "Releasing Object with ID: " << objects[j].get_id() << std::endl;
			COMP->openRaveParameterClient->send(manipulatorParam);

			//			status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);
			//
			//			if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PARAMETER_SUCCESS == openRaveEventResult.get_event()) {
			//				std::cout << "Parameter Success\n";
			//			} else {
			//				std::cout << "Error\n";
			//			}

			/**
			 * Delete Object
			 */
			stream.str("");
			stream << "OBJ_DELETE ";
			stream << objects[j].get_id();
			tmp = stream.str();
			manipulatorParam.set(tmp);
			std::cout << "Deleting Object with ID: " << objects[j].get_id() << std::endl;
			COMP->openRaveParameterClient->send(manipulatorParam);

			//			sleep(3);
			//
			//			// tryEvent() because in the Success case we do not get a new event
			//			status = COMP->openRaveEventClient->tryEvent(id);
			//			if (status == CHS::SMART_ACTIVE) {
			//				std::cout << "Parameter Success\n";
			//			} else {
			//				status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);
			//
			//				if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PARAMETER_FAIL == openRaveEventResult.get_event()) {
			//					std::cout << "Error\n";
			//				}
			//			}

			COMP->openRaveStateClient->setWaitState("trajectory");

			j++;
		}

		COMP->openRaveStateClient->setWaitState("neutral");

		if (!stackMugs_SetGrasping(id, true)) {
			return -1;
		}

		COMP->openRaveStateClient->setWaitState("trajectory");

		/**
		 * Calculate position of last object
		 */
		std::cout << "Manipulate last Object.\n";

		double v = sqrt(objects[j].get_pose().get_x(1) * objects[j].get_pose().get_x(1)
				+ objects[j].get_pose().get_y(1) * objects[j].get_pose().get_y(1));
		double vnew = v;

		x = (objects[j].get_pose().get_x(1) / v) * vnew;
		y = (objects[j].get_pose().get_y(1) / v) * vnew;
		z = objects[j].get_pose().get_z(1) + 0.02;
		azimuth = atan(y / x) + M_PI_2;
		elevation = M_PI_2;
		roll = 0;

		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER);
		trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
		COMP->openRaveTrajectorySendClient->send(trajectory);

		if (!this->stackMugs_WaitForOpenRave(id)) {
			return -1;
		}

		if (COMP->ini.connect_services.manipulator_connected) {
			COMP->manipulatorEventClient->getEvent(id, manipulatorEventResult);
		}

		COMP->openRaveStateClient->setWaitState("neutral");

		this->stackMugs_GraspObject(objects[j].get_id(), id);

		if (!stackMugs_SetGrasping(id, false)) {
			return -1;
		}

		COMP->openRaveStateClient->setWaitState("trajectory");

		// Sent hold position of cups
		trajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
		trajectory.set_trajectory_size(1);
		trajectory.set_joint_count(5);

		trajectory.set_joint_angle(0, 0, 3.13322);
		trajectory.set_joint_angle(0, 1, 2.13827);
		trajectory.set_joint_angle(0, 2, 2.87904);
		trajectory.set_joint_angle(0, 3, 4.98754);
		trajectory.set_joint_angle(0, 4, 3.1406);
		trajectory.set_gripper_action(CommManipulatorObjects::ManipulatorGripperAction::NO_OP);
		COMP->openRaveTrajectorySendClient->send(trajectory);

		if (!this->stackMugs_WaitForOpenRave(id)) {
			return -1;
		}

		return 0;
	}

	std::cout << "No Cup found.\n";

	return -1;
}

bool TestTask::stackMugs_WaitForOpenRave(CHS::EventId id) {
	CHS::StatusCode status;
	CommManipulationPlannerObjects::CommManipulationPlannerEventResult openRaveEventResult;

	status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);

	if (status != CHS::SMART_OK) {
		std::cout << "Error in Communication!.\n";
		return false;
	}

	if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PLANNING_PATH == openRaveEventResult.get_event()) {
		std::cout << "Planning Path\n";

		status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);

		if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND == openRaveEventResult.get_event()) {
			std::cout << "Found Solution with iteration.\n";
			return true;
		} else {
			std::cout << "Error\n";
		}
	} else if (CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_IKSOLUTION_FOUND
			== openRaveEventResult.get_event()) {
		std::cout << "Error No IKSolution Found\n";
	}
	return false;
}

bool TestTask::stackMugs_GraspObject(int objectId, CHS::EventId id) {
	CHS::StatusCode status;
	CommManipulationPlannerObjects::CommManipulationPlannerEventResult openRaveEventResult;
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;

	std::stringstream stream;

	stream.str("");
	stream << "OPENRAVE_GRASPOBJ ";
	stream << objectId;
	std::string tmp = stream.str();
	manipulatorParam.set(tmp);
	std::cout << "Grasping Object with ID: " << objectId << std::endl;
	COMP->openRaveParameterClient->send(manipulatorParam);

	//	status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);
	//
	//	if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PARAMETER_SUCCESS == openRaveEventResult.get_event()) {
	//		return true;
	//	}
	return true;
}

void TestTask::stackMugs_iterateGraspPosition(double body_x, double body_y, double body_z,
		CommManipulatorObjects::CommManipulatorTrajectory &trajectory, CHS::EventId id) {
	double v = sqrt(body_x * body_x + body_y * body_y);
	double vnew = v;

	double x = (body_x / v) * vnew;
	double y = (body_y / v) * vnew;
	double z = body_z + 0.02;
	double azimuth = atan(y / x) + M_PI_2;
	double elevation = 0;
	double default_elevation = M_PI_2;
	double roll = 0;

	for (int i = 0; i <= 90; ++i) {
		std::cout << "Iteration: " << i << std::endl;

		// Calculate new angle for grasping starting from 90° (gripper is horizontal) to 180° (gripper is vertical)
		elevation = M_PI / 180 * ((180 / M_PI * default_elevation) + i);

		// Roll has to be in the middle, don't know why but it works
		std::cout << "POSI: x=" << x << " y=" << y << " z=" << z << " azi=" << azimuth << " ele=" << elevation
				<< " roll=" << roll << std::endl;

		trajectory.set_pose_TCP_robot(0, x, y, z, azimuth, roll, elevation, 1);
		COMP->openRaveTrajectorySendClient->send(trajectory);

		if (this->stackMugs_WaitForOpenRave(id)) {
			break;
		}
	}
}

bool TestTask::stackMugs_SetGrasping(CHS::EventId id, bool activate) {
	CHS::StatusCode status;
	CommManipulationPlannerObjects::CommManipulationPlannerEventResult openRaveEventResult;
	CommManipulationPlannerObjects::CommManipulationPlannerParameter manipulatorParam;

	string tmp = "GRASPING_NONE";
	if (activate) {
		// Height, Depth, Angle
		tmp = "GRASPING_SIMPLE 0.01 0.02 0.0 0.015 0 30";
	}
	manipulatorParam.set(tmp);
	COMP->openRaveParameterClient->send(manipulatorParam);

	//	status = COMP->openRaveEventClient->getEvent(id, openRaveEventResult);
	//
	//	if (CommManipulationPlannerObjects::ManipulationPlannerEvent::PARAMETER_SUCCESS == openRaveEventResult.get_event()) {
	//		return true;
	//	}
	//	return false;
	return true;
}

