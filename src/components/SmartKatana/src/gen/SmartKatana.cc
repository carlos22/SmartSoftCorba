//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// Please do not modify this file. It will be re-generated
// running the workflow.
//--------------------------------------------------------------------------

#include "SmartKatana.hh"

// constructor
SmartKatana::SmartKatana()
{
	std::cout << "constructor SmartKatana\n";

	ini.eventServer.serviceName = "eventServer";
	ini.stateServer.serviceName = "stateServer";
	ini.posePushTimedServer.serviceName = "currentPose";
	ini.posePushTimedServer.cycle = 0.1;
	ini.trajectorySendServer.serviceName = "performTrajectory";
	ini.paramServer.serviceName = "param";
	ini.basePushTimedClient.serverName = "unknown";
	ini.basePushTimedClient.serviceName = "unknown";
	ini.basePushTimedClient.interval = 1;
	ini.SerialPort.Device = "/dev/ttyS0";
	ini.Network.Port = 5566;
	ini.Network.IpAdress = "127.0.0.1";
	ini.Katana.GoalPositionApproach = 3;
	ini.Katana.KatanaConfigFile = "src/config/katana6M180.cfg";
	ini.Katana.GoalAngleApproach = 0.1;
	ini.Katana.KatanaDevice = "Serial";
	ini.Katana.BaseInit = true;
}

void SmartKatana::init(int argc, char *argv[])
{
	try
	{
		component = new CHS::SmartComponent("SmartKatana", argc, argv);
		loadParameter(argc, argv);

		// create ports
		eventServer = new CHS::EventServer<
				Smart::CommManipulatorEventParameter,
				Smart::CommManipulatorEventResult,
				Smart::CommManipulatorEventState>(component,
				ini.eventServer.serviceName, eventTestHandler);
		stateServer = new CHS::SmartStateServer(component,
				ini.stateServer.serviceName, stateChangeHandler);
		// define states for stateServer (CHS::SmartStateServer)
		if (stateServer->defineStates("demonstration", "demonstration")
				!= CHS::SMART_OK)
			std::cerr << "ERROR: define state" << std::endl;
		if (stateServer->defineStates("trajectory", "trajectory")
				!= CHS::SMART_OK)
			std::cerr << "ERROR: define state" << std::endl;
		posePushTimedServer = new CHS::PushTimedServer<
				Smart::CommMobileManipulatorState>(component,
				ini.posePushTimedServer.serviceName, posePushTimedHandler,
				ini.posePushTimedServer.cycle);

		threadTrajectorySendHandler = new CHS::ThreadQueueSendHandler<
				Smart::CommManipulatorTrajectory>(trajectorySendHandler);
		trajectorySendServer = new CHS::SendServer<
				Smart::CommManipulatorTrajectory>(component,
				ini.trajectorySendServer.serviceName,
				*threadTrajectorySendHandler);

		basePushTimedClient = new CHS::PushTimedClient<Smart::CommBaseState>(
				component);

		paramServer = new CHS::SendServer<Smart::CommManipulatorParameter>(
				component, ini.paramServer.serviceName, paramHandler);

	} catch (const CORBA::Exception &)
	{
		std::cerr << "Uncaught CORBA exception" << std::endl;
	} catch (...)
	{
		std::cerr << "Uncaught exception" << std::endl;
	}
}

// run the component
void SmartKatana::run()
{
	compHandler.onStartup();
	component->run();
	delete component;
}

void SmartKatana::loadParameter(int argc, char *argv[])
{
	CHS::SmartParameter parameter;

	// load parameters
	try
	{
		// check if paramfile is given as argument
		bool paramFile = false;
		std::string str;
		for (int i = 0; i < argc; i++)
		{
			str = argv[i];
			if (str.find("filename") != std::string::npos)
				paramFile = true;
		}

		// if paramfile is given as argument
		if (paramFile == true)
		{
			std::cout << "load parameter file from argv \n";
			parameter.addFile(argc, argv, "filename", false);
		}
		// else load standard paramfile
		else
		{
			std::cout << "load SmartKatana.ini parameter file\n";
			parameter.addFile("SmartKatana.ini");
		}

		// than add command line arguments to allow overwriting of parameters
		// from file
		parameter.addCommandLine("", argc, argv);

		// print all known parameters
		parameter.print(); // TODO remove this


		// load parameter
		parameter.getString("eventServer", "serviceName",
				ini.eventServer.serviceName);
		parameter.getString("stateServer", "serviceName",
				ini.stateServer.serviceName);
		parameter.getString("posePushTimedServer", "serviceName",
				ini.posePushTimedServer.serviceName);
		parameter.getDouble("posePushTimedServer", "cycle",
				ini.posePushTimedServer.cycle);
		parameter.getString("trajectorySendServer", "serviceName",
				ini.trajectorySendServer.serviceName);
		parameter.getString("paramServer", "serviceName",
				ini.paramServer.serviceName);
		parameter.getString("basePushTimedClient", "serverName",
				ini.basePushTimedClient.serverName);
		parameter.getString("basePushTimedClient", "serviceName",
				ini.basePushTimedClient.serviceName);
		parameter.getInt("basePushTimedClient", "interval",
				ini.basePushTimedClient.interval);
		parameter.getString("SerialPort", "Device", ini.SerialPort.Device);
		parameter.getInt("Network", "Port", ini.Network.Port);
		parameter.getString("Network", "IpAdress", ini.Network.IpAdress);
		parameter.getDouble("Katana", "GoalPositionApproach",
				ini.Katana.GoalPositionApproach);
		parameter.getString("Katana", "KatanaConfigFile",
				ini.Katana.KatanaConfigFile);
		parameter.getDouble("Katana", "GoalAngleApproach",
				ini.Katana.GoalAngleApproach);
		parameter.getString("Katana", "KatanaDevice", ini.Katana.KatanaDevice);
		parameter.getTruthValue("Katana", "BaseInit", ini.Katana.BaseInit);

	} catch (const CORBA::Exception &)
	{
		std::cerr << "Uncaught CORBA exception" << std::endl;
	} catch (const CHS::ParameterError & e)
	{
		std::cerr << "Exception from parameter handling: " << e << std::endl;
	} catch (...)
	{
		std::cerr << "Uncaught exception" << std::endl;
	}
}

