//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Mapper/GridMapper component".
//  It provides mapping services based on grid maps. The current map
//  represents the latest snapshot of the local surrounding based on
//  laserscans. The current map can be preoccupied by the longterm map.
//  The longterm map is a simple occupancy grid map.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "CompHandler.hh"
#include "gen/SmartMapperGridMap.hh"

#include <iostream>

// include communication objects

void CompHandler::onStartup()
{
	CHS::StatusCode status;
    char *growing;
    int p1,p2,p3,p4,p5;
    struct MapperStateStruct localState;

    // ----------------------------------------------------------
    // global states
    // ----------------------------------------------------------
	COMP->globalState.cellSize 			= COMP->ini.general.cellsize;
	COMP->globalState.curInterval		= COMP->ini.currentMap.interval;
	COMP->globalState.curLtmState		= COMP->ini.currentMap.ltm_state;
	COMP->globalState.curLtmThreshold	= COMP->ini.currentMap.ltm_threshold;
	COMP->globalState.curEmpty			= COMP->ini.currentMap.empty;
	COMP->globalState.ltmKalman			= COMP->ini.ltmMap.kalman;


	localState = COMP->globalState;

	//globalState.ltmFilename     = (char *)parameter.getString("ltm","filename").c_str();

	growing = (char *)COMP->ini.currentMap.growing.c_str();
	COMP->globalState.growingType = MAPPER_GROWING_NO;
	if (strcmp(growing,"circle16")==0) COMP->globalState.growingType = MAPPER_GROWING_CIRCLE_16;
	if (strcmp(growing,"circle8")==0)  COMP->globalState.growingType = MAPPER_GROWING_CIRCLE_8;
	if (strcmp(growing,"star16")==0)   COMP->globalState.growingType = MAPPER_GROWING_STAR_16;
	if (strcmp(growing,"star12")==0)   COMP->globalState.growingType = MAPPER_GROWING_STAR_12;
	if (strcmp(growing,"no")==0)       COMP->globalState.growingType = MAPPER_GROWING_NO;

	p1 = COMP->ini.currentMap.size_x;
	p2 = COMP->ini.currentMap.size_y;
	p3 = COMP->ini.currentMap.offset_x;
	p4 = COMP->ini.currentMap.offset_y;
	p5 = COMP->ini.currentMap.map_id;

	// create current map
	COMP->currentGridMap = new Smart::SmartCurrentGridMap( p1, p2, p3, p4,
			COMP->globalState.cellSize,
			COMP->globalState.growingType,
			p5);

	p1 = COMP->ini.ltmMap.size_x;
	p2 = COMP->ini.ltmMap.size_y;
	p3 = COMP->ini.ltmMap.offset_x;
	p4 = COMP->ini.ltmMap.offset_y;
	p5 = COMP->ini.ltmMap.map_id;

	// create longterm map
	COMP->ltmGridMap = new Smart::SmartLtmGridMap( p1, p2, p3, p4,
			COMP->globalState.cellSize,
			p5);

	COMP->MapperStateLock.release();

	// connect to all services
	std::cout << "connecting to: " << COMP->ini.laserClient.serverName << "; "
			<< COMP->ini.laserClient.serviceName << std::endl;
	status = COMP->laserClient->connect(COMP->ini.laserClient.serverName,
			COMP->ini.laserClient.serviceName);
	while (status != CHS::SMART_OK)
	{
		usleep(500000);
		status = COMP->laserClient->connect(COMP->ini.laserClient.serverName,
				COMP->ini.laserClient.serviceName);
	}
	std::cout << "connected.\n";

	COMP->laserClient->subscribe();

	// activate state server
	if (COMP->stateServer->activate() != CHS::SMART_OK)
		std::cerr << "ERROR: activate state" << std::endl;

	// run all tasks
	COMP->ltmMapTask.open();
	COMP->curMapTask.open();

}
