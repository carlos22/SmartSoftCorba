//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//  Copyright (C) 2010 Jonas Brich
//
//        brich@mail.hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "Unicap Video Server component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "ImageTask.hh"
#include "gen/SmartUnicapImageServer.hh"
#include "Unicap.hh"

#include "EulerTransformationMatrices.hh"

#include <iostream>
#include <armadillo.hh>

ImageTask::ImageTask() {
	_image_buffer_index = 0;
	_image_buffer.resize(2);
}

int ImageTask::svc() {


	CommBasicObjects::CommBasePosition default_base_position;
	default_base_position.set_x(COMP->ini.base.x);
	default_base_position.set_y(COMP->ini.base.y);
	default_base_position.set_z(COMP->ini.base.z);
	default_base_position.set_base_alpha(COMP->ini.base.base_a);
	default_base_position.set_steer_alpha(COMP->ini.base.steer_a);
	default_base_position.set_turret_alpha(COMP->ini.base.turret_a);

	CommBasicObjects::CommBaseVelocity zero_velocity;
	zero_velocity.set_v(0);
	zero_velocity.set_omega_base(0);
	zero_velocity.set_omega_steer(0);
	zero_velocity.set_omega_turret(0);


	CommVisionObjects::FormatType format;
	if (!CommVisionObjects::CommVideoImage::string2format(COMP->ini.image.smart_format, format)) {
		std::cout<<"ERROR in converting format"<<std::endl;
		return -1;
	}

	// Fill ring_buffer with empty images
	for (unsigned int i = 0; i < _image_buffer.size(); i++) {
	  _image_buffer[i] = new CommVisionObjects::CommVideoImage(COMP->ini.hardware_properties.width,
	                                                        COMP->ini.hardware_properties.height, format);
	}


	CommVisionObjects::CommVideoImage* image = NULL;


	while (true) {
		if(COMP->stateServer->acquire("pushimage") == CHS::SMART_OK)
		{
			image = _image_buffer[_image_buffer_index];

			// get newest image from Unicap
			try {
				UNICAPINZ->getImage(*image);
			} catch (Unicap::UnicapException& e) {
				std::cerr << "Error: " << e.what() << " [ImageTask].\n";
				continue;
			} catch (...) {
				std::cerr << "Error: Undefined Error. [ImageTask]\n";
				continue;
			}

			arma::mat sensorMat;
			EulerTransformationMatrices::create_zyx_matrix(COMP->ini.sensor_pose.x, COMP->ini.sensor_pose.y,
					COMP->ini.sensor_pose.z, COMP->ini.sensor_pose.azimuth, COMP->ini.sensor_pose.elevation,
					COMP->ini.sensor_pose.roll, sensorMat);

			// set base state
			CommBasicObjects::CommBaseState base_state;
			if (COMP->ini.base.on_ptu) {
				CommBasicObjects::CommDevicePoseState devicePoseState;
				CHS::StatusCode status = COMP->ptuPushTimedClient->getUpdate(devicePoseState);

				base_state = devicePoseState.get_base_state();
				CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
				arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

				sensorMat = ptuMat * sensorMat;

				if (status != CHS::SMART_OK) {
					std::cerr << "WARNING: failed to get current ptu device state (" << CHS::StatusCodeConversion(status)
					<< "), pushing invalid image" << std::endl;
					image->set_data_invalid();
				}

			}
			// read base state from base server
			else if (COMP->ini.base.on_base) {
				CHS::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

				if (status != CHS::SMART_OK) {
					std::cerr << "WARNING: failed to get current base state (" << CHS::StatusCodeConversion(status)
					<< "), pushing invalid image" << std::endl;
					image->set_data_invalid();
				}
			}
			// default base state
			else {
				base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
				base_state.set_base_position(default_base_position);
				base_state.set_base_velocity(zero_velocity);
			}

			CommBasicObjects::CommPose3d sensorPose(sensorMat);
			image->set_sensor_pose(sensorPose);
			image->set_base_state(base_state);


			// Save the newest image into the global Pointer
			COMP->NewestImageMutex.acquire();
			COMP->newestImage = image;
			COMP->NewestImageMutex.release();


			COMP->imagePushNewestServer->put(*image);
			if (COMP->ini.push_newest.debug_info) {
				std::cout << "Newest: Image sent.\n";
			}


			// calculate new index in the ring_buffer
			_image_buffer_index++;
			if (_image_buffer_index == _image_buffer.size())
			   _image_buffer_index = 0;

			COMP->stateServer->release("pushimage");
		}
		// calculate new index in the ring_buffer
		//		_ring_buffer_index++;
		//		if (_ring_buffer_index == _ring_buffer.size())
		//			_ring_buffer_index = 0;
	}
	return 0;
}

ImageTask::~ImageTask() {
	COMP->imageTask.close();
	for (unsigned int i = 0; i < _image_buffer.size(); i++) {
		delete _image_buffer[i];
	}
	_image_buffer.clear();
}

//----------------------------------------------------------------
// ImagePushNewestCleanupThread - Methods
//----------------------------------------------------------------
//
//ImageTask::ImageCleanupThread::ImageCleanupThread() {
//	_queue_sem.acquire();
//}
//
//int ImageTask::ImageCleanupThread::svc() {
//	CommVisionObjects::CommVideoImage *img = 0;
//	while (true) {
//		_queue_sem.acquire();
//		_queue_mutex.acquire();
//		img = _queue.front();
//		_queue.pop();
//		_queue_mutex.release();
//		if (img == 0) {
//			if (COMP->ini.push_newest.debug_info)
//				std::cout << "Newest-CleanUpThread: Stopping SVC\n";
//			break; // "0" means stop, can be done over the method stopThread()
//		}
//		delete img; // may block on semaphore protecting shm
//		if (COMP->ini.push_newest.debug_info)
//			std::cout << "Newest-CleanUpThread: Image deleted\n";
//	}
//	return 0;
//}
//
//void ImageTask::ImageCleanupThread::_enqueue(CommVisionObjects::CommVideoImage *image) {
//	_queue_mutex.acquire();
//	_queue.push(image);
//	_queue_mutex.release();
//	_queue_sem.release();
//}
//
//ImageTask::ImageCleanupThread::~ImageCleanupThread() {
//}
