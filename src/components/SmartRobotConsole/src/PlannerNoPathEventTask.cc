//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//                2011 Dennis Stampfer
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft robot console component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
//  This component is for testing purposes only!
//
// --------------------------------------------------------------------------

#include "PlannerNoPathEventTask.hh"
#include "gen/SmartRobotConsole.hh"

#include <iostream>

PlannerNoPathEventTask::PlannerNoPathEventTask()
{
	std::cout << "constructor PlannerNoPathEventTask\n";
}

int PlannerNoPathEventTask::svc()
{
	CHS::StatusCode status;
	  //Cdl Goal Event!!

	  //CHS::EventClient<Smart::CommPlannerEventParameter,Smart::CommPlannerEventResult> eventClient(component, "smartPlanner","plannerEvent");
	std::cout << "connecting to: " << COMP->ini.plannerEventClient.serverName
			<< "; " << COMP->ini.plannerEventClient.serviceName << std::endl;
	status = COMP->plannerEventClient->connect(
			COMP->ini.plannerEventClient.serverName,
			COMP->ini.plannerEventClient.serviceName);
	if (status != CHS::SMART_OK) {
		std::cout << "COULD NOT CONNECT TO planner event" <<CHS::StatusCodeConversion(status)<< std::endl;
	} else {
		std::cout << "connected.\n";
	}



		//CHS::SendClient<Smart::CommMapperParameter> smartMapperParameterSendClient(component,"smartMapper","mapperParameter");
	std::cout << "connecting to: "
			<< COMP->ini.mapperParameterClient.serverName << "; "
			<< COMP->ini.mapperParameterClient.serviceName << std::endl;
	status = COMP->mapperParameterClient->connect(
			COMP->ini.mapperParameterClient.serverName,
			COMP->ini.mapperParameterClient.serviceName);
	if (status != CHS::SMART_OK) {
		std::cout << "COULD NOT CONNECT mapper parameter" << std::endl;
	} else {
		std::cout << "connected.\n";
	}





	  CommNavigationObjects::CommPlannerEventParameter parameter;
	  CommNavigationObjects::CommPlannerEventResult result;
	  CHS::EventId               id;
	  CommNavigationObjects::CommMapperParameter cmdMap;
	  std::string str;


	  CommNavigationObjects::PlannerEventType res;
	  CommNavigationObjects::PlannerEventType param(CommNavigationObjects::PlannerEventType::PLANNER_NO_ERROR);
	  //param = CommNavigationObjects::PlannerEventType::PLANNER_NO_ERROR;
	  //int param = PLANNER_NO_ERROR;

	  //
	  // continuous event
	  //
	  parameter.set(param);

	  status = COMP->plannerEventClient->activate(CHS::continuous, parameter, id);

	  while(true)
	  {
	    status = COMP->plannerEventClient->getEvent(id, result);
	    if (status == CHS::SMART_OK) {
	      result.get(res);
	      if(res == CommNavigationObjects::PlannerEventType::PLANNER_NO_PATH)
	      {
	        cout<<"Planner delete MAP!!"<<std::endl;

	          str = "CURLOADLTM";
	          cmdMap.set(str);
	          COMP->mapperParameterClient->send(cmdMap);

	      }
	    }
	  }
	  status = COMP->plannerEventClient->deactivate(id);
	  return 0;
}
