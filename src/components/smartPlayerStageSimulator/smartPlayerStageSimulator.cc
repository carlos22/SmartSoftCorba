//--------------------------------------------------------------------------
//
//  Copyright (C) 2009 Andreas Steck, Matthias Lutz
//
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License 
//  as published by the Free Software Foundation; either version 2.1 
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along 
//  with this library; if not, write to the Free Software Foundation, Inc., 
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the communication with the pioneer robot was taken from the 
// Playerstage Project, which is distributed under GPL, and you can find at 
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000  
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//                   
//----------------------------------------------------------------------------

#include <string>
#include <sstream>
#include <memory>

#include <libplayerc++/playerc++.h>

#include "smartSoft.hh"

#include "commVoid.hh"
#include "commBasePosition.hh"
#include "commBaseVelocity.hh"
#include "commBaseState.hh"
#include "commNavigationVelocity.hh"
#include "commMobileLaserScan.hh"
#include "commBasePositionUpdate.hh"
#include "commTimeStamp.hh"

// boost-Library for Matrix
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>
#include <boost/numeric/ublas/matrix_sparse.hpp>
#include <boost/numeric/ublas/operation.hpp>

CHS::SmartComponent *componentBase;
CHS::SmartComponent *componentLaser;

CHS::SendServer<Smart::CommNavigationVelocity> *navigationVelocitySendServer;
CHS::PushTimedServer<Smart::CommBaseState> *basePositionPushTimedServer;
CHS::SendServer<Smart::CommBasePositionUpdate> *basePositionUpdateSendServer;

CHS::PushNewestServer<Smart::CommMobileLaserScan> *laserServer;

CHS::QueryServer<Smart::CommVoid,Smart::CommBaseState> *baseQueryServer;

Smart::CommBasePosition robotPos;
Smart::CommBasePosition rawPos;
Smart::CommBasePosition oldPos;
CHS::SmartMutex mutexRobotPos;
CHS::SmartMutex playerClientMutex;

// probabilistic
double lamdaSigmaD;
double lamdaSigmaDeltaAlpha;
double lamdaSigmaDeltaBeta;


double totalDistance;

PlayerCc::PlayerClient robot("127.0.0.1", 6665);
PlayerCc::LaserProxy laserProxy(&robot, 0);
PlayerCc:: Position2dProxy position_2d_proxy(&robot, 0);


// -------------------------------------------------------------
// Position update
// -------------------------------------------------------------
// -PI <= a <= PI 
double piToPiRad( double a )
{
  fmod(a, 2*M_PI );
  if( a >  M_PI ) a -= 2*M_PI;
  if( a < -M_PI ) a += 2*M_PI;
  return a;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// this function just calculates the covMatric for pos1
bool updateCovMatrix( Smart::CommBasePosition pos0, Smart::CommBasePosition &pos1 )
{
  //< probabilitic (Andreas Steck 07/2008)

  // maybe some of the piToPiRad() calls are not necesarry.

  // robot orientation (radiant) !!!
  double phiK  = pos0.get_base_alpha();
  double phiK1 = pos1.get_base_alpha();

  phiK  = piToPiRad( phiK );
  phiK1 = piToPiRad( phiK1 );

  // robot motion
  double deltaX = pos1.get_x() - pos0.get_x();
  double deltaY = pos1.get_y() - pos0.get_y();
  double d = sqrt( (deltaX*deltaX) + (deltaY*deltaY) ); // euclidic distance betwenn old and new position

  double delta = 0.0;
  double deltaAlpha1 = 0.0;
  double deltaAlpha2 = 0.0;

  // delta existst only if d > 0
  if( deltaX > 0 && deltaY > 0 )
  {
    delta = atan( deltaY/deltaX ); // angle of d (angular average of robot motion)
  }
  delta = piToPiRad( delta );

  // both in radiant
  deltaAlpha1 = delta - phiK;  // angular difference
  deltaAlpha2 = phiK1 - delta; // angular difference

  // calculate new covariance matrix just if there is some motion !!!
  // if covM will be calculated and there is no motion covM will be increased, but should be constant; 
  // this is because of the fabs() in the calculation of sigmaDeltaAlpha1 and sigmaDeltaAlpha2 
  // the problem occurs by calculating sigmaQ2; sigmaQ2(1,1) and sigmaQ2(2,2) will be positiv and thus increasing covM
  // without the fabs() covM will decrease in some situations, although this should never happen
  if( d > 0.0 || fabs(phiK1-phiK) > 0.0 )
  {
    boost::numeric::ublas::matrix<double> covM(3, 3);
    covM(0,0) = pos0.get_cov(0,0);
    covM(0,1) = pos0.get_cov(0,1);
    covM(0,2) = pos0.get_cov(0,2);
    covM(1,0) = pos0.get_cov(1,0);
    covM(1,1) = pos0.get_cov(1,1);
    covM(1,2) = pos0.get_cov(1,2);
    covM(2,0) = pos0.get_cov(2,0);
    covM(2,1) = pos0.get_cov(2,1);
    covM(2,2) = pos0.get_cov(2,2);

    deltaAlpha1 = piToPiRad( deltaAlpha1 );
    deltaAlpha2 = piToPiRad( deltaAlpha2 );

    double sigmaD           = fabs(d) * lamdaSigmaD;
    double sigmaDeltaAlpha1 = fabs(deltaAlpha1) * lamdaSigmaDeltaAlpha;
    double sigmaDeltaAlpha2 = fabs(deltaAlpha2) * lamdaSigmaDeltaAlpha;
    double sigmaDeltaBeta   = fabs(d) * lamdaSigmaDeltaBeta;

    boost::numeric::ublas::matrix<double> nablaFq1(3, 3);
    nablaFq1(0,0) = 1;
    nablaFq1(0,1) = 0;
    nablaFq1(0,2) = -d * sin( phiK + deltaAlpha1 );
    nablaFq1(1,0) = 0;
    nablaFq1(1,1) = 1;
    nablaFq1(1,2) = d * cos( phiK + deltaAlpha1 )  ;
    nablaFq1(2,0) = 0;
    nablaFq1(2,1) = 0;
    nablaFq1(2,2) = 1;
 
    boost::numeric::ublas::matrix<double> nablaFq2(3, 4);
    nablaFq2(0,0) = cos( phiK + deltaAlpha1 );
    nablaFq2(0,1) = -d * sin( phiK + deltaAlpha1 );
    nablaFq2(0,2) = 0;
    nablaFq2(0,3) = 0;
    nablaFq2(1,0) = sin( phiK + deltaAlpha1 );
    nablaFq2(1,1) = d * cos( phiK + deltaAlpha1 );
    nablaFq2(1,2) = 0;
    nablaFq2(1,3) = 0;
    nablaFq2(2,0) = 0;
    nablaFq2(2,1) = 1;
    nablaFq2(2,2) = 1;
    nablaFq2(2,3) = 1;

    boost::numeric::ublas::matrix<double> sigmaQ1(3, 3);
    sigmaQ1 = covM;

    boost::numeric::ublas::matrix<double> sigmaQ2(4, 4);
    sigmaQ2(0,0) = sigmaD;
    sigmaQ2(0,1) = 0;
    sigmaQ2(0,2) = 0;
    sigmaQ2(0,3) = 0;

    sigmaQ2(1,0) = 0;
    sigmaQ2(1,1) = sigmaDeltaAlpha1;
    sigmaQ2(1,2) = 0;
    sigmaQ2(1,3) = 0;

    sigmaQ2(2,0) = 0;
    sigmaQ2(2,1) = 0;
    sigmaQ2(2,2) = sigmaDeltaAlpha2;
    sigmaQ2(2,3) = 0;

    sigmaQ2(3,0) = 0;
    sigmaQ2(3,1) = 0;
    sigmaQ2(3,2) = 0;
    sigmaQ2(3,3) = sigmaDeltaBeta;

    boost::numeric::ublas::matrix<double> tmp3x3(3, 3);
    boost::numeric::ublas::matrix<double> tmp3x3_2(3, 3);
    boost::numeric::ublas::matrix<double> tmp3x4(3, 4);
    boost::numeric::ublas::matrix<double> nablaFq1_T(3, 3);
    boost::numeric::ublas::matrix<double> nablaFq2_T(4, 3);

    nablaFq1_T = boost::numeric::ublas::trans( nablaFq1 );
    nablaFq2_T = boost::numeric::ublas::trans( nablaFq2 );

    boost::numeric::ublas::axpy_prod( nablaFq1, sigmaQ1, tmp3x3, true ); // tmp =  nablaFq1 * sigmaQ1
    boost::numeric::ublas::axpy_prod( tmp3x3, nablaFq1_T, tmp3x3_2, true ); // tmp =  tmp * nablaFq1_T

    covM.clear();
    covM = tmp3x3_2;

    boost::numeric::ublas::axpy_prod( nablaFq2, sigmaQ2, tmp3x4, true);
    boost::numeric::ublas::axpy_prod( tmp3x4, nablaFq2_T, tmp3x3, true);

    covM += tmp3x3;

    pos1.set_cov(0,0, covM(0,0) );
    pos1.set_cov(0,1, covM(0,1) );
    pos1.set_cov(0,2, covM(0,2) );
    pos1.set_cov(1,0, covM(1,0) );
    pos1.set_cov(1,1, covM(1,1) );
    pos1.set_cov(1,2, covM(1,2) );
    pos1.set_cov(2,0, covM(2,0) );
    pos1.set_cov(2,1, covM(2,1) );
    pos1.set_cov(2,2, covM(2,2) );

    return true;

  }
  // if theres was no motion the above calculations will not be done - thus set the old valuse
  // no motion --> no change in covMatrix
  else
  {
    pos1.set_cov(0,0, pos0.get_cov(0,0) );
    pos1.set_cov(0,1, pos0.get_cov(0,1) );
    pos1.set_cov(0,2, pos0.get_cov(0,2) );
    pos1.set_cov(1,0, pos0.get_cov(1,0) );
    pos1.set_cov(1,1, pos0.get_cov(1,1) );
    pos1.set_cov(1,2, pos0.get_cov(1,2) );
    pos1.set_cov(2,0, pos0.get_cov(2,0) );
    pos1.set_cov(2,1, pos0.get_cov(2,1) );
    pos1.set_cov(2,2, pos0.get_cov(2,2) );

    return false;
  }
} // ende updateCovMatrix


// -------------------------------------------------------------
// Velocity
// -------------------------------------------------------------
class NavigationVelocitySendServerHandler: public CHS::SendServerHandler<Smart::CommNavigationVelocity>
{
public:
  /**
   * Handler method for receiving navigation velocity orders.
   */
  void handleSend(const Smart::CommNavigationVelocity &cmd) throw()
  {
    // read the received CommNavigationVelocity object
    const double v = cmd.get_v();
    const double omega = cmd.get_omega();
    playerClientMutex.acquire();

    //std::cout << "Speed = " << v << std::endl;
    position_2d_proxy.SetSpeed(v/1000.0, omega);

    playerClientMutex.release();
  }
};



// -------------------------------------------------------------
// Playerloop
// -------------------------------------------------------------
class PlayerPushTimedHandler: public CHS::PushTimedHandler<Smart::CommBaseState>
{
public:
  Smart::CommBasePosition base_position;
  Smart::CommBasePosition base_position_old;
  Smart::CommBaseVelocity base_velocity;
  Smart::CommBaseState base_state;

  unsigned short oldxpos, oldypos, oldth;

  unsigned long scan_count;

  double old_yaw;
  double current_yaw;
  double real_yaw;

  PlayerPushTimedHandler() 
  {
    real_yaw = 0.0;
    old_yaw = 0.0;
    scan_count = 0;

    base_position_old.set_x(0);
    base_position_old.set_y(0);
    base_position_old.set_base_alpha(0);

    // initialize
    robotPos.set_x(0.0);
    robotPos.set_y(0.0);
    robotPos.set_base_alpha(0.0);

    rawPos.set_x(0.0);
    rawPos.set_y(0.0);
    rawPos.set_base_alpha(0.0);

    oldth = 0;
    totalDistance = 0;

    // initialize covariance matrix
    robotPos.set_cov(0,0, 50*50 );
    robotPos.set_cov(1,1, 50*50 );
    robotPos.set_cov(2,2, 5*5/180.0*M_PI );

    oldPos = robotPos;

    // uncertainity of robot
    // TODO move values to ini file
    lamdaSigmaD = 50*50/1000.0;
    lamdaSigmaDeltaAlpha = (5*5/360.0) /180.0 * M_PI;
    lamdaSigmaDeltaBeta = (2*2/1000.0) /180.0 * M_PI;

  }

  virtual ~PlayerPushTimedHandler() {}

  void handlePushTimer(CHS::PushTimedServer<Smart::CommBaseState> &server) throw()
  {
    playerClientMutex.acquire();

    robot.ReadIfWaiting();

    base_position.set_x(position_2d_proxy.GetXPos(), 1.0);
    base_position.set_y(position_2d_proxy.GetYPos(), 1.0);
    base_position.set_z(0);
    base_position.set_base_alpha(position_2d_proxy.GetYaw());

    double xSpeed;
    double ySpeed;
    xSpeed = position_2d_proxy.GetXSpeed();
    ySpeed = position_2d_proxy.GetYSpeed();
    base_velocity.set_v(((xSpeed + ySpeed) / 2.0) * 1000.0);

    double yawSpeed;
    yawSpeed = position_2d_proxy.GetYawSpeed();
    base_velocity.set_omega_base(yawSpeed);

    base_state.set_base_position(base_position);
    base_state.set_base_velocity(base_velocity);

    mutexRobotPos.acquire();

    double dx = base_position.get_x() - base_position_old.get_x();
    double dy = base_position.get_y() - base_position_old.get_y();
    double da = base_position.get_base_alpha() - base_position_old.get_base_alpha();

    base_position_old = base_position;

    robotPos.set_x( oldPos.get_x() + dx );
    robotPos.set_y( oldPos.get_y() + dy );
    robotPos.set_base_alpha( piToPiRad(oldPos.get_base_alpha() + da ));

    rawPos.set_x( rawPos.get_x() + dx );
    rawPos.set_y( rawPos.get_y() + dy );
    rawPos.set_base_alpha( piToPiRad(rawPos.get_base_alpha() + da ));

    updateCovMatrix( oldPos, robotPos );
    mutexRobotPos.release();

    oldPos = robotPos;
    base_state.set_base_position(oldPos);
    base_state.set_base_raw_position(rawPos);
    base_state.set_base_velocity(base_velocity);

    ///////////////////////////////////////////////////////////////////
    // laser
    Smart::CommMobileLaserScan scan;

    scan.set_base_state(base_state);

    double _scanner_x = 0;
    double _scanner_y = 0;
    double _scanner_z = 0;
    double _scanner_a = 0;
    bool _scanner_on_turret = false;
    
    // laser
    scan.set_scan_update_count(scan_count);

    // set timestamp
    timeval _receive_time;
    gettimeofday(&_receive_time, 0);
    scan.set_scan_time_stamp(Smart::CommTimeStamp(_receive_time));

    //////////////////////////
    // set scanner position
    //
    double base_x = 0;
    double base_y = 0;
    double base_z = 0;
    double base_a = 0;

    base_x = base_state.get_base_position().get_x();
    base_y = base_state.get_base_position().get_y();
    base_z = base_state.get_base_position().get_z();

    if(_scanner_on_turret)
    {
      base_a = base_state.get_base_position().get_turret_alpha();
    }
    else
    {
      base_a = base_state.get_base_position().get_base_alpha();
    }

    const double sin_base_a = sin(base_a);
    const double cos_base_a = cos(base_a);
    scan.set_scanner_x(base_x + _scanner_x * cos_base_a - _scanner_y * sin_base_a);
    scan.set_scanner_y(base_y + _scanner_x * sin_base_a + _scanner_y * cos_base_a);
    scan.set_scanner_z(base_z + _scanner_z);
    scan.set_scanner_azimuth(base_a + _scanner_a);

    //////////////////////////
    // set scan parameters
    //
    scan.set_scan_length_unit(1);
    scan.set_scan_integer_field_of_view(-50*180, 50);

    //////////////////////////
    // get maximum non-overflow distance
    //
    const unsigned int max_dist = 7500;

    //////////////////////////
    // set scan points
    //
    const unsigned int num_points = laserProxy.GetCount();

    if( num_points == 0)
    {
      scan.set_scan_valid(false);
    }
    else
    {
      unsigned int num_valid_points = 0;
      for(unsigned int i=0; i<num_points; ++i)
      {
        if((unsigned int)(laserProxy[i]*1000.0) <= max_dist) ++num_valid_points;
      }
 
      scan.set_scan_size(num_valid_points);
      unsigned int valid_point_index = 0;
      for(unsigned int i=0; i<num_points; ++i)
      {
        const unsigned int dist = (unsigned int)(laserProxy[i]*1000.0);
        if(dist <= max_dist)
        {
          scan.set_scan_index(valid_point_index, i);
          scan.set_scan_integer_distance(valid_point_index, dist);
          valid_point_index++;
        }
      }

      scan.set_scan_valid(true);
    }

    playerClientMutex.release();

    server.put(base_state);
    laserServer->put(scan);

    ++scan_count; 
    scan.set_scan_valid(false);

  }
};







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int updatePosition( Smart::CommBasePositionUpdate update )
{
  bool isCovUpdated = false;

  Smart::CommBasePosition oldPos          = update.get_old_position();
  Smart::CommBasePosition correctedPos    = update.get_corrected_position();
  Smart::CommBasePosition newCorrectedPos;

  // robot motion between current position and the position the laserscan (selfloc-scan) was taken 
  double deltaX = robotPos.get_x() - oldPos.get_x();
  double deltaY = robotPos.get_y() - oldPos.get_y();
  double deltaA = piToPiRad( robotPos.get_base_alpha() )  - piToPiRad( oldPos.get_base_alpha() );
  deltaA = piToPiRad( deltaA );

  newCorrectedPos.set_x( correctedPos.get_x() + deltaX );
  newCorrectedPos.set_y( correctedPos.get_y() + deltaY );
  newCorrectedPos.set_base_alpha( piToPiRad(correctedPos.get_base_alpha() + deltaA) );

  // calculate covMatrix
  isCovUpdated = updateCovMatrix( correctedPos, newCorrectedPos );
  // now in newCorrectedPos exists the new covMatrix

  // robot motion once more. this is because of the motion while calculating covM 
  deltaX = robotPos.get_x() - oldPos.get_x();
  deltaY = robotPos.get_y() - oldPos.get_y();
  deltaA = piToPiRad( robotPos.get_base_alpha() ) - piToPiRad( oldPos.get_base_alpha() );
  deltaA = piToPiRad( deltaA );

  newCorrectedPos.set_x( correctedPos.get_x() + deltaX );
  newCorrectedPos.set_y( correctedPos.get_y() + deltaY );
  newCorrectedPos.set_base_alpha( piToPiRad( piToPiRad(correctedPos.get_base_alpha()) + deltaA) );
//  newCorrectedPos.set_base_alpha( correctedPos.get_base_alpha() + deltaA );

  // update of the robot Position
  mutexRobotPos.acquire();
  robotPos = newCorrectedPos;
  oldPos = robotPos;

  // set odometry of robot
  //position_2d_proxy.SetOdometry( robotPos.get_x()/1000.0, robotPos.get_y()/1000.0, robotPos.get_base_alpha() );


  printf("Pos        (cnt=%lu) ( %9.4f %9.4f %6.2f deg)\n", correctedPos.get_update_count(),
           newCorrectedPos.get_x(), newCorrectedPos.get_y(), newCorrectedPos.get_base_alpha() /M_PI*180.0 );

  printf("corrected covM  (0,0)(1,1)(2,2): %8.1f; %8.1f; %8.1f \n", correctedPos.get_cov(0,0),
           correctedPos.get_cov(1,1), correctedPos.get_cov(2,2) );

  mutexRobotPos.release();

  return 0;
}

class BasePositionUpdateSendHandler: public CHS::SendServerHandler<Smart::CommBasePositionUpdate>
{
public:
  void handleSend(const Smart::CommBasePositionUpdate &upd) throw()
  {
    Smart::CommBasePosition oldPos          = upd.get_old_position();
    Smart::CommBasePosition correctedPos    = upd.get_corrected_position();
    Smart::CommBasePosition newCorrectedPos;

    // robot motion between current position and the position the laserscan (selfloc-scan) was taken 
    double deltaX = robotPos.get_x() - oldPos.get_x();
    double deltaY = robotPos.get_y() - oldPos.get_y();
    double deltaA = piToPiRad( robotPos.get_base_alpha() )  - piToPiRad( oldPos.get_base_alpha() );
    deltaA = piToPiRad( deltaA );

    newCorrectedPos.set_x( correctedPos.get_x() + deltaX );
    newCorrectedPos.set_y( correctedPos.get_y() + deltaY );
    newCorrectedPos.set_base_alpha( piToPiRad(correctedPos.get_base_alpha() + deltaA) );

    // calculate covMatrix
    updateCovMatrix( correctedPos, newCorrectedPos );
    // now in newCorrectedPos exists the new covMatrix

    // robot motion once more. this is because of the motion while calculating covM 
    deltaX = robotPos.get_x() - oldPos.get_x();
    deltaY = robotPos.get_y() - oldPos.get_y();
    deltaA = piToPiRad( robotPos.get_base_alpha() ) - piToPiRad( oldPos.get_base_alpha() );
    deltaA = piToPiRad( deltaA );

    newCorrectedPos.set_x( correctedPos.get_x() + deltaX );
    newCorrectedPos.set_y( correctedPos.get_y() + deltaY );
    newCorrectedPos.set_base_alpha( piToPiRad( piToPiRad(correctedPos.get_base_alpha()) + deltaA) );

    // update of the robot Position
    mutexRobotPos.acquire();
    robotPos = newCorrectedPos;
    oldPos = robotPos;

    // set odometry of robot
    position_2d_proxy.SetOdometry( robotPos.get_x()/1000.0, robotPos.get_y()/1000.0, robotPos.get_base_alpha() );


    printf("Pos        (cnt=%lu) ( %9.4f %9.4f %6.2f deg)\n", correctedPos.get_update_count(),
             newCorrectedPos.get_x(), newCorrectedPos.get_y(), newCorrectedPos.get_base_alpha() /M_PI*180.0 );

    printf("corrected covM  (0,0)(1,1)(2,2): %8.1f; %8.1f; %8.1f \n", correctedPos.get_cov(0,0),
             correctedPos.get_cov(1,1), correctedPos.get_cov(2,2) );

    mutexRobotPos.release();
  }
};



class LaserCompTask : public CHS::SmartTask
{
public:
  unsigned long scan_count;

  LaserCompTask() {}
  ~LaserCompTask() {}

  int svc(void)
  {
    componentLaser->run();
    return 0;
  }
};



class BaseStateQueryHandler :  public CHS::QueryServerHandler<Smart::CommVoid,Smart::CommBaseState>
{ 
public:

  void handleQuery(CHS::QueryServer<Smart::CommVoid,Smart::CommBaseState> & server,
                     const CHS::QueryId id,
                     const Smart::CommVoid& r) throw()
  
  {
    std::cout << "Query for basestate \n";

    playerClientMutex.acquire();

    robot.ReadIfWaiting();

    base_position.set_x(position_2d_proxy.GetXPos(), 1.0);
    base_position.set_y(position_2d_proxy.GetYPos(), 1.0);
    base_position.set_z(0);
    base_position.set_base_alpha(position_2d_proxy.GetYaw());

    double xSpeed;
    double ySpeed;
    xSpeed = position_2d_proxy.GetXSpeed();
    ySpeed = position_2d_proxy.GetYSpeed();
    base_velocity.set_v(((xSpeed + ySpeed) / 2.0) * 1000.0);

    double yawSpeed;
    yawSpeed = position_2d_proxy.GetYawSpeed();
    base_velocity.set_omega_base(yawSpeed);

    playerClientMutex.release();

    base_state.set_base_position(base_position);
    base_state.set_base_velocity(base_velocity);

    server.answer(id, base_state);
} 

private:
  Smart::CommTimeStamp time_stamp; 
  Smart::CommBasePosition base_position;
  Smart::CommBaseVelocity base_velocity;
  Smart::CommBaseState base_state;
    
};


// -------------------------------------------------------------
//
// Main
//
// -------------------------------------------------------------
int main (int argc, char *argv[])
{
  try
  {
    componentBase  = new CHS::SmartComponent("smartPioneerBaseServer",argc,argv);
    componentLaser = new CHS::SmartComponent("smartLaserServer",argc,argv);
    CHS::SmartParameter parameter;

    try
    {
        robot.SetDataMode( PLAYERC_DATAMODE_PUSH );
        robot.SetReplaceRule( true, -1, -1, -1 );
    }
    catch (PlayerCc::PlayerError e)
    {
        std::cout << "Could not set to pull-mode" << std::endl;
        std::cout << e.GetErrorStr() << std::endl;
    }

    position_2d_proxy.SetMotorEnable(true);
    laserProxy.IntensityOn();
    robot.Read();
    robot.Read();

    // NavigationVelocity SendServer:
    NavigationVelocitySendServerHandler navigationVelocitySendServerHandler;
    navigationVelocitySendServer = new CHS::SendServer<Smart::CommNavigationVelocity>(componentBase, "navigationvelocity", navigationVelocitySendServerHandler);

    // BasePosition PushTimedServer:
    PlayerPushTimedHandler playerPushTimedHandler;
    basePositionPushTimedServer = new CHS::PushTimedServer<Smart::CommBaseState>(componentBase, "basestate", playerPushTimedHandler, 
             25 / 1000.0);  // 25ms

    // BasePositionUpdate SendServer
    BasePositionUpdateSendHandler basePositionUpdateSendHandler;
    basePositionUpdateSendServer = new CHS::SendServer<Smart::CommBasePositionUpdate>(componentBase, "positionUpdate", basePositionUpdateSendHandler);


    // BaseStateQuery Server
    BaseStateQueryHandler baseStateQueryHandler;
    baseQueryServer = new CHS::QueryServer<Smart::CommVoid,Smart::CommBaseState>(componentBase, "basestatequery", baseStateQueryHandler);



    // laser
    laserServer = new CHS::PushNewestServer<Smart::CommMobileLaserScan>(componentLaser, "scan");

    LaserCompTask laserCompTask;
    laserCompTask.open(); 

    basePositionPushTimedServer->start();

    componentBase->run();
  }
  catch (const CORBA::Exception &)
  {
    std::cerr << "Uncaught CORBA exception" << std::endl;
    return 1;
  }
  catch (...)
  {
    std::cerr << "Uncaught exception" << std::endl;
    return 1;
  }

  return 0;
}
