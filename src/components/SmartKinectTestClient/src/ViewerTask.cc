//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.8.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//------------------------------------------------------------------------
//
//  Copyright (C) 2011 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of "CommKinectTestClient".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include <mrpt/gui.h>
#include <mrpt/opengl.h>
#include <mrpt/utils.h>

#include "ViewerTask.hh"
#include "gen/SmartKinectTestClient.hh"

#include <CommVisionObjects/commKinectImage.hh>

#include <armadillo.hh>
#include <OpenCVHelpers.hh>

#include <iostream>

using namespace mrpt;
using namespace mrpt::gui;
using namespace mrpt::opengl;

ViewerTask::ViewerTask()
{
}

int ViewerTask::svc()
{
	// activate kinect
	//COMP->stateClient->setWaitState("active");

	// create windows
	CDisplayWindow rgbImage("RGB Image");
	CDisplayWindow depthImage_Window("Depth Image");
	CDisplayWindow3D cartesianWindow("Cartesian Points", 640, 480);

	// place windows on screen
	rgbImage.setPos(0, 0);
	cartesianWindow.setPos(0, 260);

	cartesianWindow.setCameraProjective(true);
	cartesianWindow.setCameraElevationDeg(25.0f);
	cartesianWindow.setCameraAzimuthDeg(160.0f);
	cartesianWindow.setCameraPointingToPoint(4, 0, 0);
	cartesianWindow.setCameraZoom(12.0f);

	COpenGLScenePtr &theScene = cartesianWindow.get3DSceneAndLock();

	opengl::CPointCloudColouredPtr cloud = opengl::CPointCloudColoured::Create();
	cloud->setName("cloud");
	cloud->setPointSize(2.0);
	theScene->insert(cloud);

	{
		// Add world coordinate system
		opengl::CSimpleLinePtr xAxis = opengl::CSimpleLine::Create();
		xAxis->setName("world_x");
		xAxis->setLineCoords(0, 0, 0, 0.3, 0, 0);
		xAxis->setLineWidth(3.0);
		xAxis->setColor(mrpt::utils::TColorf(1, 0, 0));
		theScene->insert(xAxis);

		opengl::CSimpleLinePtr yAxis = opengl::CSimpleLine::Create();
		yAxis->setName("world_y");
		yAxis->setLineCoords(0, 0, 0, 0, 0.3, 0);
		yAxis->setLineWidth(3.0);
		yAxis->setColor(mrpt::utils::TColorf(0, 1, 0));
		theScene->insert(yAxis);

		opengl::CSimpleLinePtr zAxis = opengl::CSimpleLine::Create();
		zAxis->setName("world_z");
		zAxis->setLineCoords(0, 0, 0, 0, 0, 0.3);
		zAxis->setLineWidth(3.0);
		zAxis->setColor(mrpt::utils::TColorf(0, 0, 1));
		theScene->insert(zAxis);
	}

	{
		// Add robot coordinate system
		opengl::CSimpleLinePtr xAxis = opengl::CSimpleLine::Create();
		xAxis->setName("robot_x");
		xAxis->setLineCoords(0, 0, 0, 0.2, 0, 0);
		xAxis->setLineWidth(3.0);
		xAxis->setColor(mrpt::utils::TColorf(1, 0, 0));
		theScene->insert(xAxis);

		opengl::CSimpleLinePtr yAxis = opengl::CSimpleLine::Create();
		yAxis->setName("robot_y");
		yAxis->setLineCoords(0, 0, 0, 0, 0.2, 0);
		yAxis->setLineWidth(3.0);
		yAxis->setColor(mrpt::utils::TColorf(0, 1, 0));
		theScene->insert(yAxis);

		opengl::CSimpleLinePtr zAxis = opengl::CSimpleLine::Create();
		zAxis->setName("robot_z");
		zAxis->setLineCoords(0, 0, 0, 0, 0, 0.2);
		zAxis->setLineWidth(3.0);
		zAxis->setColor(mrpt::utils::TColorf(0, 0, 1));
		theScene->insert(zAxis);
	}

	{
		// Add sensor coordinate system
		opengl::CSimpleLinePtr xAxis = opengl::CSimpleLine::Create();
		xAxis->setName("sensor_x");
		xAxis->setLineCoords(0, 0, 0, 0.1, 0, 0);
		xAxis->setLineWidth(3.0);
		xAxis->setColor(mrpt::utils::TColorf(1, 0, 0));
		theScene->insert(xAxis);

		opengl::CSimpleLinePtr yAxis = opengl::CSimpleLine::Create();
		yAxis->setName("sensor_y");
		yAxis->setLineCoords(0, 0, 0, 0, 0.1, 0);
		yAxis->setLineWidth(3.0);
		yAxis->setColor(mrpt::utils::TColorf(0, 1, 0));
		theScene->insert(yAxis);

		opengl::CSimpleLinePtr zAxis = opengl::CSimpleLine::Create();
		zAxis->setName("sensor_z");
		zAxis->setLineCoords(0, 0, 0, 0, 0, 0.1);
		zAxis->setLineWidth(3.0);
		zAxis->setColor(mrpt::utils::TColorf(0, 0, 1));
		theScene->insert(zAxis);
	}

	cartesianWindow.unlockAccess3DScene();

	// ------------------------------------------------------
	while (!mrpt::system::os::kbhit() && cartesianWindow.isOpen())
	{

		CommBasicObjects::CommVoid v;
		CommVisionObjects::CommKinectImage image;

		COMP->imagePushNewestClient->getUpdateWait(image);
		//COMP->kinectQueryClient->query(v, image);

		// save file
		if (image.is_data_valid() && COMP->ini.general.save_to_file)
		{
			ofstream myfile(COMP->ini.general.filename.c_str());
			if (myfile.is_open())
			{
				image.save_xml(myfile);
				myfile.close();
			}
		}

		if (image.is_data_valid())
		{


		//{ // write cloud to file
		//	fstream filestr;
		//	filestr.open ("kinect_kart_points_sensor.txt", fstream::out);
		//	double x,y,z;
		//	CommVisionObjects::Comm3dPointCloud pointCloud = image.get_as_3dPointCloud_sensor();
		//	for (uint32_t i = 0; i < pointCloud.get_size(); ++i) {
		//		pointCloud.get_point(i, x, y, z, 1);
		//		filestr<<x <<" "<<y<<" "<<z<<std::endl;
		//	}
		//	filestr.close();
		//}
		//{ // write cloud to file
		//	fstream filestr;
		//	filestr.open ("kinect_kart_points_robot.txt", fstream::out);
		//	double x,y,z;
		//	CommVisionObjects::Comm3dPointCloud pointCloud = image.get_as_3dPointCloud_robot();
		//	for (uint32_t i = 0; i < pointCloud.get_size(); ++i) {
		//		pointCloud.get_point(i, x, y, z, 1);
		//		filestr<<x <<" "<<y<<" "<<z<<std::endl;
		//	}
		//	filestr.close();
		//	char buf[500];
		//	std::cout << "cin for next image." << std::endl;
		//	cin >> buf;
		//}
	
			std::cout << "counter: " << image.get_sequence_counter() << "\n";
			std::cout << "min_distance: " << image.get_min_distance() << "\n";
			std::cout << "max_distance: " << image.get_max_distance() << "\n";

			//////////////////////////////////////////
			// show rgb image
			{
				CImage colorImage(image.get_rgb_width(), image.get_rgb_height());
				std::cout << "width x height: " << image.get_rgb_width() << "x" << image.get_rgb_height() << std::endl;
				const uint8_t* imageData = image.get_rgb_image();
				for (uint32_t i = 0; i < image.get_rgb_height(); i++)
				{
					for (uint32_t j = 0; j < image.get_rgb_width(); j++)
					{

						const uint8_t* pixel = (imageData + i * 3* image .get_rgb_width() + j * 3);

						uint8_t r = pixel[0];
						uint8_t g = pixel[1];
						uint8_t b = pixel[2];

						TColor color(r, g, b);
						colorImage.setPixel(j, i, color);
					}
				}
				rgbImage.showImage(colorImage);
			}

			//////////////////////////////////////////
			// show depth image
			{
				CImage depthImage(image.get_distance_width(), image.get_distance_height());
				std::cout << "depth width x height: " << image.get_distance_width() << "x" << image.get_distance_height() << std::endl;
				const float* imageData = image.get_distances();
				for (uint32_t i = 0; i < image.get_distance_height(); i++)
				{
					for (uint32_t j = 0; j < image.get_distance_width(); j++)
					{

						const float* pixel = (imageData + i * image.get_distance_width() + j);

						uint8_t r = pixel[0] / 8* 255 ;
						uint8_t g = pixel[0] / 8* 255 ;
						uint8_t b = pixel[0] / 8* 255 ;

						TColor color(r, g, b);
						depthImage.setPixel(j, i, color);
					}
				}
				depthImage_Window.showImage(depthImage);
			}

			//////////////////////////////////////////

			// calculate points and colors
			arma::vec q(4);
			q(3) = 1;

			double x, y, z;
			float r = 0, g = 0, b = 0;
			std::vector<ColPoint3d> points;
			const arma::mat& project = image.get_color_intrinsic() * image.get_camera_extrinsic();
			const uint8_t* rgbImg = image.get_rgb_image();

			for (uint32_t w = 0; w < image.get_distance_width(); w++)
			{
				for (uint32_t h = 0; h < image.get_distance_height(); h++)
				{
					image.get_cartesian_point_sensor(w, h, q(0), q(1), q(2), 1);
					arma::vec p = project * q;
					p /= p(2);

					uint32_t px = p(0);
					uint32_t py = p(1);

					if (px >= 0 && px < image.get_rgb_width() && py >= 0 && py < image.get_rgb_height())
					{

						r = (rgbImg + 3* image .get_rgb_width() * py)[px * 3];
						g = (rgbImg + 3* image .get_rgb_width() * py)[px * 3 + 1];
						b = (rgbImg + 3* image .get_rgb_width() * py)[px * 3 + 2];
					}

					image.get_cartesian_point_world(w, h, x, y, z, 1);
					points.push_back(ColPoint3d(x, y, z, r / 255.0, g / 255.0, b / 255.0));
				}
			}

			COpenGLScenePtr & theScene = cartesianWindow.get3DSceneAndLock();
			//////////////////////////////////////////
			// show coordinates
			{
				cloud->clear();
				for (uint32_t i = 0; i < points.size(); i++)
				{
					cloud->push_back(points[i].x, points[i].y, points[i].z, points[i].r, points[i].g, points[i].b);
				}

			}
			//////////////////////////////////////////


			//////////////////////////////////////////
			// show robot coordinate system
			{
				arma::mat pose_robot = image.get_base_state().get_base_position().get_base_pose3d().getHomogeneousMatrix(1);

				arma::vec origin(4);
				origin.zeros();
				origin[3] = 1;

				arma::vec x(4);
				x = origin;
				x[0] = 0.2;
				x = pose_robot * x;

				arma::vec y(4);
				y = origin;
				y[1] = 0.2;
				y = pose_robot * y;

				arma::vec z(4);
				z = origin;
				z[2] = 0.2;
				z = pose_robot * z;

				origin = pose_robot * origin;

				opengl::CSimpleLinePtr xAxis = (opengl::CSimpleLinePtr) theScene->getByName("robot_x");
				xAxis->setLineCoords(origin[0], origin[1], origin[2], x[0], x[1], x[2]);

				opengl::CSimpleLinePtr yAxis = (opengl::CSimpleLinePtr) theScene->getByName("robot_y");
				yAxis->setLineCoords(origin[0], origin[1], origin[2], y[0], y[1], y[2]);

				opengl::CSimpleLinePtr zAxis = (opengl::CSimpleLinePtr) theScene->getByName("robot_z");
				zAxis->setLineCoords(origin[0], origin[1], origin[2], z[0], z[1], z[2]);
			}
			//////////////////////////////////////////


			//////////////////////////////////////////
			// show sensor coordinate system
			{
				arma::mat pose = image.get_sensor_pose().getHomogeneousMatrix(1);
				arma::mat pose_robot = image.get_base_state().get_base_position().get_base_pose3d().getHomogeneousMatrix(1);

				arma::vec origin(4);
				origin.zeros();
				origin[3] = 1;

				arma::vec x(4);
				x = origin;
				x[0] = 0.1;
				x = pose_robot * pose * x;

				arma::vec y(4);
				y = origin;
				y[1] = 0.1;
				y = pose_robot * pose * y;

				arma::vec z(4);
				z = origin;
				z[2] = 0.1;
				z = pose_robot * pose * z;

				origin = pose_robot * pose * origin;

				opengl::CSimpleLinePtr xAxis = (opengl::CSimpleLinePtr) theScene->getByName("sensor_x");
				xAxis->setLineCoords(origin[0], origin[1], origin[2], x[0], x[1], x[2]);

				opengl::CSimpleLinePtr yAxis = (opengl::CSimpleLinePtr) theScene->getByName("sensor_y");
				yAxis->setLineCoords(origin[0], origin[1], origin[2], y[0], y[1], y[2]);

				opengl::CSimpleLinePtr zAxis = (opengl::CSimpleLinePtr) theScene->getByName("sensor_z");
				zAxis->setLineCoords(origin[0], origin[1], origin[2], z[0], z[1], z[2]);
			}
			//////////////////////////////////////////
			cartesianWindow.unlockAccess3DScene();
			cartesianWindow.forceRepaint();

		} else
		{
			std::cout << "data invalid\n";
		}

	}

	return 0;
}
