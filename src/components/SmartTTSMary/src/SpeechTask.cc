//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2009 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft SmartTTSMary component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the communication with the mary speech output server was
// taken from the mary project, which is distributed under there own license,
// and you can find at http://mary.dfki.de/ .
//
//
// Copyright 2000-2006 DFKI GmbH.
// All Rights Reserved.  Use is subject to license terms.
//
// Permission is hereby granted, free of charge, to use and distribute
// this software and its documentation without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of this work, and to
// permit persons to whom this work is furnished to do so, subject to
// the following conditions:
//
// 1. The code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 2. Any modifications must be clearly marked as such.
// 3. Original authors' names are not deleted.
// 4. The authors' names are not used to endorse or promote products
//    derived from this software without specific prior written
//    permission.
//
// DFKI GMBH AND THE CONTRIBUTORS TO THIS WORK DISCLAIM ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DFKI GMBH NOR THE
// CONTRIBUTORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
// DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
// PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
// ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.
//
// --------------------------------------------------------------------------





#include "SpeechTask.hh"
#include "gen/SmartTTSMary.hh"
#include "mary_client.hh"

#include <iostream>

SpeechTask::SpeechTask()
{
	std::cout << "constructor SpeechTask\n";
}

int SpeechTask::svc()
{
    //address of the mary speechoutput server
//    std::string server_host = "localhost";
//    int server_port         = 59125;
    char filename[255];

    //temporary file for speechoutput via aplay
    sprintf(filename,"tmp.wav");
    //audio player for system call
    //std::string audioplayer = "aplay";

    while(true)
    {
      // wait for queue entry
      COMP->_queue_sem.acquire();

      // pop queue entry
      COMP->_queue_mutex.acquire();
      SmartTTSMary::QueueEntry entry = COMP->_queue.front();
      COMP->_queue.pop_front();
      COMP->_queue_mutex.release();

      // process queue entry:
      CommBasicObjects::CommPropertySet answer;

      // check time stamp
      if(entry.msg.get_discard_time().is_before(CommBasicObjects::CommTimeStamp::now()))
      {
        answer.set("success",false);
        answer.set("discarded",true);
      }
      else
      {
        std::string result;
        //get audio stream from mary_server
        mary_query(COMP->ini.mary.maryServerHost,
        		COMP->ini.mary.maryServerPort,
        		entry.msg.get_message() ,
        		COMP->ini.mary.inputType,
        		COMP->ini.mary.outputType,
        		COMP->ini.mary.audioType,
        		COMP->ini.mary.voiceType,
        		result);

        std::ofstream myFile ( filename , std::ios::out | std::ios::binary);

        myFile<<result;

        myFile.close();

        // call appliation to play wave file
        std::string audio_string = COMP->ini.mary.audioplayer + " "+filename;
        if(system (audio_string.c_str())==0)
        {
          answer.set("success",true);
          answer.set("discarded",false);
        }
        else
        {
          // file open failed
          answer.set("success",false);
          answer.set("discarded",false);
          answer.set("error",std::string("Could not play sound!\n"));
        }
      }

      // answer query, unless request was plain "send"
      if(entry.query_server)
      {
        entry.query_server->answer(entry.id, answer);
      }
    }




	return 0;
}
