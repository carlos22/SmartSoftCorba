//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//
//  Copyright (C) 2011 Jonas Brich, Manuel Wopfner
//
//        brich@mail.hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "IDS uEye Video Server component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "ImageTask.hh"
#include "gen/SmartIDSuEyeImageServer.hh"
#include "Ueye.hh"

#include "EulerTransformationMatrices.hh"

#include <CommManipulatorObjects/commMobileManipulatorState.hh>

#include <iostream>
#include <armadillo.hh>

ImageTask::ImageTask()
{
	_image_buffer_index = 0;
}

ImageTask::~ImageTask()
{
	COMP->imageTask.close();
	for (unsigned int i = 0; i < _image_buffer.size(); i++)
	{
		delete _image_buffer[i];
	}
	_image_buffer.clear();
}

int ImageTask::svc()
{

	CommBasicObjects::CommBasePosition default_base_position;
	default_base_position.set_x(COMP->ini.base.x);
	default_base_position.set_y(COMP->ini.base.y);
	default_base_position.set_z(COMP->ini.base.z);
	default_base_position.set_base_alpha(COMP->ini.base.base_a);
	default_base_position.set_steer_alpha(COMP->ini.base.steer_a);
	default_base_position.set_turret_alpha(COMP->ini.base.turret_a);

	CommBasicObjects::CommBaseVelocity zero_velocity;
	zero_velocity.set_v(0);
	zero_velocity.set_omega_base(0);
	zero_velocity.set_omega_steer(0);
	zero_velocity.set_omega_turret(0);

	CommVisionObjects::CommVideoImage* image = NULL;

	while (true)
	{
		if (COMP->stateServer->acquire("pushimage") == CHS::SMART_OK)
		{
			// if the image buffer size is empty close task
			if (_image_buffer.size() == 0)
			{
				std::cerr << "[ImageTask] Error: Image buffer size is zero\n";
				return 1;
			}

			image = _image_buffer[_image_buffer_index];

			// get newest image from uEye camera


			if (!COMP->camera.getImage(*image))
			{
				continue;
			}

			arma::mat sensorMat;
			EulerTransformationMatrices::create_zyx_matrix(COMP->ini.sensor_pose.x, COMP->ini.sensor_pose.y, COMP->ini.sensor_pose.z,
					COMP->ini.sensor_pose.azimuth, COMP->ini.sensor_pose.elevation, COMP->ini.sensor_pose.roll, sensorMat);

			// set base state
			CommBasicObjects::CommBaseState base_state;
			if (COMP->ini.base.on_actuator)
			{
				CommBasicObjects::CommDevicePoseState devicePoseState;
				CHS::StatusCode status = COMP->actuatorPushTimedClient->getUpdate(devicePoseState);

				base_state = devicePoseState.get_base_state();
				CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
				arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

				sensorMat = ptuMat * sensorMat;

				if (status != CHS::SMART_OK)
				{
					std::cerr << "WARNING: failed to get current device state (" << CHS::StatusCodeConversion(status)
							<< "), pushing invalid image" << std::endl;
					image->set_data_invalid();
				}

			} else if (COMP->ini.base.on_manipulator)
			{
				CommManipulatorObjects::CommMobileManipulatorState manipState;
				CHS::StatusCode status = COMP->manipulatorPushTimedClient->getUpdate(manipState);

				double x, y, z, azimuth, elevation, roll;
				base_state = manipState.get_base_state();
				manipState.get_manipulator_state().get_pose_TCP_robot(x, y, z, azimuth, elevation, roll);
				CommBasicObjects::CommPose3d manipPose(x, y, z, azimuth, elevation, roll);
				arma::mat manipMat = manipPose.getHomogeneousMatrix();

				sensorMat = manipMat * sensorMat;

				if (status != CHS::SMART_OK)
				{
					std::cerr << "WARNING: failed to get current manipulator state (" << CHS::StatusCodeConversion(status)
							<< "), pushing invalid image" << std::endl;
					image->set_data_invalid();
				}
			}
			// read base state from base server
			else if (COMP->ini.base.on_base)
			{
				CHS::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

				if (status != CHS::SMART_OK)
				{
					std::cerr << "WARNING: failed to get current base state (" << CHS::StatusCodeConversion(status)
							<< "), pushing invalid image" << std::endl;
					image->set_data_invalid();
				}
			}
			// default base state
			else
			{
				base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
				base_state.set_base_position(default_base_position);
				base_state.set_base_velocity(zero_velocity);
			}

			CommBasicObjects::CommPose3d sensorPose(sensorMat);
			image->set_sensor_pose(sensorPose);
			image->set_base_state(base_state);

			// Save the newest image into the global Pointer
			COMP->NewestImageMutex.acquire();
			COMP->newestImage = image;
			COMP->NewestImageMutex.release();

			COMP->imagePushNewestServer->put(*image);
			if (COMP->ini.settings.debug_info)
			{
				std::cout << "Newest: Image sent.\n";
			}

			// calculate new index in the ring_buffer
			_image_buffer_index++;
			if (_image_buffer_index == _image_buffer.size())
				_image_buffer_index = 0;

			COMP->stateServer->release("pushimage");
		}
	}
	return 0;
}

void ImageTask::createImageBuffer()
{
	// clear buffer
	for (unsigned int i = 0; i < _image_buffer.size(); i++)
	{
		delete _image_buffer[i];
	}
	_image_buffer.clear();

	// create buffer
	_image_buffer.resize(2);

	// Fill ring_buffer with empty images
	for (unsigned int i = 0; i < _image_buffer.size(); i++)
	{
		_image_buffer[i] = new CommVisionObjects::CommVideoImage(COMP->camera.getWidth(), COMP->camera.getHeight(),
				COMP->camera.getColorMode().getVisionFormat());
	}
}

