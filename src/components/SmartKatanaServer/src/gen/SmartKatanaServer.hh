//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.2
// The SmartSoft Toolchain has been developed by:
//  
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
// 
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#ifndef _SMARTKATANASERVER_HH
#define _SMARTKATANASERVER_HH

#include <iostream>
#include "smartSoft.hh"
#include "../SmartKatanaServerCore.hh"
// include communication objects
#include <CommBasicObjects/commBaseState.hh>

#include <CommBasicObjects/commMobileLaserScan.hh>

#include <CommBasicObjects/commVoid.hh>

#include <CommManipulatorObjects/commManipulatorEventParameter.hh>

#include <CommManipulatorObjects/commManipulatorEventResult.hh>

#include <CommManipulatorObjects/commManipulatorId.hh>

#include <CommManipulatorObjects/commManipulatorParameter.hh>

#include <CommManipulatorObjects/commManipulatorRequestScan3d.hh>

#include <CommManipulatorObjects/commManipulatorTrajectory.hh>

#include <CommManipulatorObjects/commMobileManipulatorState.hh>

#include <CommManipulatorObjects/manipulatorEventState.hh>

#include <CommManipulatorObjects/scanEventState.hh>

#include <CommVisionObjects/comm3dPointCloud.hh>

// include tasks	

// include handler
#include "../CompHandler.hh"
#include "../EventTestHandler.hh"
#include "../ParamHandler.hh"
#include "../PosePushTimedHandler.hh"
#include "../RequestScan3dHandler.hh"
#include "../Scan3dHandler.hh"
#include "../ScanEventTestHandler.hh"
#include "../StateChangeHandler.hh"
#include "../TrajectorySendHandler.hh"

#define COMP SmartKatanaServer::instance()

class SmartKatanaServer: public SmartKatanaServerCore
{
private:
	static SmartKatanaServer _smartKatanaServer;

	// constructor
	SmartKatanaServer();

	// copy-constructor
	SmartKatanaServer(const SmartKatanaServer& cc);

	// destructor
	~SmartKatanaServer()
	{
	}
	;

	// load parameter from ini file
	void loadParameter(int argc, char *argv[]);

	// instantiate handler
	CompHandler compHandler;
	EventTestHandler eventTestHandler;
	ParamHandler paramHandler;
	PosePushTimedHandler posePushTimedHandler;
	RequestScan3dHandler requestScan3dHandler;
	Scan3dHandler scan3dHandler;
	ScanEventTestHandler scanEventTestHandler;
	StateChangeHandler stateChangeHandler;
	TrajectorySendHandler trajectorySendHandler;

	// ThreadQueueHandler 


	CHS::ThreadQueueSendHandler<
			CommManipulatorObjects::CommManipulatorRequestScan3d>
			*threadRequestScan3dHandler;

	CHS::ThreadQueueQueryHandler<CommManipulatorObjects::CommManipulatorId,
			CommVisionObjects::Comm3dPointCloud> *threadScan3dHandler;

	CHS::ThreadQueueSendHandler<
			CommManipulatorObjects::CommManipulatorTrajectory>
			*threadTrajectorySendHandler;

public:
	// component
	CHS::SmartComponent *component;

	// create mutex
	CHS::SmartMutex EncoderMutex;
	CHS::SmartMutex KatanaMutex;
	CHS::SmartMutex ParameterMutex;
	CHS::SmartMutex PointCloudMutex;

	// create condition mutex


	// instantiate tasks


	// ports
	CHS::PushTimedClient<CommBasicObjects::CommBaseState> *basePushTimedClient;
	CHS::EventServer<CommManipulatorObjects::CommManipulatorEventParameter,
			CommManipulatorObjects::CommManipulatorEventResult,
			CommManipulatorObjects::ManipulatorEventState> *eventServer;
	CHS::QueryClient<CommBasicObjects::CommVoid,
			CommBasicObjects::CommMobileLaserScan> *laserQueryClient;
	CHS::SendServer<CommManipulatorObjects::CommManipulatorParameter>
			*paramServer;
	CHS::PushTimedServer<CommManipulatorObjects::CommMobileManipulatorState>
			*posePushTimedServer;
	CHS::SendServer<CommManipulatorObjects::CommManipulatorRequestScan3d>
			*requestScan3dSendServer;
	CHS::EventServer<CommBasicObjects::CommVoid,
			CommManipulatorObjects::CommManipulatorId,
			CommManipulatorObjects::ScanEventState> *scan3dEventServer;
	CHS::QueryServer<CommManipulatorObjects::CommManipulatorId,
			CommVisionObjects::Comm3dPointCloud> *scan3dQueryServer;
	CHS::SmartStateServer *stateServer;
	CHS::SendServer<CommManipulatorObjects::CommManipulatorTrajectory>
			*trajectorySendServer;

	void init(int argc, char *argv[]);
	void run();

	// return singleton instance
	static SmartKatanaServer* instance()
	{
		return (SmartKatanaServer*) &_smartKatanaServer;
	}

	// ini parameter
	struct ini_ini
	{

		// component struct
		struct ini_component
		{
			// the name of the component
			std::string name;
		} component;

		struct ini_eventServer
		{
			std::string serviceName;
		} eventServer;

		struct ini_paramServer
		{
			std::string serviceName;
		} paramServer;

		struct ini_posePushTimedServer
		{
			std::string serviceName;
			double cycle;
		} posePushTimedServer;

		struct ini_requestScan3dSendServer
		{
			std::string serviceName;
		} requestScan3dSendServer;

		struct ini_scan3dEventServer
		{
			std::string serviceName;
		} scan3dEventServer;

		struct ini_scan3dQueryServer
		{
			std::string serviceName;
		} scan3dQueryServer;

		struct ini_stateServer
		{
			std::string serviceName;
		} stateServer;

		struct ini_trajectorySendServer
		{
			std::string serviceName;
		} trajectorySendServer;

		struct ini_basePushTimedClient
		{
			std::string serverName;
			std::string serviceName;
			long interval;
		} basePushTimedClient;

		struct ini_laserQueryClient
		{
			std::string serverName;
			std::string serviceName;
		} laserQueryClient;

		struct ini_base
		{

			/**
			 * the orientation of the base [rad]
			 */
			double base_a;

			/**
			 * specify if manipulator is mounted on a base.
			 * if false the values below are used.
			 */
			bool on_base;

			/**
			 * the steering angle of the base [rad]
			 */
			double steer_a;

			/**
			 * the angle of the turret on the base [rad]
			 */
			double turret_a;

			/**
			 * the x world coordinate [mm]
			 */
			long x;

			/**
			 * the y world coordinate [mm]
			 */
			long y;

			/**
			 * the z world coordinate [mm]
			 */
			long z;
		} base;

		struct ini_katana
		{

			/**
			 * the azimuth angle of the katana relative to the robot [rad]
			 */
			double azimuth;

			/**
			 * the elevation angle of the katana relative to the robot [rad]
			 */
			double elevation;

			/**
			 * the component checks if the katana is already calibrated
			 * by moving the first joint
			 */
			bool fast_calibration;

			/**
			 * the goal is reached when the difference between the
			 * goal and current tcp angles are smaller then this value [rad]
			 */
			double goal_angle_approach;

			/**
			 * the goal is reached when the difference between the
			 * goal and current tcp positions are smaller then this value [mm]
			 */
			double goal_position_approach;

			/**
			 * If the angle of the gripper is bigger than this value the GOAL_REACHED_GRIPPER_EMPTY event is send. Value in [rad]
			 */
			double gripper_empty_angle;

			/**
			 * Timeout for open or close gripper action [ms]
			 */
			unsigned long gripper_timeout;

			/**
			 * the path to the katana config file
			 */
			std::string katana_config_file;

			/**
			 * Serial = katana is connected over the serial port
			 * Lan = katana is connected over the network
			 */
			std::string katana_device;

			/**
			 * the roll angle of the katana relative to the robot [rad]
			 */
			double roll;

			/**
			 * activate/deactivate info messages
			 */
			bool verbose;

			/**
			 * the x offset of the katana relative to the robot [mm]
			 */
			long x;

			/**
			 * the y offset of the katana relative to the robot [mm]
			 */
			long y;

			/**
			 * the z offset of the katana relative to the robot [mm]
			 */
			long z;
		} katana;

		struct ini_laser
		{

			/**
			 * the azimuth angle relative to the tcp [rad]
			 */
			double azimuth;

			/**
			 * the elevation angle relative to the tcp [rad]
			 */
			double elevation;

			/**
			 * true if a laser ranger is mounted on the katana
			 */
			bool laser_is_mounted;

			/**
			 * the roll angle relative to the tcp [rad]
			 */
			double roll;

			/**
			 * the x offset of the laser relative to the tcp [mm]
			 */
			long x;

			/**
			 * the y offset of the laser relative to the tcp [mm]
			 */
			long y;

			/**
			 * the z offset of the laser relative to the tcp [mm]
			 */
			long z;
		} laser;

		struct ini_network
		{

			/**
			 * the ip address where the katana is connected
			 */
			std::string ip_address;

			/**
			 * the port where the katana is connected
			 */
			unsigned long port;
		} network;

		struct ini_serial_port
		{

			/**
			 * the serial device where the katana is connected
			 */
			std::string device;
		} serial_port;
	} ini;

};
#endif
