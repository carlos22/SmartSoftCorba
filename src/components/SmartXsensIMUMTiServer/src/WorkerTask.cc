//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//  Copyright (C) 2009 Christian Schlegel, Florian Poppa
//
//        schlegel@hs-ulm.de
//        poppa@hs-ulm.de
//
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------


#include "WorkerTask.hh"
#include "gen/SmartXsensIMUMTiServer.hh"


WorkerTask::WorkerTask()
{
	std::cout << "constructor WorkerTask\n";
}

int WorkerTask::svc()
{
	  //
	  // initialize and connect to Xsens IMU
	  //

	  // use CMT Level 3 (Device Interface)
	  xsens::Cmt3 cmt3;

	  // connect to the Xsens IMU and retrieve the sample frequency
	  short sampleFreq = initAndConnectToXsensIMU(cmt3);

	  // initAndConnectToXsensIMU returns INVALID_SAMPLE_FREQ if sth. failed
	  if (sampleFreq == INVALID_SAMPLE_FREQ)
	  {
	    std::cerr << "ERROR: Error during initialization or connect." << std::endl;
	    std::cerr << "sampleFreq == INVALID_SAMPLEFREY: " << sampleFreq << "==" << INVALID_SAMPLE_FREQ << std::endl;

	    cmt3.closePort();
	    die();
	  }

	  std::cout << "==> PRESS <STRG>+<C> TO QUIT" << std::endl << std::endl;

	  if (!COMP->getUserQuit())
	  {
	    // sampleFreq must be IMU_SAMPLE_RATE for correct operation of this SmartSoft component
	    if (sampleFreq != IMU_SAMPLE_RATE)
	    {
	      std::cerr << "ERROR: Sample frequency " << sampleFreq << "Hz != " << IMU_SAMPLE_RATE << "Hz. A sample frequency of " << IMU_SAMPLE_RATE << "Hz is required by this SmartSoft component." << std::endl;

	      cmt3.closePort();
	      die();
	    }
	    else
	    {
	      //
	      // variables
	      //

	      // check status code of all Xsens SDK functions
	      XsensResultValue result = XRV_OK;

	      // structs to hold Xsens IMU motion data
	      CmtCalData caldata;
	      CmtEuler eulerdata;

	      // Initialize packet for data
	      xsens::Packet* packet = new xsens::Packet(1, cmt3.isXm());

	      // the communication object
	      CommBasicObjects::CommIMUData commIMUData;


	      //
	      // start doing something useful ...
	      //
	      while (!COMP->getUserQuit() && result == XRV_OK)
	      {
	        // receive data
	        cmt3.waitForDataMessage(packet);

	        // get motion data
	        caldata = packet->getCalData(0);
	        eulerdata = packet->getOriEuler(0);

	        // fill smartsoft communication object
	        // -- timestamp
	        commIMUData.set_timestamp(packet->getSampleCounter());
	        // -- temperature
	        commIMUData.set_temperature(packet->getTemp(0));

	        // -- accelerometer values
	        commIMUData.set_accelerometer_values(
	          caldata.m_acc.m_data[0],
	          caldata.m_acc.m_data[1],
	          caldata.m_acc.m_data[2]
	        );

	        // -- gyroscope values
	        commIMUData.set_gyroscope_values(
	          caldata.m_gyr.m_data[0],
	          caldata.m_gyr.m_data[1],
	          caldata.m_gyr.m_data[2]
	        );

	        // -- magnetometer values
	        commIMUData.set_magnetometer_values(
	          caldata.m_mag.m_data[0],
	          caldata.m_mag.m_data[1],
	          caldata.m_mag.m_data[2]
	        );

	        // -- euler angles
	        commIMUData.set_euler_angles(
	          eulerdata.m_roll,
	          eulerdata.m_pitch,
	          eulerdata.m_yaw
	        );

	        //pushTimedHandler.setIMUData(commIMUData);
	    	COMP->imuDataMutex.acquire();
	    	COMP->imuData = commIMUData;
	    	COMP->imuDataMutex.release();

	        if (COMP->ini.xsens.verbose)
	          cout << commIMUData << std::endl;
	      }

	      // clean up and shut down
	      delete packet;
	      cmt3.closePort();

	      die();
	    }
	  }

	  // that's it
	  std::cout << "Closing smartXsensIMUMTiWorkTask." << std::endl;

	  return 0;
}


//--------------------------------------------------------------------------
// general methods
//--------------------------------------------------------------------------


/**
 * Method to call when it is all done. Does a bit of clean-up.
 */
void WorkerTask::die(void)
{
  // notify other task
  COMP->setUserQuit(true);

}



//--------------------------------------------------------------------------
// xsens stuff
//--------------------------------------------------------------------------

/**
 * Check for errors while using Xsens SDK
 */
inline bool WorkerTask::checkXsensResultCode(int resultCode, const char* errorMessage)
{
  if (resultCode != XRV_OK)
  {
    std::cerr << "ERROR: Xsens SDK Error (code: " << resultCode << ", message: " << errorMessage << ")." << std::endl;

    // clean up and exit
    die();

    return false;
  }

  return true;
}

/**
 * This method does the Xsens IMU initialization procedure and connects to the IMU
 * (This method is based on the Xsens CMT Linux Example Src)
 */
unsigned int WorkerTask::initAndConnectToXsensIMU(xsens::Cmt3 &cmt3)
{
  // used for CMT Level 3 Device ID based adressing
  CmtDeviceId deviceId;
  // check status code of all Xsens SDK functions
  XsensResultValue result = XRV_OK;

  // check if a COM port has been specified
  // -- this should never happen, if nobody removed the default values  --
  if (COMP->ini.xsens.port.length() == 0)
  {
    std::cerr << "ERROR: no COM port specified." << std::endl << std::endl;
    die();

    return INVALID_SAMPLE_FREQ;
  }

  // convert .ini file parameter from std::string to char*
  const char* xsensCOMPort = COMP->ini.xsens.port.c_str();

  CmtOutputMode mode =  CMT_OUTPUTMODE_TEMP   | // get temperature
                        CMT_OUTPUTMODE_CALIB  | // Calibrated data output mode
                        CMT_OUTPUTMODE_ORIENT;  // get orientation

  CmtOutputSettings settings =  CMT_OUTPUTSETTINGS_ORIENTMODE_EULER |   // get euler angles
                                CMT_OUTPUTSETTINGS_TIMESTAMP_SAMPLECNT; // get sample counter

  // check if the IMU is available on the specified COM port
  CmtPortInfo portInfo;
  strcpy(portInfo.m_portName, xsensCOMPort);

  std::cout << "Scanning for Xsens device on COM port " << xsensCOMPort << "." << std::endl;

  if (xsens::cmtScanPort(portInfo))
  {
    std::cout << "done." << std::endl << std::endl;
  }
  else
  {
    std::cerr << std::endl << "ERROR while connecting to Xsens device on " << xsensCOMPort << "." << std::endl;
    die();

    return INVALID_SAMPLE_FREQ;
  }

  char baud[10];

  switch (portInfo.m_baudrate)
  {
    case B9600    : strcpy(baud, STRING_B9600);   break;
    case B19200   : strcpy(baud, STRING_B19200);  break;
    case B38400   : strcpy(baud, STRING_B38400);  break;
    case B57600   : strcpy(baud, STRING_B57600);  break;
    case B115200  : strcpy(baud, STRING_B115200); break;
    case B230400  : strcpy(baud, STRING_B230400); break;
    case B460800  : strcpy(baud, STRING_B460800); break;
    case B921600  : strcpy(baud, STRING_B921600); break;

    default:
      std::cerr << "ERROR: No valid baud rate setting " << std::hex << portInfo.m_baudrate << "." << std::endl;

      // clean up and shut down
      die();

      return INVALID_SAMPLE_FREQ;
  }

  // open port
  std::cout << "Opening port " << portInfo.m_portName << " (baud rate " << baud << ") ... " << std::endl;
  result = cmt3.openPort(portInfo.m_portName, portInfo.m_baudrate);
  if (!checkXsensResultCode(result, "cmtOpenPort")) return INVALID_SAMPLE_FREQ;
  std::cout << "done." << std::endl << std::endl;

  if (cmt3.getMtCount() == 0)
  {
    std::cerr << "ERROR: No Xsens hardware found." << std::endl;

    // clean up and shut down
    cmt3.closePort();
    die();

    return INVALID_SAMPLE_FREQ;
  }

  // retrieve the device ID of the IMU
  std::cout << "Retrieving MotionTrackers device ID: " << std::endl;
  result = cmt3.getDeviceId(1, deviceId);
  if (!checkXsensResultCode(result, "getDeviceId")) return INVALID_SAMPLE_FREQ;
  std::cout << "Device ID at busId " << 1 << ": " << (long) deviceId << std::endl << std::endl;

  // set sensor to config sate
  result = cmt3.gotoConfig();
  if (!checkXsensResultCode(result, "gotoConfig")) return INVALID_SAMPLE_FREQ;

  unsigned short sampleFreq;
  sampleFreq = cmt3.getSampleFrequency();
  std::cout << "SampleFrequency: " << sampleFreq << " Hz" << std::endl << std::endl;

  // set the device output mode for the device
  CmtDeviceMode deviceMode(mode, settings, sampleFreq);

  if ((deviceId & 0xFFF00000) != 0x00500000)
  {
    // not an MTi-G, remove all GPS related stuff
    deviceMode.m_outputMode &= 0xFF0F;
  }

  result = cmt3.setDeviceMode(deviceMode, true, deviceId);
  if (!checkXsensResultCode(result, "setDeviceMode")) return INVALID_SAMPLE_FREQ;

  // start receiving data
  result = cmt3.gotoMeasurement();
  if (!checkXsensResultCode(result, "gotoMeasurement")) return INVALID_SAMPLE_FREQ;

  return sampleFreq;
}




