//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//
//  Copyright (C) 2003 Boris Kluge
//                2009 Andreas Steck
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

#include "LaserTask.hh"
#include "gen/SmartLaserLMS200Server.hh"

#include <CommBasicObjects/commPose3d.hh>

#include <iostream>

LaserTask::LaserTask()
{
	std::cout << "constructor LaserTask\n";
}

int LaserTask::svc()
{
	CommBasicObjects::CommMobileLaserScan scan;
	CommBasicObjects::CommBaseState base_state;
	  unsigned long update_count = 0;
	  unsigned long long start = 0, stop = 0;
	  timeval ts;

	  CHS::StatusCode status;

	  CommBasicObjects::CommBaseVelocity zero_velocity;
	  zero_velocity.set_v(0);
	  zero_velocity.set_omega_base(0);
	  zero_velocity.set_omega_steer(0);
	  zero_velocity.set_omega_turret(0);

	  Smart::SickInterface laser;

	  while(!init_laser(laser))
	  {
	    std::cerr << "WARNING: failed to init laser, retry in one second" << std::endl;
	    sleep(1);
	  }

	  while(1) //! CHS::SmartThreadManager::instance()->testcancel(ACE_Thread::self()))
	  {
	    if (laser.read_laser_data()==0)
	    {
	      bool base_state_valid = false;

	      scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp(laser.get_receive_timestamp()));
	      scan.set_scan_update_count(update_count);

	      //////////////////////////
	      // set base state
	      //
	      if(COMP->ini.base.subscribe == true)
	      {
	        CHS::StatusCode status = COMP->baseClient->getUpdate(base_state);  //base->getUpdate(base_state);
	        if(status!=CHS::SMART_OK)
	        {
	          std::cerr << "WARNING: failed to get current base state (" << CHS::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
	          scan.set_scan_valid(false);
	        }
	        else base_state_valid = true;
	      }
	      else
	      {
	        base_state.set_time_stamp(CommBasicObjects::CommTimeStamp(laser.get_receive_timestamp()));
	        CommBasicObjects::CommBasePosition default_base_position;
	        default_base_position.set_x(COMP->ini.base.x);
	        default_base_position.set_y(COMP->ini.base.y);
	        default_base_position.set_z(COMP->ini.base.z);
	        default_base_position.set_base_alpha(COMP->ini.base.base_a);
	        default_base_position.set_steer_alpha(COMP->ini.base.steer_a);
	        default_base_position.set_turret_alpha(COMP->ini.base.turret_a);
	        base_state.set_base_position(default_base_position);
	        base_state.set_base_velocity(zero_velocity);
	        base_state_valid = true;
	      }
	      scan.set_base_state(base_state);

	      //////////////////////////
	      // set scanner position
	      //
	      double base_x = 0;
	      double base_y = 0;
	      double base_z = 0;
	      double base_a = 0;
	      if(base_state_valid)
	      {
	        base_x = base_state.get_base_position().get_x();
	        base_y = base_state.get_base_position().get_y();
	        base_z = base_state.get_base_position().get_z();
	        if(COMP->ini.laser.on_turret)
	        {
	          base_a = base_state.get_base_position().get_turret_alpha();
	        }
	        else
	        {
	          base_a = base_state.get_base_position().get_base_alpha();
	        }
	      }
	      const double sin_base_a = sin(base_a);
	      const double cos_base_a = cos(base_a);
	      scan.set_scanner_x(base_x + COMP->ini.laser.x * cos_base_a - COMP->ini.laser.y * sin_base_a);
	      scan.set_scanner_y(base_y + COMP->ini.laser.x * sin_base_a + COMP->ini.laser.y * cos_base_a);
	      scan.set_scanner_z(base_z + COMP->ini.laser.z);
	      scan.set_scanner_azimuth(base_a + COMP->ini.laser.azimuth);

	      CommBasicObjects::CommPose3d SensorOffset(COMP->ini.laser.x, COMP->ini.laser.y, COMP->ini.laser.z, COMP->ini.laser.azimuth, 0, 0);
	      scan.set_sensor_pose(SensorOffset);

	      //////////////////////////
	      // set scan parameters
	      //
	      scan.set_scan_length_unit(laser.extract_length_unit());
	      scan.set_scan_integer_field_of_view(-50 * int(laser.width), laser.resolution);

	      //////////////////////////
	      // get maximum non-overflow distance
	      //
	      const unsigned int max_dist = laser.get_max_distance();

	      //////////////////////////
	      // set scan points
	      //
	      const unsigned int num_points = laser.extract_num_points();
	      unsigned int num_valid_points = 0;
	      for(unsigned int i=0; i<num_points; ++i)
	      {
	        if(laser.extract_distance(i) <= max_dist) ++num_valid_points;
	      }
	      scan.set_scan_size(num_valid_points);
	      unsigned int valid_point_index = 0;
	      for(unsigned int i=0; i<num_points; ++i)
	      {
	        const unsigned int dist = laser.extract_distance(i);
	        if(dist <= max_dist)
	        {
	          scan.set_scan_index(valid_point_index, i);
	          scan.set_scan_integer_distance(valid_point_index, dist);
	          scan.set_scan_intensity(valid_point_index, laser.extract_intensity(i));
	          ++valid_point_index;
	        }
	      }
	      scan.set_scan_valid(base_state_valid /* && ... */);

	      CHS::StatusCode push_status = COMP->laserServer->put(scan);
	      if(push_status!=CHS::SMART_OK)
	      {
	        std::cerr << "WARNING: error on push (" << CHS::StatusCodeConversion(push_status) << ")" << std::endl;
	      }

	      COMP->ScanLock.acquire();
	      COMP->global_scan = scan;
	      COMP->ScanLock.release();

	      /*
	            const unsigned int index = 180;
	            if(_verbose) std::cout << "Scan " << update_count << " sent." << " Scan Position " << index << " = " << scan.get_scan_distance(index) << " mm"<< std::endl;
	      */

	      const unsigned int num_scans_freq = 200;
	      if(update_count== 0)
	      {

	          ts = laser.get_receive_timestamp();
	          start = ts.tv_sec * 1000000 + ts.tv_usec;
	          std::cout << "\n\nlaser is ready. measure frequency (first "<< num_scans_freq << " scans)...\n";
	      }
	      else if(update_count == num_scans_freq)
	      {
	    	  ts = laser.get_receive_timestamp();
	    	  stop = ts.tv_sec * 1000000 + ts.tv_usec;
	    	  std::cout << "...frequency is " << (double)num_scans_freq / (double)(stop-start) * 1000000.0 << " Hz.\n";
	      }
	      ++update_count;
	    }
	    else
	    {
	      std::cerr << "WARNING: received unexpected packet type" << std::endl;
	    }
	  }

	  laser.close_device();

	  if(COMP->ini.base.subscribe)
	  {
	    status = COMP->baseClient->unsubscribe();
	    if(status!=CHS::SMART_OK)
	    {
	      std::cerr << "WARNING: failed to unsubscribe from base state service \"" << COMP->ini.laserServer.serviceName << "\"" << std::endl;
	      std::cerr << "WARNING: (" << CHS::StatusCodeConversion(status) << ")" << std::endl;
	    }
	  }

	  return 0;
}


bool LaserTask::init_laser(Smart::SickInterface &laser) const
{
  // set up laser connection
  laser.verbose = COMP->ini.laser.verbose;
  laser.length_unit = COMP->ini.laser.length_unit;

  laser.resolution = COMP->ini.laser.resolution;
  if(laser.resolution==25)
  {
    laser.width = 100;
  }
  else
  {
    laser.width = 180;
  }

  laser.bitrate = COMP->ini.laser.baudrate;
  laser.term_bitrate = COMP->ini.laser.baudrate;

  if(COMP->ini.laser.sick_type == "LMS")
  {
    laser.sick_type = Smart::SickInterface::LMS;
  }
  else if(COMP->ini.laser.sick_type=="PLS")
  {
    laser.sick_type = Smart::SickInterface::PLS;
  }
  else
  {
    std::cerr << "WARNING: unknown SICK type \"" << COMP->ini.laser.sick_type << "\", using default (\"LMS\")." << std::endl;
    laser.sick_type = Smart::SickInterface::LMS;
  }

  if(laser.open_device(COMP->ini.laser.device.c_str()))
  {
    std::cerr << "ERROR: laser.open_device(\"" << COMP->ini.laser.device << "\") failed." << std::endl;
    return false;
  }
  unsigned int current_laser_speed = 0;
  std::string laser_type;
  if(laser.probe_sick_speed(current_laser_speed, laser_type))
  {
    std::cerr << "ERROR: probe_laser_speed() failed." << std::endl;
    return false;
  }
  if(COMP->ini.laser.verbose)
  {
    std::cout << "Connected to \"" << laser_type << "\", initially at " << current_laser_speed << "bps" << std::endl;
  }
  if(laser.set_laser_config())
  {
    std::cerr << "ERROR: set_laser_config() failed." << std::endl;
    return false;
  }
  for(unsigned int retry = 0; true; ++retry)
  {
    if(laser.request_laser_data()==0) break;
    if (retry >= 5)
    {
      std::cerr << "ERROR: request_laser_data() failed." << std::endl;
      return false;
    }
  }
  if(COMP->ini.laser.verbose)
  {
    std::cout << "Laser ready." << std::endl;
  }
  return true;
}
