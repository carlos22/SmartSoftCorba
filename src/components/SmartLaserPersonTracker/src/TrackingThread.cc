//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.2
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2009-2010 Andreas Steck, Matthias Lutz
//
//        lutz@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "TrackingThread.hh"
#include "gen/SmartLaserPersonTracker.hh"

#include "CommBasicObjects/commNavigationVelocity.hh"

#include <iostream>

TrackingThread::TrackingThread()
{
	std::cout << "constructor TrackingThread\n";
}

int TrackingThread::svc()
{

	 try {

	  CommBasicObjects::CommMobileLaserScan scan;
	  CommBasicObjects::CommNavigationVelocity vel;
	  CHS::StatusCode status;

	  std::vector<segment> segments;
	  std::vector<segment> legs;
	  std::vector<segment> persons;
	  std::vector<segment> objects;

	  segment seg, seg1, seg2;
	  CommTrackingObjects::CommLaserTrackingData trackingData;

	  // TODO
	  double person_x = 1000.0;
	  double person_y = 0.0;

	  bool personFound = false;
	  int noPersonCount = 0;
	  int personIndex = 0;


	  //   MRPT EKF
	  mrpt::random::Randomize();

	  CDisplayWindowPlots             winEKF("Tracking - Extended Kalman Filter",450,400);


	  winEKF.setPos(10,10);

	  winEKF.axis(-2,20,-10,10); winEKF.axis_equal();

	  // Create EKF
	  // ----------------------
	  //CRangeBearing   EKF; // global now
	  //EKF.KF_options.verbose = false; --> main
	  //     EKF.KF_options.method = kfEKFNaive;
	  //EKF.KF_options.method = kfEKFAlaDavison; --> main
	  //      EKF.KF_options.method = kfIKFFull;
	  //      EKF.KF_options.IKF_iterations = 5;

	  CVectorTemplate<KFTYPE>                 EKF_xkk;
	  CMatrixTemplateNumeric<KFTYPE>  EKF_pkk;

	  // Init. simulation:
	  // -------------------------
	  //float x=VEHICLE_INITIAL_X,y=VEHICLE_INITIAL_Y,phi=DEG2RAD(-180),v=VEHICLE_INITIAL_VX,w=VEHICLE_INITIAL_VY;
	  //float  t=0;

	  unsigned long long oldTime = 0;
	  unsigned long long newTime = 0;
	  unsigned long long deltaTime = 0;
	  unsigned long long accumulatedDeltaTime = 0;
	  timeval ts;


	  std::vector<double> meanPerson;
	  std::vector<double> meanLeg;
	  std::vector<double> meanLegDist;
	  std::vector<double> featuresSeg;
	  std::vector<double> featureLegDist;
	  std::vector<double> meanUpperBody;

	  CMatrixTemplateNumeric<double> covPerson;
	  //covPerson.setSize(3,3);
	  covPerson.setSize(2,2);

	  CMatrixTemplateNumeric<double> covLeg;
	  //covLeg.setSize(3,3);
	  covLeg.setSize(2,2);

	  CMatrixTemplateNumeric<double> covUpperBody;
	  covUpperBody.setSize(2,2);

	  CMatrixTemplateNumeric<double> covLegDist;
	  covLegDist.setSize(1,1);


	  meanPerson.push_back(227.4133);
	  meanPerson.push_back(-40.1389);

	  meanLeg.push_back(136.8020);
	  meanLeg.push_back(-32.6803);

	  meanLegDist.push_back(278.0805);

	  meanUpperBody.push_back(464.2478);
	  meanUpperBody.push_back(-66.4167);

	  covPerson(0,0) = 9456.9;
	  covPerson(0,1) = -175.7;
	  covPerson(1,0) = -175.7;
	  covPerson(1,1) = 1108.1;
	  covPerson = covPerson.inv();

	  covLeg(0,0)    = 939.2642;
	  covLeg(0,1)    = -56.6714;
	  covLeg(1,0)    = -56.6714;
	  covLeg(1,1)    = 825.9608;
	  covLeg = covLeg.inv();

	  covUpperBody(0,0)    = 11521.1852;
	  covUpperBody(0,1)    = 756.1377;
	  covUpperBody(1,0)    = 756.1377;
	  covUpperBody(1,1)    = 1105.4441;
	  covUpperBody = covUpperBody.inv();


	  covLegDist(0,0) = 2991.8;
	  covLegDist = covLegDist.inv();

	 // unsigned int counter = 0;

	  //while(winEKF.isOpen()) //while(1)
	  while(1)
	  {
	   status = COMP->stateServer->acquire("follow");
	   if (status == CHS::SMART_OK)
	   {

	    legs.clear();
	    persons.clear();
	    segments.clear();
	    objects.clear();
	    double mahal;

	    // wait for scan (PushNewest)
	    status = COMP->laserClient->getUpdateWait(scan);
	    if (status != CHS::SMART_OK) {
	      std::cout << "blocking wait  status " << CHS::StatusCodeConversion(status) << " not ok => retry ..." << std::endl;
	    }
	    else
	    {
	      int count = scan.get_scan_size();
	      std::cout << "scan_size = " << count << std::endl;

	      //////////////
	      // get segments out of laserscan
	      getSegments(scan, segments);

	      std::cout << "segments_size = " << segments.size() << std::endl;

		


	/*
	      ////////////////////////////////////////////////////////////////////////////
	      // visualisation
	      count = segments.size();
	      //std::cout << "segments send       : count = " << count << std::endl;

	      trackingData.set_laser_scan(scan);
	      trackingData.set_num_objects(count);
	      for(int i=0; i<count; ++i)
	      {
	        trackingData.set_object_first_point(i, segments[i].begin);
	        trackingData.set_object_last_point(i, segments[i].end);
	        trackingData.set_object_id(i, i);
	      }

	      // push trackingData
	      status = trackingDataServer->put(trackingData);
	      if(status!=CHS::SMART_OK)
	      {
	        std::cerr << "WARNING: error on push (" << CHS::StatusCodeConversion(status) << ")" << std::endl;
	      }
	*/

	      /////////////////
	      // roboCup hack: delete segments within range between robot and person
	      COMP->EKF->getState( EKF_xkk, EKF_pkk );
	      count = segments.size();
	      unsigned int distToPerson = sqrt( (scan.get_base_state().get_base_raw_position().get_x() - EKF_xkk[0]*1000.0) * (scan.get_base_state().get_base_raw_position().get_x() - EKF_xkk[0]*1000.0)
	        + (scan.get_base_state().get_base_raw_position().get_y() - EKF_xkk[1]*1000) * (scan.get_base_state().get_base_raw_position().get_y() - EKF_xkk[1]*1000) );
	      for(int i=0; i<segments.size(); ++i)
	      {
	         seg = segments[i];
	         int middle = (seg.end + seg.begin) / 2;
	         //if( middle >= 100 && middle <= 260 && scan.get_scan_distance(middle) <= 0.85*distToPerson )
	         if( scan.get_scan_distance(middle) <= 0.7*distToPerson )
	         {
	           // delete
	           segments.erase(segments.begin() + i);
	           i--;
	         }
	      }


	      //////////////
	      // put segments larger than xx (50) and smaller than yy (1200) in objects
	      count = segments.size();
	      std::cout << "segments from scan       : count = " << count << std::endl;
	      for(int i=0; i<count; ++i)
	      {
	        seg = segments[i];

	        if(checkLeg(scan,seg, 50, 1200)==true)
	        {
	          objects.push_back(seg);
	        }

	      }


	      /////////////////
	      // remove outliers from remaining objects
	      count = objects.size();
	      cout << "\nobjects count: " << count << endl;
	      for(int i=0; i<count; i++)
	      {
	        seg = objects[i];

	        // remove outliers if enough points
	        if(seg.end-seg.begin >= 10)
	        {
	          seg.begin++;
	          seg.end--;
	        }
	        if(seg.end-seg.begin >= 25)
	        {
	          seg.begin++;
	          seg.end--;
	        }

	        objects[i] = seg;

	      }


	      ////////////////////
	      // classify objects into
	      //  --> either single legs
	      //  --> or persons (person as one segment - NOT persons consisting out of 2 legs !!!)
	      count = objects.size();
	      //cout << "\ncount: " << count << endl;
	      for(int i=0; i<count; i++)
	      {
	        seg = objects[i];

	        double diameter      = getDiameter(scan, seg);
	        double meanSurfCurv  = getMeanSurfCurv(scan, seg);
	        featuresSeg.clear();
	        featuresSeg.push_back(diameter);
	        featuresSeg.push_back(meanSurfCurv);

	        // classify legs
	        mahal = mahalanobisDistance(featuresSeg, meanLeg, covLeg);
	        if(mahal < 1.5)
	        {
	          //cout << "leg detected\n";
	          legs.push_back(seg);
	        }
	        else
	        {
	          // classify persons
	          mahal = mahalanobisDistance(featuresSeg, meanPerson, covPerson);
	          if(mahal < 1.5)
	          {
	            //cout << "person detected\n";
	            persons.push_back(seg);
	          }
	        }

	      }


	     ////////////////////////////////////////////////////////////////////////////
	     // note: persons as single segment are alredy inserted!
	     // add persons consisting out of exactly 2 legs
	     count = legs.size();
	     double seg1_mx, seg1_my, seg2_mx, seg2_my, dist, min;
	     int index;

	     min = std::numeric_limits<double>::infinity();
	     while( legs.size() > 1 )
	     {
	        seg1 = legs[0];
	        index = -1;

	        for( unsigned int k=1; k<legs.size(); ++k)
	        {
	          seg2 = legs[k];

	          scan.get_scan_cartesian_point_scanner( int((seg1.begin+seg1.end)/2), seg1_mx, seg1_my);
	          scan.get_scan_cartesian_point_scanner( int((seg2.begin+seg2.end)/2), seg2_mx, seg2_my);
	          dist = sqrt( (seg1_mx-seg2_mx)*(seg1_mx-seg2_mx) + (seg1_my-seg2_my)*(seg1_my-seg2_my) );
	          featuresSeg.clear();
	          featuresSeg.push_back(dist);

	          mahal = mahalanobisDistance(featuresSeg, meanLegDist, covLegDist);

	          if(mahal < min && mahal < 1.5)
	          {
	            min = mahal;
	            index = k;
	          }

	        }

	        // second leg found matching the first
	        if(index != -1)
	        {
	          segment seg;
	          seg2 = legs[index];
	          seg.begin = seg1.begin;
	          seg.end = seg2.end;
	          persons.push_back(seg);
	          legs.erase (legs.begin()+index); // delete this first!
	          legs.erase (legs.begin());
	          //cout << "person added 2 legs - mahal: " << mahal << endl;
	        }
	        // otherwise add single leg (as person)
	        else
	        {
	          persons.push_back(seg1);
	          legs.erase (legs.begin());
	          //cout << "person added 1 leg: " << mahal << endl;
	        }
	      } // while

	      // now in the list of legs is either no or one leg remaining
	      // in case of one -> add into person list
	      if(legs.size() == 1)
	      {
	        seg1 = legs[0];
	        persons.push_back(seg1);
	        //cout << "person added - i==count-1: " << seg1.begin << "; " << seg1.end << endl;
	      }
	     ////////////////////////////////////////////////////////////////////////////




	      count = persons.size();
	      cout << "--> persons: " << count << endl;

	      ////////////////////////////////////////////////////////////////////////////
	      // visualisation
	      count = persons.size();
	      //std::cout << "segments send       : count = " << count << std::endl;

	      trackingData.set_laser_scan(scan);
	      trackingData.set_num_objects(count);
	      for(int i=0; i<count; ++i)
	      {
	        trackingData.set_object_first_point(i, persons[i].begin);
	        trackingData.set_object_last_point(i, persons[i].end);
	        trackingData.set_object_id(i, i);
	      }

	      // push trackingData
	      status = COMP->trackingDataServer->put(trackingData);
	      if(status!=CHS::SMART_OK)
	      {
	        std::cerr << "WARNING: error on push (" << CHS::StatusCodeConversion(status) << ")" << std::endl;
	      }



	      COMP->EKF->getState( EKF_xkk, EKF_pkk );

	///////////////
	// DEBUG OUTPUT:
	// write EKF state and robot pose to file
	//////////////
	/*
	if(counter>10){
		string sFileExtension = ".mat";
		stringstream sFileName;
		stringstream sFileName2;
		sFileName << "estimatedPersonPos";
	//	sFileName << setfill('0') << setw(AppParams.iTimeStepDigits) << iTimestep << sFileExtension;

		double raw_x = scan.get_base_state().get_base_raw_position().get_x(1);
	        double raw_y = scan.get_base_state().get_base_raw_position().get_y(1);
	        double raw_alpha = scan.get_base_state().get_base_raw_position().get_base_alpha();

		double base_x = scan.get_base_state().get_base_position().get_x(1);
	        double base_y = scan.get_base_state().get_base_position().get_y(1);
	        double base_alpha = scan.get_base_state().get_base_position().get_base_alpha();


		double delta_x = EKF_xkk[0]-raw_x;
	        double delta_y = EKF_xkk[1]-raw_y;
		double delta_alpha = scan.get_base_state().get_base_position().get_base_alpha()-raw_alpha;

		//construct diff vector between robot raw pose and tracked person
		CVectorTemplate<KFTYPE>diff_vector;
	        diff_vector.push_back(delta_x);
	        diff_vector.push_back(delta_y);
	        diff_vector.push_back(1);

		//construct transformation matrix
	  	//this matrix rotates the diff vector into the direction of the corrected robot pose coordinate system
		//the rotation angel is the difference between the two coordinate systems
	        CMatrixTemplateNumeric<KFTYPE>trans;
	        trans.resize(3,3);
	        trans(0,0) = cos(delta_alpha);
	        trans(1,0) = -1.0 * sin(delta_alpha);
	        trans(2,0) = 0;

	        trans(1,0) = sin(delta_alpha);
	        trans(1,1) = cos(delta_alpha);
	        trans(1,2) = 0;

	        trans(2,0) = 0;
	        trans(2,1) = 0;
	        trans(2,2) = 1;

	        CMatrixTemplateNumeric<KFTYPE>tmp2;

		//do the rotation
	        tmp2 = (trans*diff_vector);

		//move the rotated diff to the corrected coordinate system
		tmp2(0,0)=tmp2(0,0)+base_x;
		tmp2(1,0)=tmp2(1,0)+base_y;


	//	cout<<"Robot pose raw_x: "<<raw_x<<"y: "<<raw_y<<"alpha: "<<raw_alpha<<endl;
	//	cout<<"Robot pose corected x: "<<base_x<<"y: "<<base_y<<" alpha: "<<base_alpha<<endl;
	//	cout<<"Person point uncorrected: "<<EKF_xkk[0]<<"; "<<EKF_xkk[1]<<endl;
	//	cout<<"Person point corrected: "<<tmp2<<endl;


		ofstream fileStream((sFileName.str()).c_str(), ios::app);	// open file for output
		if(fileStream) // file could be opened
		{
			fileStream<<scientific<<setprecision(7);
			fileStream <<setw(16)<<tmp2(0,0) <<";";
			fileStream <<setw(16)<<tmp2(1,0) <<endl;
		}
		fileStream.close();	// close the File





	        sFileName2 << "estimatedVehiclePose";

	        ofstream fileStream_1((sFileName2.str()).c_str(), ios::app);     // open file for output
	        if(fileStream) // file could be opened
	        {
	                fileStream_1<<scientific<<setprecision(7);
	                fileStream_1 <<setw(16)<<scan.get_base_state().get_base_position().get_x(1)<<";";
	                fileStream_1<<setw(16)<<scan.get_base_state().get_base_position().get_y(1)<<";";
	          	fileStream_1<<setw(16)<<scan.get_base_state().get_base_position().get_base_alpha()<<endl;

	        }
	        fileStream_1.close();     // close the File

	counter = 0;
	}
	counter ++;
	// END
	//////////////
	*/



	      //cout<<"EKF_xkk: "<<EKF_xkk<<endl;
	      personFound = false;

	      ///////////////
	      // check for person which fits best to estimate
	      if( persons.size() >= 1 )
	      {
	        segment seg;
	        double min = std::numeric_limits<double>::infinity();
	        double tmp = 0;
	        CMatrixTemplateNumeric<double> p_2x2;
	        p_2x2.setSize(2,2);
	        EKF_pkk.extractMatrix(0,0,2,2,p_2x2);
	        p_2x2 = p_2x2.inv();

		for(unsigned int i=0; i<persons.size(); ++i)
	        {
	          seg = persons[i];

	          double x1, x2, y1, y2, sx, sy, x, y;//, dist;

	          //scan.get_scan_cartesian_point_world( seg.begin, x1, y1);
	          //scan.get_scan_cartesian_point_world( seg.end, x2, y2);

	////////////////////////////////////////////////////////////////////////////////////////
	          // calculate x and y in raw-position world coordinates !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	          scan.get_scan_cartesian_point_scanner( seg.begin, x1, y1);
	          scan.get_scan_cartesian_point_scanner( seg.end, x2, y2);

	          sx = (x1 + x2) / 2.0;
	          sy = (y1 + y2) / 2.0;

	          const double cos_a = cos(scan.get_base_state().get_base_raw_position().get_base_alpha() );
	          const double sin_a = sin(scan.get_base_state().get_base_raw_position().get_base_alpha() );

	          //x = sx * cos_a - sy * sin_a + get_scanner_x(unit);
	          //y = sx * sin_a + sy * cos_a + get_scanner_y(unit);

	          // 70 is the offset of the scanner (base)
	          // scan.set_scanner_x         ( base_x +                                        _scanner_x * cos_base_a - _scanner_y * sin_base_a);
	          x = sx * cos_a - sy * sin_a + ( scan.get_base_state().get_base_raw_position().get_x() + 70 * cos_a - 0 * sin_a);
	          // scan.set_scanner_y         ( base_y +                                        _scanner_x * sin_base_a + _scanner_y * cos_base_a);
	          y = sx * sin_a + sy * cos_a + ( scan.get_base_state().get_base_raw_position().get_y() + 70 * sin_a + 0 * cos_a);

	////////////////////////////////////////////////////////////////////////////////////////

	          std::vector<double> x_person;
	          x_person.push_back(x/1000);
	          x_person.push_back(y/1000);



	          tmp = mahalanobisDistance(x_person, EKF_xkk.extract_vector(0,2),p_2x2);

	          //cout<<"mahalanobisDistance of segment: "<<i<<" mah: "<<tmp<<endl;

	          //if(tmp<min)
	          //if(tmp<min && tmp<0.4472) //sqrt(0.2) Chi-sqare distribution 90%
	          if(tmp<min && tmp< 1.5)  //0.8) //sqrt(0.2) Chi-sqare distribution 90%
	          {
	            min = tmp;
	            person_x = x;
	            person_y = y;
	            personFound = true;
	          }

	        }


	      }



	      double robotX, robotY, robotA;
	      robotX = scan.get_base_state().get_base_raw_position().get_x();
	      robotY = scan.get_base_state().get_base_raw_position().get_y();
	      robotA = scan.get_base_state().get_base_raw_position().get_base_alpha();

	      double angle = angle00(atan2( person_y- robotY,  person_x- robotX) - robotA);
	      //double angle = angle00(atan2( person_y- robotY,  person_x- robotX));

	      //double dist2 = scan.get_scan_distance(int((seg.begin+seg.end)/2));
	      double dist2 = sqrt( (robotX-person_x)*(robotX-person_x) + (robotY-person_y)*(robotY-person_y) );


	      scan.get_scan_time_stamp().get(ts);
	      newTime = ts.tv_sec * 1000000 + ts.tv_usec;
	      deltaTime = newTime - oldTime;
	      accumulatedDeltaTime += deltaTime;
	      if(oldTime != 0)
	      {
	        //----------------------------------------------------
	        //run one EKF interation
	        //doOneEkfIteration(dist2,angle,EKF,winEKF,deltaTime, accumulatedDeltaTime, personFound);

	// asteck
	        //double world_angle = angle00(atan2( person_y,  person_x));
		//double world_dist  = sqrt( (person_x)*(person_x) + (person_y)*(person_y) );
	        //doOneEkfIteration(person_x, person_y, deltaTime, accumulatedDeltaTime, personFound);
	        doOneEkfIteration(person_x, person_y, winEKF, deltaTime, accumulatedDeltaTime, personFound);
	// asteck




	        if(personFound==true)
	        {
	          noPersonCount = 0;
	          accumulatedDeltaTime = 0;

	          CommTrackingObjects::PersonLostEventState s;
	          s.set(CommTrackingObjects::PersonLostEventType::PERSON_FOUND);
	          COMP->personLostEventServer->put(s);

	          CommTrackingObjects::CommTrackingGoal trackingGoal;
	          //angle = angle00( angle - robotA );
	          trackingGoal.set( angle, dist2, person_x, person_y, true);
	          COMP->trackingGoalServer->put(trackingGoal);
	          //std::cout << "tracking goal x: " << person_x << "; y: " << person_y << std::endl;
	        }
	        else
	        {
	          noPersonCount++;
	        }
	        //----------------------------------------------------
	      } else {
	        //cout<<"oldTime == 0"<<endl;
	      }

	      oldTime = newTime;



	      if(noPersonCount >= 100) // 40 OK
	      {
	        ///////////// EVENT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TODO TODO
	    	CommTrackingObjects::CommTrackingGoal trackingGoal;
	        trackingGoal.set( 0, 0, 0, 0, false);
	        COMP->trackingGoalServer->put(trackingGoal);
	        std::cout << "no Person found!!!" << std::endl;
	        //noPersonCount = 0;
	        //CommTrackingObjects::PersonLostEventState s;
	        //s.set(PERSON_LOST);
	        //personLostEventServer->put(s);
	      }
	      if(noPersonCount >= 250) // 40 OK
	      {
	        noPersonCount = 0;
	        CommTrackingObjects::PersonLostEventState s;
	        s.set(CommTrackingObjects::PersonLostEventType::PERSON_LOST);
	        COMP->personLostEventServer->put(s);
	      }

	      ////////////////////////////////////////////////////////////////////////////
	      // send all legs to visualisation
	      count = legs.size();
	      //cout << "send legs: " << count << endl;

	      trackingData.set_laser_scan(scan);
	      trackingData.set_num_objects(count);
	      for(int i=0; i<count; ++i)
	      {
	        trackingData.set_object_first_point(i, legs[i].begin);
	        trackingData.set_object_last_point(i, legs[i].end);
	        trackingData.set_object_id(i, i);
	      }

	      // push trackingData
	      status = COMP->trackingSegmentsDataServer->put(trackingData);
	      if(status!=CHS::SMART_OK)
	      {
	        std::cerr << "WARNING: error on push (" << CHS::StatusCodeConversion(status) << ")" << std::endl;
	      }



	      ////////////////////////////////////////////////////////////////////////
	      // send person to follow to visualisation
	      if(personFound)
	      {
	        //std::cout << "send Person\n";
	        trackingData.set_laser_scan(scan);
	        trackingData.set_num_objects(1);
	        trackingData.set_object_first_point(0, persons[personIndex].begin);
	        trackingData.set_object_last_point(0, persons[personIndex].end);
	        trackingData.set_object_id(0, 0);

	        // push trackingData
	        status = COMP->trackingPersonDataServer->put(trackingData);
	        if(status!=CHS::SMART_OK)
	        {
	          std::cerr << "WARNING: error on push (" << CHS::StatusCodeConversion(status) << ")" << std::endl;
	        }
	      }
	      else
	      {
	        trackingData.set_laser_scan(scan);
	        trackingData.set_num_objects(0);

	        // push trackingData
	        status = COMP->trackingPersonDataServer->put(trackingData);
	        if(status!=CHS::SMART_OK)
	        {
	          std::cerr << "WARNING: error on push (" << CHS::StatusCodeConversion(status) << ")" << std::endl;
	        }
	      }


	    }
	   } // state
	  status = COMP->stateServer->release("follow");
	  } // while


	 }
	 catch (std::exception &e)
	 {
	   std::cout << "exception: " << e.what() << std::endl;
	 }

	  return 0;


}



void TrackingThread::getSegments(CommBasicObjects::CommMobileLaserScan &scan, std::vector<segment> &segments)
{
  segments.clear();
  int mask=0;                                     // mask == 0 means no segment active
  unsigned int count = scan.get_scan_size();
  count-=1;
  segment segment_tmp(0, count-1);

  for (uint i = 1; i < count; i++)
  {


    if(i > 0 && (std::abs(scan.get_scan_angle(i) - scan.get_scan_angle(i-1)) > 2*scan.get_scan_resolution()) )
    {
      if (mask==1)
      {
        //segments[segments.size()].end = i-1;
        segment_tmp.end = i-1;
        segments.push_back(segment_tmp);
      }
      mask=0;
      continue;
    }


    if (mask==0)
    { // create a new segment
      segment_tmp.begin = i;
      segment_tmp.end = count-1;
      mask=1;
    }

    //std::cout<<"getSegments::scan.get_scan_distance(i+1):: i:"<<i<<" count: "<<count<<std::endl;
    if (std::abs(scan.get_scan_distance(i) - scan.get_scan_distance(i+1)) > COMP->ini.tracking.segmentation_threshold)
    { // check if should close segment
      segment_tmp.end = i;
      segments.push_back(segment_tmp);
      //segment_tmp.end = count-1;
      mask=0;
    }

  } // for
}




bool TrackingThread::checkArcPreRequisites(CommBasicObjects::CommMobileLaserScan &scan, segment &seg)
{
  bool rtrn = false;
  if( seg.end - seg.begin >= 4 )
  {
    int middle_index = (seg.end + seg.begin ) /2;
    double middle_x, middle_y;
    scan.get_scan_cartesian_point_scanner( middle_index, middle_x, middle_y );

    double right_x, right_y, left_x, left_y;
    scan.get_scan_cartesian_point_scanner( seg.begin, right_x, right_y );
    scan.get_scan_cartesian_point_scanner( seg.end, left_x, left_y );

    middle_x -= left_x;
    middle_y -= left_y;

    float angle_to_rotate = atan2( (left_x-right_x)/(left_y-right_y), 1);

    double rotate_x, rotate_y;
    rotate_x = middle_x*cos(angle_to_rotate) - middle_y*sin(angle_to_rotate);
    rotate_y = middle_x*sin(angle_to_rotate) + middle_y*cos(angle_to_rotate);

    double dist = sqrt( (left_x-right_x)*(left_x-right_x) + (left_y-right_y)*(left_y-right_y)  );

//    cout << "right_x: " << right_x << "; right_y: " << right_y << "; left_x: " << left_x << "; left_y: " << left_y
//	 << "; middle_x: " << middle_x << "; middle_y: " << middle_y << "; ---> -rotate_x: " << -rotate_x << "; 0.1*dist: "
//         << 0.1 * dist << endl;

    //if( -rotate_x > 0.001 * dist && -rotate_x < dist )
    if( -rotate_x > 0.1 * dist )//&& -rotate_x < dist )
    {
      rtrn = true;
    }
  }

  return rtrn;
}


bool TrackingThread::checkLeg(CommBasicObjects::CommMobileLaserScan &scan, segment &seg, int min, int max)
{
  bool rtrn = false;
  if( seg.end - seg.begin >= 0 )
  {
    double right_x, right_y, left_x, left_y;
    scan.get_scan_cartesian_point_scanner( seg.begin, right_x, right_y );
    scan.get_scan_cartesian_point_scanner( seg.end, left_x, left_y );
    float diameter = sqrt( (left_x-right_x)*(left_x-right_x) + (left_y-right_y)*(left_y-right_y) );

    // check single legs
   // std::cout<<"TrackingThread::checkLeg:: seg.begin-1: "<<seg.begin-1<<" seg.begin: "<<seg.begin<< " seg.end+1: "<<seg.end+1<<std::endl;
    if( (diameter < max) && (diameter > min)
       && ( scan.get_scan_distance(seg.begin-1) > scan.get_scan_distance(seg.begin))
       && ( scan.get_scan_distance(seg.end+1) > scan.get_scan_distance(seg.end) ) )
    {
      rtrn = true;
    }
  }

  return rtrn;
}


void TrackingThread::doOneEkfIteration(float person_x, float person_y, CDisplayWindowPlots &winEKF, unsigned long long deltaTime , unsigned long long accumulatedDeltaTime, bool personFound){

// Update vehicle:
    // x+=v*DELTA_TIME*(cos(phi)-sin(phi));
    // y+=v*DELTA_TIME*(sin(phi)+cos(phi));
    // phi+=w*DELTA_TIME;

    // v+=1.0f*DELTA_TIME*cos(t);
    // w-=0.1f*DELTA_TIME*sin(t);


     // Simulate noisy observation:
    // float realBearing = atan2( y,x );
    // float obsBearing = realBearing  + BEARING_SENSOR_NOISE_STD * mrpt::random::normalizedGaussian();
    // printf("Real/Simulated bearing: %.03f / %.03f deg\n", RAD2DEG(realBearing), RAD2DEG(obsBearing) );

    // float realRange = sqrt(square(x)+square(y));
    // float obsRange = max(0.0, realRange  + RANGE_SENSOR_NOISE_STD * mrpt::random::normalizedGaussian() );
    // printf("Real/Simulated range: %.03f / %.03f \n", realRange, obsRange );

      //obsRange /=1000;
     person_x /=1000;
     person_y /=1000;

     // Process with EKF:
     COMP->EKF->doProcess(deltaTime/1000000.0, accumulatedDeltaTime/1000000.0 ,person_x, person_y, personFound);
     //EKF.doProcess(DELTA_TIME,obsRange, obsBearing);


     // Show EKF state:
     CVectorTemplate<KFTYPE>                 EKF_xkk;
     CMatrixTemplateNumeric<KFTYPE>  EKF_pkk;

     COMP->EKF->getState( EKF_xkk, EKF_pkk );

     //cout << "EKF: " << EKF_xkk << endl;


     // Draw EKF state:
     CMatrixTemplateNumeric<KFTYPE>   COVXY(2,2);
     COVXY(0,0) = EKF_pkk(0,0);
     COVXY(1,1) = EKF_pkk(1,1);
     //cout<<"P: "<<EKF_pkk<<endl;
     COVXY(0,1) = COVXY(1,0) = EKF_pkk(0,1);

     winEKF.plotEllipse( EKF_xkk[0], EKF_xkk[1], COVXY, 1, "b-2", "ellipse_EKF" );

     // Delay:
     //mrpt::system::sleep((int)(DELTA_TIME*5000));
     //t+=DELTA_TIME;
}
