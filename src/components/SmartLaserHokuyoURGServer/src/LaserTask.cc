//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.6.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartLaserHokuyoURGServer component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "LaserTask.hh"
#include "CommManipulatorObjects/commMobileManipulatorState.hh"

#include "gen/SmartLaserHokuyoURGServer.hh"
#include <EulerTransformationMatrices.hh>

#include <string>
#include <iostream>

LaserTask::LaserTask() {
	_default_base_position.set_x(COMP->ini.base_manipulator.x);
	_default_base_position.set_y(COMP->ini.base_manipulator.y);
	_default_base_position.set_z(COMP->ini.base_manipulator.z);
	_default_base_position.set_base_alpha(COMP->ini.base_manipulator.base_a);
	_default_base_position.set_steer_alpha(COMP->ini.base_manipulator.steer_a);
	_default_base_position.set_turret_alpha(COMP->ini.base_manipulator.turret_a);

	// set scan id counter to 0
	scan_id = 0;
}

bool LaserTask::accquireNewScan(Smart::CommMobileLaserScan& scan) {
	if (COMP->ini.scanner.verbose)
		std::cout << "[Laser Task] read new laser data\n";

	if (laser.read_laser_data()) {

		// set scan header
		scan.set_scan_time_stamp(Smart::CommTimeStamp(laser.get_receive_timestamp()));
		scan.set_scan_update_count(scan_id);

		//////////////////////////
		// set scan parameters
		//////////////////////////
		if (COMP->ini.scanner.verbose) {
			std::cout << "set scan parameters\n";
		}

		const unsigned int min_dist = COMP->ini.scanner.min_range;
		const unsigned int max_dist = COMP->ini.scanner.max_range;

		scan.set_scan_length_unit(1);
		scan.set_scan_integer_field_of_view(-0.5 * int(COMP->ini.scanner.opening_angle), laser.get_resolution());
		scan.set_min_distance(min_dist);
		scan.set_max_distance(max_dist);

		//////////////////////////
		// set scan points
		//////////////////////////

		const int desiredScans = COMP->ini.scanner.opening_angle / laser.get_resolution();
		const int rangerScans = laser.get_opening_angle() / laser.get_resolution();

		const uint32_t firstScanIndex = (rangerScans - desiredScans) * 0.5;
		uint32_t lastScanIndex = rangerScans - firstScanIndex;

		if (lastScanIndex > laser.extract_num_points())
			lastScanIndex = laser.extract_num_points();

		uint32_t num_valid_points = 0;
		for (uint32_t i = firstScanIndex; i < lastScanIndex; ++i) {
			const unsigned int dist = laser.extract_distance(i);
			if (dist >= min_dist && dist <= max_dist) {
				++num_valid_points;
			}
		}

		scan.set_scan_size(num_valid_points);

		uint32_t valid_point_index = 0;
		for (uint32_t i = firstScanIndex; i < lastScanIndex; ++i) {
			const unsigned int dist = laser.extract_distance(i);
			if (dist >= min_dist && dist <= max_dist) {
				scan.set_scan_index(valid_point_index, i - firstScanIndex);
				scan.set_scan_integer_distance(valid_point_index, dist);
				scan.set_scan_intensity(valid_point_index, laser.extract_intensity(i));
				++valid_point_index;
			}
		}

		scan.set_scan_valid(true);
		scan_id++;

		return true;
	} else {
		return false;
	}
}

int LaserTask::svc() {
	Smart::CommMobileLaserScan scan;
	Smart::CommBaseState base_state;
	CommManipulatorObjects::CommManipulatorState manipulator_state;
	CommManipulatorObjects::CommMobileManipulatorState mobile_manipulator_state;

	Smart::CommBaseVelocity zero_velocity;
	zero_velocity.set_v(0);
	zero_velocity.set_omega_base(0);
	zero_velocity.set_omega_steer(0);
	zero_velocity.set_omega_turret(0);

	// open device
	std::cout << "[Laser Task] try to open " << COMP->ini.scanner.type << " device " << COMP->ini.scanner.device
			<< " ...\n";

	ScipWrapper::RangerType rangerType;

	if (strcasecmp(COMP->ini.scanner.type.c_str(), "URG-04LX") == 0) {
		rangerType = ScipWrapper::URG_04LX;
	} else if (strcasecmp(COMP->ini.scanner.type.c_str(), "URG-04LX-UG01") == 0) {
		rangerType = ScipWrapper::URG_04LX_UG01;
	} else if (strcasecmp(COMP->ini.scanner.type.c_str(), "UBG-05LX-F01") == 0) {
		rangerType = ScipWrapper::UBG_05LX_F01;
	} else if (strcasecmp(COMP->ini.scanner.type.c_str(), "UHG-08LX") == 0) {
		rangerType = ScipWrapper::UHG_08LX;
	} else if (strcasecmp(COMP->ini.scanner.type.c_str(), "UTM-30LXS") == 0) {
		rangerType = ScipWrapper::UTM_30LX;
	} else {
		std::cerr << "[Laser Task] Ranger type unknown!\n";
		return 0;
	}

	laser.open_device(rangerType, COMP->ini.scanner.device.c_str(), COMP->ini.scanner.speed);
	std::cout << "[Laser Task] device " << COMP->ini.scanner.device << " successfully opened!\n";

	std::cout << "[Laser Task] start scanning ...\n";

	while (!CHS::SmartThreadManager::instance()->testcancel(ACE_Thread::self())) {

		// block here when component not in active state
		COMP->stateServer->acquire("active");
		COMP->stateServer->release("active");

		if (accquireNewScan(scan)) {
			bool scan_is_valid = false;

			//////////////////////////
			// set base state
			//////////////////////////
			if (COMP->ini.scanner.verbose)
				std::cout << "[Laser Task] set base state\n";

			// read base state from manipulator
			if (COMP->ini.base_manipulator.on_manipulator) {
				CHS::StatusCode status = COMP->manipulatorTimedClient->getUpdate(mobile_manipulator_state);
				manipulator_state = mobile_manipulator_state.get_manipulator_state();
				base_state = mobile_manipulator_state.get_base_state();

				if (status == CHS::SMART_OK) {
					scan_is_valid = manipulator_state.is_valid();

					if (COMP->ini.scanner.verbose) {
						manipulator_state.print();
						std::cout.flush();
					}
				} else {
					std::cerr << "[Laser Task] WARNING: failed to get current manipulator state ("
							<< CHS::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
					scan.set_scan_valid(false);
				}
			}
			// read base state from base server
			else if (COMP->ini.base_manipulator.on_base) {
				CHS::StatusCode status = COMP->baseTimedClient->getUpdate(base_state);

				if (status == CHS::SMART_OK) {
					scan_is_valid = true;

					if (COMP->ini.scanner.verbose) {
						base_state.print();
						std::cout << "\n";
					}
				} else {
					std::cerr << "[Laser Task] WARNING: failed to get current base state ("
							<< CHS::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
					scan.set_scan_valid(false);
				}
			}
			// default base state
			else {
				base_state.set_time_stamp(Smart::CommTimeStamp(laser.get_receive_timestamp()));
				base_state.set_base_position(_default_base_position);
				base_state.set_base_velocity(zero_velocity);
				scan_is_valid = true;
			}
			scan.set_base_state(base_state);

			//////////////////////////
			// set robot scanner position
			//////////////////////////
			double x = COMP->ini.scanner.x;
			double y = COMP->ini.scanner.y;
			double z = COMP->ini.scanner.z;
			double azimuth = COMP->ini.scanner.azimuth;
			double elevation = COMP->ini.scanner.elevation;
			double roll = COMP->ini.scanner.roll;
			arma::mat mat_sensor;

			if (COMP->ini.base_manipulator.on_manipulator && scan_is_valid) {
				arma::mat mat_offset(4, 4);
				EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_offset);

				arma::mat mat_tcp(4, 4);
				double tcp_x, tcp_y, tcp_z, tcp_azimuth, tcp_elevation, tcp_roll;
				manipulator_state.get_pose_TCP_manipulator(tcp_x, tcp_y, tcp_z, tcp_azimuth, tcp_elevation, tcp_roll);
				EulerTransformationMatrices::create_zyx_matrix(tcp_x, tcp_y, tcp_z, tcp_azimuth, tcp_elevation,
						tcp_roll, mat_tcp);

				arma::mat mat_manipulator(4, 4);
				double man_x, man_y, man_z, man_azimuth, man_elevation, man_roll;
				manipulator_state.get_pose_manipulator(man_x, man_y, man_z, man_azimuth, man_elevation, man_roll);
				EulerTransformationMatrices::create_zyx_matrix(man_x, man_y, man_z, man_azimuth, man_elevation,
						man_roll, mat_manipulator);

				mat_sensor = mat_manipulator * mat_tcp * mat_offset;

			} else {
				EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_sensor);
			}

			Smart::CommPose3d sensor_pose(mat_sensor);
			scan.set_sensor_pose(sensor_pose);

			//////////////////////////
			// set world scanner position
			//////////////////////////
			double base_x = 0;
			double base_y = 0;
			double base_z = 0;
			double base_a = 0;
			arma::mat mat_base(4, 4);

			if (scan_is_valid) {
				base_x = base_state.get_base_position().get_x();
				base_y = base_state.get_base_position().get_y();
				base_z = base_state.get_base_position().get_z();
				if (COMP->ini.base_manipulator.on_turret) {
					base_a = base_state.get_base_position().get_turret_alpha();
				} else {
					base_a = base_state.get_base_position().get_base_alpha();
				}
			}

			EulerTransformationMatrices::create_zyx_matrix(base_x, base_y, base_z, base_a, 0, 0, mat_base);
			arma::mat mat_world = mat_base * mat_sensor;
			Smart::CommPose3d world_pose(mat_world);

			scan.set_scanner_x(world_pose.get_x());
			scan.set_scanner_y(world_pose.get_y());
			scan.set_scanner_z(world_pose.get_z());

			scan.set_scanner_azimuth(world_pose.get_azimuth());
			scan.set_scanner_elevation(world_pose.get_elevation());
			scan.set_scanner_roll(world_pose.get_roll());

			//////////////////////////
			// send scan to clients
			//////////////////////////
			if (COMP->ini.scanner.verbose)
				std::cout << "[Laser Task] send scan to clients\n";

			if (COMP->ini.services.activate_push_newest) {
				CHS::StatusCode push_status = COMP->laserPushNewestServer->put(scan);
				if (push_status != CHS::SMART_OK) {
					std::cerr << "[Laser Task] WARNING: error on push (" << CHS::StatusCodeConversion(push_status)
							<< ")" << std::endl;
				}
			}

			// copy local scan to global scan
			CHS::SmartGuard scan_guard(COMP->ScanLock);
			COMP->global_scan = scan;
			scan_guard.release();

			if (COMP->ini.scanner.verbose) {
				const unsigned int index = scan.get_scan_size() / 2;
				std::cout << "[Laser Task] Scan " << scan_id << " sent." << " Scan Position " << index << "/"
						<< scan.get_scan_size() << " = " << scan.get_scan_distance(index) << " mm" << std::endl;
			}
		} else {
			std::cerr << "[Laser Task] WARNING: received unexpected packet type" << std::endl;
		}
	}

	// close laser device
	laser.close_device();

	return 0;
}
