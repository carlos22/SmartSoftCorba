//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.2.1
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// http://smart-robotics.sourceforge.net/
//
// This file is generated once. Modify this file to your needs.
// If you want the workflow to re-generate this file, please
// delete it before running the workflow.
//
//------------------------------------------------------------------------
//
//  Copyright (C) 2009 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "Katana Mobile Manipulation component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "ControllerTask.hh"
#include "gen/MobileManipulationClient.hh"

#include <iostream>

ControllerTask::ControllerTask()
{
	std::cout << "constructor ControllerTask\n";
}

int ControllerTask::svc()
{
	std::cout << "Hello from ControllerTask\n";

	COMP->scanEnvironment->connect( COMP->ini.scanEnvironment.serverName, COMP->ini.scanEnvironment.serviceName);
	COMP->manipulateObject->connect( COMP->ini.manipulateObject.serverName, COMP->ini.manipulateObject.serviceName);
	COMP->moveToPoint->connect( COMP->ini.moveToPoint.serverName, COMP->ini.moveToPoint.serviceName);
	COMP->getNewPoint->connect(COMP->ini.getNewPoint.serverName, COMP->ini.getNewPoint.serviceName);


	Smart::CommMoMaScanEnvironment scanRequest;
	Smart::CommMoMaObjectList scanResult;
	Smart::CommMoMaObjectList manipulateRequest;
	Smart::CommMoMaManipulateState manipulateResult;
	CHS::StatusCode status;

	std::string manipulateObject = "Becher";
	std::string command;

	while (command != "exit")
	{
		std::cout << "Command [getPoint, manipulate, home, exit]: ";
		std::cin >> command;

		if (command == "manipulate")
		{
			// scan environment and get objects
			scanRequest.setStartAngle(240);
			scanRequest.setScanAngle(180);

			status = COMP->scanEnvironment->query(scanRequest, scanResult);
			std::cout << "query (status): " << CHS::StatusCodeConversion(status) << " result " << endl;

			// manipulate objects
			std::vector<uint32_t> objects;
			std::string objClass;


			for (uint32_t i=0; i < scanResult.getObjectListSize(); i++)
			{
				double x, y, z, yaw, pitch, roll;

				scanResult.getObjectClass(i, objClass);
				scanResult.getPose(i, x, y, z, yaw, pitch, roll);
				
				std::cout << "Id, ObjectClass: " << scanResult.getId(i) << ", " << objClass 
					  << "  (" << x << ", " << y << ", " << z << ", " << yaw << ", " << pitch << ", " << roll << ")" << endl;

				if (objClass == manipulateObject)
				{
					objects.push_back(i);
				}
			}

			manipulateRequest.setObjectListSize(objects.size());

			if (objects.size() > 0)
			{
				size_t j = 0;
				for (; j < objects.size()-1; ++j)
				{
					double x, y, z, yaw, pitch, roll;

					// stack objects in each other
					manipulateRequest.setId(j, scanResult.getId(objects[j]));
					manipulateRequest.setObjectClass(j, objClass);
					scanResult.getPose(objects[j+1], x, y, z, yaw, pitch, roll);
					manipulateRequest.setPose(j, x, y, z + 0.12, atan(y/x), M_PI/2, 0);
					manipulateRequest.setCommand(j, 1);
				}

				// manipulate last object
				manipulateRequest.setId(j, scanResult.getId(objects[j]));
				manipulateRequest.setObjectClass(j, objClass);
				manipulateRequest.setMotors(j, 3.13322, 2.13827, 2.87904, 4.98754, 3.1406);
				manipulateRequest.setCommand(j, 0);

				// send object list
				status = COMP->manipulateObject->query(manipulateRequest, manipulateResult);
				std::cout << "query (status): " << CHS::StatusCodeConversion(status) << " result " << endl;

				std::string state;

				for (uint32_t i = 0; i < manipulateResult.getSize(); i++)
				{
					manipulateResult.getState(i, state);
					std::cout << "ObjectId, State: " << manipulateResult.getObjectId(i) << ", " << state << endl;
				}
			}


/*
			if (objects.size() >= 2)
			{
				std::cout << "Two objects found -> stack them\n";
				double x, y, z, yaw, pitch, roll;

				manipulateRequest.setObjectListSize(2);

				// stack object 1 into object 2
				manipulateRequest.setId(0, scanResult.getId(objects[0]));
				manipulateRequest.setObjectClass(0, objClass);
				scanResult.getPose(objects[1], x, y, z, yaw, pitch, roll);
				manipulateRequest.setPose(0, x, y, z + 0.11, atan(y/x), M_PI/2, 0);
				manipulateRequest.setCommand(0, 1);

				// manipulate object 2
				manipulateRequest.setId(1, scanResult.getId(objects[1]));
				manipulateRequest.setObjectClass(1, objClass);
				manipulateRequest.setMotors(1, 3.13322, 2.13827, 2.87904, 4.98754, 3.1406);

				// send object list
				status = COMP->manipulateObject->query(manipulateRequest, manipulateResult);
				std::cout << "query (status): " << CHS::StatusCodeConversion(status) << " result " << endl;

				std::string state;

				for (uint32_t i = 0; i < manipulateResult.getSize(); i++)
				{
					manipulateResult.getState(i, state);
					std::cout << "ObjectId, State: " << manipulateResult.getObjectId(i) << ", " << state << endl;
				}
			}
*/

		}
		else if (command == "getPoint")
		{

			Smart::CommMoMaPose moveRequest;
			Smart::CommMoMaPose moveResult;

			moveRequest.setMotors(3.18292, 1.32026, 1.96614, 3.30004, 3.18649);
			COMP->moveToPoint->send(moveRequest);

			sleep(3);

			moveRequest.setMotors(3.13997, 2.10003, 0.995503, 1.1667, 3.16367);
			status = COMP->getNewPoint->query(moveRequest, moveResult);
			std::cout << "query (status): " << CHS::StatusCodeConversion(status) << " result " << endl;

			std::cout << "Motor Angles: "
					  << moveResult.getMotor1()
					  << ", " << moveResult.getMotor2()
					  << ", " << moveResult.getMotor3()
					  << ", " << moveResult.getMotor4()
					  << ", " << moveResult.getMotor5()
					  << std::endl;

			moveRequest.setMotors(3.13997, 2.10003, 0.995503, 1.1667, 3.16367);
			COMP->moveToPoint->send(moveRequest);
		}
		else if (command == "home")
		{
			// move robot back to home position
			Smart::CommMoMaPose moveRequest;

			std::cout << ">> move to give position" << std::endl;
			moveRequest.setMotors(3.18292, 1.32026, 1.96614, 3.30004, 3.18649);
			COMP->moveToPoint->send(moveRequest);

			sleep(3);
			std::cout << ">> open gripper" << std::endl;
			moveRequest.setMotors(3.18292, 1.32026, 1.96614, 3.30004, 3.18649);
			moveRequest.setCommand(1);
			COMP->moveToPoint->send(moveRequest);

			sleep(3);
			std::cout << ">> move to home position" << std::endl;
			moveRequest.setMotors(3.13997, 2.10003, 0.995503, 1.1667, 3.16367);
			moveRequest.setCommand(0);
			COMP->moveToPoint->send(moveRequest);
		}
	}

	Smart::CommMoMaPose moveRequest;
	moveRequest.setMotors(3.13997, 2.10003, 0.995503, 1.1667, 3.16367);
	COMP->moveToPoint->send(moveRequest);

	return 0;
}
