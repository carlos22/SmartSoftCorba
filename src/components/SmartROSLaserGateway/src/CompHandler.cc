//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.2
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2011 Christian Schlegel, Alex Lotz
//
//        schlegel@hs-ulm.de
//        lotz@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "CompHandler.hh"
#include "gen/SmartROSLaserGateway.hh"

#include <iostream>

#include "ROS_LaserScan.hh"

// include communication objects
#include <CommBasicObjects/commMobileLaserScan.hh>

void CompHandler::onStartup()
{
	std::cout << "startup - put your startupCode in CompHandler::onStartup()!!!\n";

	if(COMP->ini.ROS.is_static_mounted_lrf)
	{
		tf::TransformListener tf_listener;
		std::string first = COMP->ini.ROS.tf_base_link_name;
		std::string second = COMP->ini.ROS.tf_laser_base_link_name;

		int max_tries = 3;
		bool success = false;
		while(max_tries > 0 && !success)
		{
			std::cout << "wait for tf to get ready..." << std::endl;
			tf_listener.waitForTransform(first, second, ros::Time(), ros::Duration(1.0));
			try {
				tf_listener.lookupTransform(first, second, ros::Time(), COMP->base_laser_offset);
				if(COMP->ini.services.verbose)
				{
					std::cout << "Laser Offset: X= " << COMP->base_laser_offset.getOrigin().getX()
						<< ", Y= " << COMP->base_laser_offset.getOrigin().getY()
						<< ", Z= " << COMP->base_laser_offset.getOrigin().getZ() << std::endl;
				}
				success = true;
			} catch (tf::TransformException &ex) {
				ROS_WARN("transformation failed: %s; retry...\n", ex.what());
				max_tries--;
				sleep(1);
			}
		}
	}

	if(COMP->ini.services.subscribe_base) {
		std::cout << "connecting to: " << COMP->ini.baseStateClient.serverName << "; "
				<< COMP->ini.baseStateClient.serviceName << std::endl;
		CHS::StatusCode status = COMP->baseStateClient->connect(COMP->ini.baseStateClient.serverName,
				COMP->ini.baseStateClient.serviceName);
		while (status != CHS::SMART_OK)
		{
			usleep(500000);
			status = COMP->baseStateClient->connect(COMP->ini.baseStateClient.serverName,
					COMP->ini.baseStateClient.serviceName);
		}
		std::cout << "connected.\n";

		COMP->baseStateClient->subscribe(COMP->ini.baseStateClient.interval);
	} else {
		std::cout << "Not connecting to base." << std::endl;
	}

	COMP->lrf_subscr = COMP->rosnode->subscribe(COMP->ini.ROS.laser_subscr_name, 1, ROS_LaserScan::lrfCallback);

//	COMP->raw_odometry_subscr = COMP->rosnode->subscribe("/base_controller/odometry", 1, ROS_LaserScan::odometryRawCallback);
//	COMP->gps_odometry_subscr = COMP->rosnode->subscribe("/base_pose_ground_truth", 1, ROS_LaserScan::odometryGpsCallback);

	COMP->rOS_SpinTask.open();
}
