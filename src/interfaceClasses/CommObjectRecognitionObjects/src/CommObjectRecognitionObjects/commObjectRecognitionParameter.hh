//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.8.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "CommObjectRecognitonObjects".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#ifndef _COMM_COMMOBJECTRECOGNITIONOBJECTS_COMMOBJECTRECOGNITIONPARAMETER_HH
#define _COMM_COMMOBJECTRECOGNITIONOBJECTS_COMMOBJECTRECOGNITIONPARAMETER_HH

#include <string>
#include <sstream>
#include <iostream>

// include files of classes

// include header-files of included communication objects

// include enums
#include <CommObjectRecognitionObjects/gen/enumObjectRecognitionBehavior.hh>
#include <CommObjectRecognitionObjects/gen/enumObjectRecognitionMode.hh>
#include <CommObjectRecognitionObjects/gen/enumObjectRecognitionSensor.hh>

// include client-side file generated by IDL compiler
#include "CommObjectRecognitionObjects/gen/smartCommObjectRecognitionParameterC.hh"

#ifndef LISP_SEPARATOR
#define LISP_SEPARATOR " ()\"\n"
#define LISP_STRING    1000
#endif


/**
 * The repository for object recognition.
 */
namespace CommObjectRecognitionObjects {

class CommObjectRecognitionParameter {
protected:
	CommObjectRecognitionObjectsIDL::CommObjectRecognitionParameter idl_CommObjectRecognitionParameter;

public:
	CommObjectRecognitionParameter() {
	}

	CommObjectRecognitionParameter(const CommObjectRecognitionObjectsIDL::CommObjectRecognitionParameter &obj) :
		idl_CommObjectRecognitionParameter(obj) {
	}

	operator CommObjectRecognitionObjectsIDL::CommObjectRecognitionParameter() const
	{
		return idl_CommObjectRecognitionParameter;
	}

	virtual ~CommObjectRecognitionParameter() {
	}

	void get(CORBA::Any &a) const;
	void set(const CORBA::Any &a);

	static inline std::string identifier(void) {
		return "CommObjectRecognitionObjects::CommObjectRecognitionParameter";
	}

	//
	// user interfaces

	/**
	 * Set the values of the communication object in lisp syntax.
	 * Syntax:
	 * 		CLOUD(?id)
	 * 		ADDOBJECT((type ?type) (height ?height))
	 * 		DELOBJECTS
	 * 		BEHAVIOR(?b) | b = FULLSEARCH, SEARCH
	 * 		RECOGNIZE
	 */
	int set(const std::string& str) {
		char *param = (char *) NULL;
		char *input = (char *) NULL;

		int error = 0;
		input = (char *) str.c_str();

		do {
			param = strsep(&input, LISP_SEPARATOR);
		} while ((param != NULL) && (strlen(param) == 0));

		if (strcasecmp(param, "CLOUD") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_CLOUD;
			idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_UNSET;
			//idl_CommObjectRecognitionParameter.color = CommObjectRecognitionObjectsIDL::LITERAL_NO_COLOR;
			idl_CommObjectRecognitionParameter.type = "";
			idl_CommObjectRecognitionParameter.height = 0;

			do {
				param = strsep(&input, LISP_SEPARATOR);
			} while ((param != NULL) && (strlen(param) == 0));

			if ((sscanf(param, "%d", &idl_CommObjectRecognitionParameter.cloud_id) != 1)) {
				error = -1;
			}

		} else if (strcasecmp(param, "ADDOBJECT") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_ADDOBJECT;
			idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_UNSET;
			idl_CommObjectRecognitionParameter.cloud_id = 0;

			do
			{
			param = strsep(&input,LISP_SEPARATOR);
			} while ((param != NULL) && (strlen(param)==0));

			char* tmp = (char*)NULL;
			tmp = (char *)calloc(LISP_STRING,sizeof(char));

			if ((param != NULL) && (sscanf(param,"%s",tmp)==1))
			{
				// everything ok
				error = 0;
				std::string str(tmp);

				idl_CommObjectRecognitionParameter.type = str.c_str();
			}
			else
			{
			  error = -1;
			}

//			idl_CommObjectRecognitionParameter.color = CommObjectRecognitionObjectsIDL::LITERAL_NO_COLOR;
			//idl_CommObjectRecognitionParameter.type = "";
			//idl_CommObjectRecognitionParameter.height = 0;

		} else if (strcasecmp(param, "DELOBJECTS") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_DELOBJECTS;


		} else if (strcasecmp(param, "BEHAVIOR") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_BEHAVIOR;
//			idl_CommObjectRecognitionParameter.color = CommObjectRecognitionObjectsIDL::LITERAL_NO_COLOR;
			idl_CommObjectRecognitionParameter.type = "";
			idl_CommObjectRecognitionParameter.height = 0;
			idl_CommObjectRecognitionParameter.cloud_id = 0;

			do {
				param = strsep(&input, LISP_SEPARATOR);
			} while ((param != NULL) && (strlen(param) == 0));

			if (strcasecmp(param, "SEARCH") == 0) {
				idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_SEARCH;
			} else if (strcasecmp(param, "FULLSEARCH") == 0) {
				idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_FULLSEARCH;
			} else if (strcasecmp(param, "CLUSTERING_ON") == 0) {
				idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_CLUSTERING_ON;
			} else if (strcasecmp(param, "CLUSTERING_OFF") == 0) {
				idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_CLUSTERING_OFF;
			}


		} else if (strcasecmp(param, "ADDSENSOR") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_ADDSENSOR;

			do {
				param = strsep(&input, LISP_SEPARATOR);
			} while ((param != NULL) && (strlen(param) == 0));

			if (strcasecmp(param, "KINECT") == 0) {
				idl_CommObjectRecognitionParameter.sensor = CommObjectRecognitionObjectsIDL::LITERAL_KINECT;
			} else if (strcasecmp(param, "MANIPULATOR_CAMERA") == 0) {
				idl_CommObjectRecognitionParameter.sensor = CommObjectRecognitionObjectsIDL::LITERAL_MANIPULATOR_CAMERA;
			} else if (strcasecmp(param, "MANIPULATOR_LASER") == 0) {
				idl_CommObjectRecognitionParameter.sensor = CommObjectRecognitionObjectsIDL::LITERAL_MANIPULATOR_LASER;
			}
		} else if (strcasecmp(param, "DELSENSORS") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_DELSENSORS;


		} else if (strcasecmp(param, "ADDALGORITHM") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_ADDALGORITHM;

			do {
				param = strsep(&input, LISP_SEPARATOR);
			} while ((param != NULL) && (strlen(param) == 0));

			if ((param != NULL) && (strlen(param) == 0)) {
				idl_CommObjectRecognitionParameter.algorithm = param;
			} else {
				error = -1;
				return error;
			}
		} else if (strcasecmp(param, "DELALGORITHMS") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_DELALGORITHMS;


		} else if (strcasecmp(param, "RECOGNIZE") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_RECOGNIZE;


		} else if (strcasecmp(param, "BELIEF_THRESHOLD") == 0) {
			idl_CommObjectRecognitionParameter.mode = CommObjectRecognitionObjectsIDL::LITERAL_BELIEF_THRESHOLD;
			idl_CommObjectRecognitionParameter.behavior = CommObjectRecognitionObjectsIDL::LITERAL_UNSET;
			idl_CommObjectRecognitionParameter.belief_threshold = 0;

			param = strsep(&input, LISP_SEPARATOR);
			if ((param != NULL) && (strlen(param) == 0)) {
				idl_CommObjectRecognitionParameter.belief_threshold = atof(param);
			} else {
				error = -1;
				return error;
			}



		} else {
			error = -1;
		}

		return error;
	}

	/**
	 * Set the mode in which the communication object is set.
	 * 		behavior = the behavior value is valid.
	 * 		config = the configuration values are valid.
	 * 		cloud = the point cloud id is valid.
	 */
	inline void set_mode(ObjectRecognitionMode mode) {
		idl_CommObjectRecognitionParameter.mode = mode.get_value_idl();
	}

	/**
	 * Get the mode in which the communication object is set.
	 * 		behavior = the behavior value is valid.
	 * 		config = the configuration values are valid.
	 * 		cloud = the point cloud id is valid.
	 */
	inline ObjectRecognitionMode get_mode() const {
		return idl_CommObjectRecognitionParameter.mode;
	}

	/**
	 * Set the behavior in which the object recognition component should work.
	 * 		fullsearch = return all objects found in the scene, although obstacles.
	 * 		search = search only until the first object is found.
	 * 		unset = not specified.
	 */
	inline void set_behavior(ObjectRecognitionBehavior behavior) {
		idl_CommObjectRecognitionParameter.behavior = behavior.get_value_idl();
	}

	/**
	 * Get the behavior in which the object recognition component should work.
	 * 		fullsearch = return all objects found in the scene, although obstacles.
	 * 		search = search only until the first object is found.
	 * 		unset = not specified.
	 */
	inline ObjectRecognitionBehavior get_behavior() const {
		return idl_CommObjectRecognitionParameter.behavior;
	}

	/**
	 * Set the sensor used for obj rec
	 */
	inline void set_sensor(ObjectRecognitionSensor sensor) {
		idl_CommObjectRecognitionParameter.sensor = sensor.get_value_idl();
	}

	/**
	 * get the sensor used for obj rec
	 */
	inline ObjectRecognitionSensor get_sensor() const {
		return idl_CommObjectRecognitionParameter.sensor;
	}

	/**
	 * Set the algorithm used for obj rec
	 */
	inline void set_algorithm(std::string algorithm) {
		idl_CommObjectRecognitionParameter.algorithm = algorithm.c_str();
	}

	/**
	 * get the algorithm used for obj rec
	 */
	inline std::string get_algorithm() const {
		return std::string(idl_CommObjectRecognitionParameter.algorithm);
	}

	/**
	 * Set the type the object which is searched for should have.
	 */
	inline void set_type(const std::string& type) {
		idl_CommObjectRecognitionParameter.type = type.c_str();
	}

	/**
	 * Get the type the object which is searched for should have.
	 */
	inline void get_type(std::string& type) const {
		type = idl_CommObjectRecognitionParameter.type;
	}

	/**
	 * Set the height in which the object is expected.
	 * This value can be used in the 2D case for distance calculation.
	 */
	inline void set_height(int32_t height) {
		idl_CommObjectRecognitionParameter.height = height;
	}

	/**
	 * Get the height in which the object is expected.
	 * This value can be used in the 2D case for distance calculation.
	 */
	inline int32_t get_height() const {
		return idl_CommObjectRecognitionParameter.height;
	}

	/**
	 * Set the id of the point cloud.
	 */
	inline void set_cloud_id(uint32_t id) {
		idl_CommObjectRecognitionParameter.cloud_id = id;
	}

	/**
	 * Get the id of the point cloud.
	 */
	inline uint32_t get_cloud_id() const {
		return idl_CommObjectRecognitionParameter.cloud_id;
	}

	/**
	 * Set belief threshold
	 */
	inline void set_belief_threshold(double threshold) {
		idl_CommObjectRecognitionParameter.belief_threshold = threshold;
	}

	/**
	 * get belief threshold
	 */
	inline double get_belief_threshold() const {
		return idl_CommObjectRecognitionParameter.belief_threshold;
	}

	/**
	 * Print the object to an output stream.
	 * @param os Output stream to which should be printed
	 */
	void print(std::ostream &os = std::cout) const;

};

//
// Implementation
//

inline std::ostream &operator<<(std::ostream &os, const CommObjectRecognitionParameter &obj) {
	obj.print(os);
	return os;
}

}
#endif
