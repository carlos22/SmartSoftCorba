//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.3
// The SmartSoft Toolchain has been developed by:
//  
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
// 
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#ifndef _COMMNAVIGATIONOBJECTS_ENUM_HH_PLANNEREVENTTYPE
#define _COMMNAVIGATIONOBJECTS_ENUM_HH_PLANNEREVENTTYPE

#include <CommNavigationObjects/gen/enumPlannerEventTypeC.hh>
#include <string>
#include <ostream>

namespace CommNavigationObjects
{

class PlannerEventType
{
public:
	enum literal
	{

		PLANNER_GOAL_NOT_MARKED = CommNavigationObjectsIDL::LITERAL_PLANNER_GOAL_NOT_MARKED,

		PLANNER_GOAL_OK = CommNavigationObjectsIDL::LITERAL_PLANNER_GOAL_OK,

		PLANNER_INVALID_MAP = CommNavigationObjectsIDL::LITERAL_PLANNER_INVALID_MAP,

		PLANNER_NO_ERROR = CommNavigationObjectsIDL::LITERAL_PLANNER_NO_ERROR,

		PLANNER_NO_GOAL_AVAILABLE = CommNavigationObjectsIDL::LITERAL_PLANNER_NO_GOAL_AVAILABLE,

		PLANNER_NO_PATH = CommNavigationObjectsIDL::LITERAL_PLANNER_NO_PATH,

		PLANNER_PATH_FOUND = CommNavigationObjectsIDL::LITERAL_PLANNER_PATH_FOUND,

		PLANNER_START_OCCUPIED_GOAL = CommNavigationObjectsIDL::LITERAL_PLANNER_START_OCCUPIED_GOAL,

		PLANNER_START_OCCUPIED_OBSTACLE = CommNavigationObjectsIDL::LITERAL_PLANNER_START_OCCUPIED_OBSTACLE,

		PLANNER_UNKNOWN = CommNavigationObjectsIDL::LITERAL_PLANNER_UNKNOWN,

		PLANNER_UNKNOWN_ERROR = CommNavigationObjectsIDL::LITERAL_PLANNER_UNKNOWN_ERROR,

		PLANNER_WRONG_MAPID = CommNavigationObjectsIDL::LITERAL_PLANNER_WRONG_MAPID
	};

	PlannerEventType()
	{
	}

	PlannerEventType(literal t)
	{
		value = t;
	}

	operator literal()
	{
		return value;
	}

	PlannerEventType(CommNavigationObjectsIDL::ENUM_PlannerEventType t)
	{
		value = (literal) t;
	}

	bool operator ==(PlannerEventType& t)
	{
		return this->value == t.value;
	}

	CommNavigationObjectsIDL::ENUM_PlannerEventType get_value_idl()
	{
		return (CommNavigationObjectsIDL::ENUM_PlannerEventType) value;
	}

	literal get_value() const
	{
		return value;
	}

	std::string get_string() const
	{
		switch (value)
		{

		case PLANNER_GOAL_NOT_MARKED:
			return "PlannerEventType::PLANNER_GOAL_NOT_MARKED";
			break;

		case PLANNER_GOAL_OK:
			return "PlannerEventType::PLANNER_GOAL_OK";
			break;

		case PLANNER_INVALID_MAP:
			return "PlannerEventType::PLANNER_INVALID_MAP";
			break;

		case PLANNER_NO_ERROR:
			return "PlannerEventType::PLANNER_NO_ERROR";
			break;

		case PLANNER_NO_GOAL_AVAILABLE:
			return "PlannerEventType::PLANNER_NO_GOAL_AVAILABLE";
			break;

		case PLANNER_NO_PATH:
			return "PlannerEventType::PLANNER_NO_PATH";
			break;

		case PLANNER_PATH_FOUND:
			return "PlannerEventType::PLANNER_PATH_FOUND";
			break;

		case PLANNER_START_OCCUPIED_GOAL:
			return "PlannerEventType::PLANNER_START_OCCUPIED_GOAL";
			break;

		case PLANNER_START_OCCUPIED_OBSTACLE:
			return "PlannerEventType::PLANNER_START_OCCUPIED_OBSTACLE";
			break;

		case PLANNER_UNKNOWN:
			return "PlannerEventType::PLANNER_UNKNOWN";
			break;

		case PLANNER_UNKNOWN_ERROR:
			return "PlannerEventType::PLANNER_UNKNOWN_ERROR";
			break;

		case PLANNER_WRONG_MAPID:
			return "PlannerEventType::PLANNER_WRONG_MAPID";
			break;

		default:
			return "UNKNOWN!";
			break;
		}
	}

private:
	literal value;
};

inline std::ostream &operator<<(std::ostream &os, const PlannerEventType &e)
{
	os << e.get_string();
	return os;
}

}
#endif
