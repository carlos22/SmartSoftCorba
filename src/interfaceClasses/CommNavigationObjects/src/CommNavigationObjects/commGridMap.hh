//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Communication Classes".
//  It provides basic standardized data types for communication between
//  different components in the mobile robotics context. These classes
//  are designed to be used in conjunction with the SmartSoft Communication
//  Library.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------


#ifndef _COMM_COMMNAVIGATIONOBJECTS_COMMGRIDMAP_HH
#define _COMM_COMMNAVIGATIONOBJECTS_COMMGRIDMAP_HH

#include <cmath>
#include <string>
#include <iostream>
#include <iomanip>

// include files of classes

// include header-files of included communication objects
#include <CommBasicObjects/commTimeStamp.hh>

// include enums


// include client-side file generated by IDL compiler
#include "CommNavigationObjects/gen/smartCommGridMapC.hh"




// --------------------------------------------------------------------
// Values for the actual map
// 0-127    denote traversability with 0 completely free
// 128-255  special values
// --------------------------------------------------------------------
#define MAPPER_FREE          0
#define MAPPER_OBSTACLE      128
#define MAPPER_GROWING       129
#define MAPPER_UNDELETABLE   130

// --------------------------------------------------------------------
// Values to define obstacle growing
// --------------------------------------------------------------------
#define MAPPER_GROWING_NO          0
#define MAPPER_GROWING_CIRCLE_16   1
#define MAPPER_GROWING_CIRCLE_8    2
#define MAPPER_GROWING_STAR_16     3
#define MAPPER_GROWING_STAR_12     4




namespace CommNavigationObjects
{

class CommGridMap
{
protected:
	CommNavigationObjectsIDL::CommGridMap idl_CommGridMap;

public:
	CommGridMap()
	{
		idl_CommGridMap.id = 0;
		idl_CommGridMap.is_valid = false;
		idl_CommGridMap.time.sec = 0;
		idl_CommGridMap.time.usec = 0;
		idl_CommGridMap.xOffsetMM = 0;
		idl_CommGridMap.yOffsetMM = 0;
		idl_CommGridMap.xOffsetCells = 0;
		idl_CommGridMap.yOffsetCells = 0;
		idl_CommGridMap.cellSizeMM = 0;
		idl_CommGridMap.xSizeMM = 0;
		idl_CommGridMap.ySizeMM = 0;
		idl_CommGridMap.xSizeCells = 0;
		idl_CommGridMap.ySizeCells = 0;
		idl_CommGridMap.size = 0;

	}

	CommGridMap(const CommNavigationObjectsIDL::CommGridMap &obj) :
		idl_CommGridMap(obj)
		{
		}

	virtual ~CommGridMap()
	{
	}

	void get(CORBA::Any &a) const;
	void set(const CORBA::Any &a);

	inline const CommNavigationObjectsIDL::CommGridMap &get() const
	{
		return idl_CommGridMap;
	}

	inline void set(const CommNavigationObjectsIDL::CommGridMap &obj)
	{
		idl_CommGridMap = obj;
	}

	static inline std::string identifier(void)
	{
		return "CommNavigationObjects::CommGridMap";
	}

	//
	// user interfaces
	/// extract all relevant parameters from the communication class of the map
	int get_parameter( unsigned int &id,
			bool &is_valid,
			struct timeval &time,
			int &xOffsetMM,
			int &yOffsetMM,
			int &xOffsetCells,
			int &yOffsetCells,
			unsigned int &cellSizeMM,
			unsigned int &xSizeMM,
			unsigned int &ySizeMM,
			unsigned int &xSizeCells,
			unsigned int &ySizeCells ) const;

	/// extract a cell from the communication class of the map
	inline unsigned char get_cells(unsigned int xcell, unsigned int ycell) const
	{
		return ( idl_CommGridMap.cell[xcell+ycell*idl_CommGridMap.xSizeCells]);
	}


	/// save the map in X11 XPM format
	void save_xpm( std::ostream &os ) const;

	/// save map in XML format
	void save_xml( std::ostream &os, const std::string &indent = "" ) const;

	/// load map from XML format
	void load_xml( std::istream &is );

	/**
	      Get the time stamp.
	 */
	inline CommBasicObjects::CommTimeStamp get_time_stamp() const { return CommBasicObjects::CommTimeStamp(idl_CommGridMap.time); }

	/**
	      Set the time stamp.
	 */
	inline void set_time_stamp(const CommBasicObjects::CommTimeStamp &ts) { idl_CommGridMap.time = ts.get_idl(); }


};

}
#endif
