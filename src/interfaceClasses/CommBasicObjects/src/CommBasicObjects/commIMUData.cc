//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//
//  Copyright (C) 2009 Christian Schlegel, Florian Poppa
//
//        schlegel@hs-ulm.de
//        poppa@hs-ulm.de
//
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

#include "commIMUData.hh"

using namespace CommBasicObjects;

void CommIMUData::get(CORBA::Any &a) const
{
	a <<= idl_CommIMUData;
}

void CommIMUData::set(const CORBA::Any &a)
{
	CommBasicObjectsIDL::CommIMUData *tmp_cmd;
	if (a >>= tmp_cmd)
	{
		idl_CommIMUData = *tmp_cmd;
	}
}

void CommIMUData::printCommunicationObject(std::ostream &os) const
{
  double acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z, mag_x, mag_y, mag_z, roll, pitch, yaw;

  get_accelerometer_values(acc_x, acc_y, acc_z);
  get_gyroscope_values(gyr_x, gyr_y, gyr_z);
  get_magnetometer_values(mag_x, mag_y, mag_z);
  get_euler_angles(roll, pitch, yaw);

  os << "CommIMUData(";

  os << "acc_x: " << acc_x << ", ";
  os << "acc_y: " << acc_y << ", ";
  os << "acc_z: " << acc_z << ", ";

  os << "gyr_x: " << gyr_x << ", ";
  os << "gyr_y: " << gyr_y << ", ";
  os << "gyr_z: " << gyr_z << ", ";

  os << "mag_x: " << mag_x << ", ";
  os << "mag_y: " << mag_y << ", ";
  os << "mag_z: " << mag_z << ", ";

  os << "roll: " << roll << ", ";
  os << "pitch: " << pitch << ", ";
  os << "yaw: " << yaw;

  os << ")";
}

void CommIMUData::printCommunicationObjectCSV(std::ostream &os) const
{
  double acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z, mag_x, mag_y, mag_z, roll, pitch, yaw;

  get_accelerometer_values(acc_x, acc_y, acc_z);
  get_gyroscope_values(gyr_x, gyr_y, gyr_z);
  get_magnetometer_values(mag_x, mag_y, mag_z);
  get_euler_angles(roll, pitch, yaw);

  os << acc_x << ", ";
  os << acc_y << ", ";
  os << acc_z << ", ";

  os << gyr_x << ", ";
  os << gyr_y << ", ";
  os << gyr_z << ", ";

  os << mag_x << ", ";
  os << mag_y << ", ";
  os << mag_z << ", ";

  os << roll  << ", ";
  os << pitch << ", ";
  os << yaw;
}
