//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.8.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

#ifndef _COMM_COMMKINECTOBJECTS_COMMKINECTIMAGE_HH
#define _COMM_COMMKINECTOBJECTS_COMMKINECTIMAGE_HH

#include <string>

// include files of classes
#include <commSharedMemory.hh>
#include <commPose3d.hh>
#include <commBaseState.hh>
// include header-files of included communication objects

// include enums


// include client-side file generated by IDL compiler

namespace CommKinectObjects {

class CommKinectImage: protected Smart::CommSharedMemoryBase {

private:
	arma::mat robot_mat;
	arma::mat world_mat;

	arma::mat color_intrinsic_mat;
	arma::mat color_inv_intrinsic_mat;
	arma::mat dist_intrinsic_mat;
	arma::mat camera_extrinsic_mat;

public:
	/**
	 * Description of the Kinect image parameters.
	 */
	struct KinectImageParameters {
		//
		// The following fields may be written from CommResizableVideoImage instances
		//

		/**
		 * The width of the image in pixels.
		 */
		uint32_t width;

		/**
		 * The height of the image in pixels.
		 */
		uint32_t height;

		/**
		 * Size of the complete used memory in bytes.
		 */
		uint32_t size;

		/**
		 * Size of the color image in bytes.
		 */
		uint32_t color_image_size;

		/**
		 * Size of the distance image in bytes.
		 */
		uint32_t distance_image_size;

		//
		// The following fields may be written from CommMutableVideoImage instances
		//

		/**
		 * The pose where the image was captured relative to the
		 * robot coordinate system.
		 */
		Smart::CommPose3d sensor_pose;

		/**
		 * The state of the base when the image was captured.
		 */
		Smart::CommBaseState base_state;

		/**
		 * The intrinsic matrix of the color camera
		 */
		double color_intinsic[4][4];

		/**
		 * The intrinsic matrix of the distance camera
		 */
		double dist_intinsic[4][4];

		/**
		 * The extrinsic matrix between the cameras
		 */
		double camera_extrinsic[4][4];

		/**
		 * The minimal distance the sensor works [mm].
		 */
		double_t min_distance;

		/**
		 * The maximal distance the sensor works [mm].
		 */
		double_t max_distance;

		/**
		 * The opening angle of the camera in x-axis [rad].
		 * It is expected that the opening angle in positive and negative direction is the same.
		 */
		double_t opening_angle_x_axis;

		/**
		 * The opening angle of the camera in y-axis [rad].
		 * It is expected that the opening angle in positive and negative direction is the same.
		 */
		double_t opening_angle_y_axis;

		/**
		 * Boolean flag if image data is valid.
		 */
		bool data_valid;

		/**
		 * Sequence counter
		 */
		ulong seq_count;
	};

public:
	CommKinectImage() {
	}

	inline CommKinectImage(const CommKinectImage &source) :
		CommSharedMemoryBase(source) {
	}

	inline CommKinectImage &operator=(const CommKinectImage &source) {
		CommSharedMemoryBase::operator=(source);
		return *this;
	}

	virtual ~CommKinectImage() {
	}

	/**
	 * Required by SmartSoft.
	 */
	inline void get(CORBA::Any &a) const {
		CommSharedMemoryBase::get(a);
	}

	/**
	 * Required by SmartSoft.
	 */
	inline void set(const CORBA::Any &a) {
		CommSharedMemoryBase::set(a);
	}

	static inline std::string identifier(void) {
		return "CommKinectObjects::CommKinectImage";
	}

	///////////////////////////////////////////////////////
	// user interfaces
	///////////////////////////////////////////////////////

	/**
	 * Get the pose of the sensor relative to the robot coordinate system.
	 */
	inline Smart::CommPose3d get_sensor_pose() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->sensor_pose;
	}

	/**
	 * Get the state of the base.
	 */
	inline Smart::CommBaseState get_base_state() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->base_state;
	}

	/**
	 * Get the width of the ToF image in pixels.
	 */
	inline uint32_t get_width() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->width;
	}

	/**
	 * Get the height of the ToF image in pixels.
	 */
	inline uint32_t get_height() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->height;
	}

	/**
	 * Get the minimal distance the sensor works.
	 */
	inline double_t get_min_distance(const double_t unit = 0.001) const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->min_distance * 0.001 / unit;
	}

	/**
	 * Get the maximal distance the sensor works.
	 */
	inline double_t get_max_distance(const double_t unit = 0.001) const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->max_distance * 0.001 / unit;
	}

	/**
	 * Get the opening angle of the camera in x-axis [rad].
	 * It is expected that the opening angle in positive and negative direction is the same.
	 */
	inline double_t get_opening_angle_x_axis() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->opening_angle_x_axis;
	}

	/**
	 * Get the opening angle of the camera in y-axis [rad].
	 * It is expected that the opening angle in positive and negative direction is the same.
	 */
	inline double_t get_opening_angle_y_axis() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->opening_angle_y_axis;
	}

	/**
	 * Return the size of the whole ToF image (incl. image parameters etc.) in memory in bytes.
	 */
	inline uint32_t get_size() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->size;
	}

	/**
	 * Return the size of the color image in memory in bytes.
	 */
	inline uint32_t get_color_image_size() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->color_image_size;
	}

	/**
	 * Return the size of the distance image in memory in bytes.
	 */
	inline uint32_t get_distance_image_size() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->distance_image_size;
	}

	/**
	 * Get the intrinsic matrix of the color camera.
	 */
	inline const arma::mat& get_color_intinsic() {

		if (color_intrinsic_mat.n_elem == 0) {
			arma::mat m(4, 4);
			for (size_t i = 0; i < 4; ++i) {
				for (size_t j = 0; j < 4; j++) {
					m(i, j) = reinterpret_cast<const KinectImageParameters*> (shm)->color_intinsic[i][j];
				}
			}
			color_intrinsic_mat = m;
		}

		return color_intrinsic_mat;
	}

	/**
	 * Get the intrinsic matrix of the distance camera.
	 */
	inline const arma::mat& get_distance_intrinsic() {

		if (dist_intrinsic_mat.n_elem == 0) {
			arma::mat m(4, 4);
			for (size_t i = 0; i < 4; ++i) {
				for (size_t j = 0; j < 4; j++) {
					m(i, j) = reinterpret_cast<const KinectImageParameters*> (shm)->dist_intinsic[i][j];
				}
			}

			dist_intrinsic_mat = m;
		}

		return dist_intrinsic_mat;
	}

	/**
	 * Get the extrinsic matrix between the cameras.
	 */
	inline const arma::mat& get_camera_extrinsic() {

		if (camera_extrinsic_mat.n_elem == 0) {
			arma::mat m(4, 4);
			for (size_t i = 0; i < 4; ++i) {
				for (size_t j = 0; j < 4; j++) {
					m(i, j) = reinterpret_cast<const KinectImageParameters*> (shm)->camera_extrinsic[i][j];
				}
			}
			camera_extrinsic_mat = m;
		}

		return camera_extrinsic_mat;
	}

	/**
	 * Check if the image data is valid.
	 */
	inline bool is_data_valid() const {
		return (shm) && reinterpret_cast<const KinectImageParameters*> (shm)->data_valid;
	}

	/**
	 * Returns the server sided sequence counter of this image.
	 * Use it to see if your client drops frames.
	 */
	inline ulong get_sequence_counter() const {
		return reinterpret_cast<const KinectImageParameters*> (shm)->seq_count;
	}

	/**
	 * Returns a pointer to rgb image
	 * The image has the size return from get_size().
	 */
	inline const uint8_t* get_rgb_image() const {
		return reinterpret_cast<const uint8_t*> (shm) + sizeof(KinectImageParameters) / sizeof(uint8_t);
	}

	/**
	 * Returns a pointer to the first element of the coordinate image.
	 * The image has the size return from get_image_size().
	 */
	inline const float* get_distances() const {
		return reinterpret_cast<const float*> (shm) + (sizeof(KinectImageParameters) + get_color_image_size())
				/ sizeof(float);
	}

	/**
	 * Get the Cartesian 3d point in the sensor coordinate system.
	 */
	inline void get_cartesian_point_sensor(const uint32_t posX, const uint32_t posY, double& x, double& y, double& z,
			const double unit = 0.001) {

		if (color_inv_intrinsic_mat.n_elem == 0) {
			color_inv_intrinsic_mat = arma::inv(get_distance_intrinsic());
		}

		// get pointer to source position
		const float dist = *(get_distances() + (posY * get_width()) + posX);

		arma::vec q(4);
		q(0) = posX;
		q(1) = posY;
		q(2) = 1;
		q(3) = 1;

		q = color_inv_intrinsic_mat * q;

		arma::vec point(3);
		point(0) = q(0);
		point(1) = q(1);
		point(2) = q(2);

		point = (point / arma::norm(point, 2)) * dist;

		x = point(0) / unit;
		y = point(1) / unit;
		z = point(2) / unit;
	}

	/**
	 * Get the Cartesian 3d point in the robot coordinate system.
	 */
	inline void get_cartesian_point_robot(const uint32_t posX, const uint32_t posY, double& x, double& y, double& z,
			const double unit = 0.001) {

		if (robot_mat.n_elem == 0) {
			robot_mat = get_sensor_pose().getHomogeneousMatrix(1);
		}

		arma::vec q(4);
		get_cartesian_point_sensor(posX, posY, q(0), q(1), q(2), 1);
		q(3) = 1;

		arma::vec point = robot_mat * q;

		x = point(0) / unit;
		y = point(1) / unit;
		z = point(2) / unit;
	}

	/**
	 * Get the Cartesian 3d point in the world coordinate system.
	 */
	inline void get_cartesian_point_world(const uint32_t posX, const uint32_t posY, double& x, double& y, double& z,
			const double unit = 0.001) {

		if (world_mat.n_elem == 0) {
			arma::mat pose_robot = get_base_state().get_base_position().get_base_pose3d().getHomogeneousMatrix(1);
			arma::mat pose = get_sensor_pose().getHomogeneousMatrix(1);

			world_mat = pose_robot * pose;
		}

		arma::vec q(4);
		get_cartesian_point_sensor(posX, posY, q(0), q(1), q(2), 1);
		q(3) = 1;

		arma::vec point = world_mat * q;

		x = point(0) / unit;
		y = point(1) / unit;
		z = point(2) / unit;
	}

	/**
	 *  Get the spherical coordinate of a 3d point in the sensor coordinate system.
	 */
	inline void get_spherical_point_sensor(const uint32_t posX, const uint32_t posY, double &radius, double &phi,
			double &theta, const double unit = 0.001) {

		double x, y, z;
		get_cartesian_point_sensor(posX, posY, x, y, z, unit);

		// calculate the spherical coordinates
		radius = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
		phi = atan2(y, x);
		theta = acos(z / radius);

	}

	/**
	 *  Get the spherical coordinate of a 3d point in the robot coordinate system.
	 */
	inline void get_spherical_point_robot(const uint32_t posX, const uint32_t posY, double &radius, double &phi,
			double &theta, const double unit = 0.001) {

		double x, y, z;
		get_cartesian_point_robot(posX, posY, x, y, z, unit);

		// calculate the spherical coordinates
		radius = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
		phi = atan2(y, x);
		theta = acos(z / radius);

	}

	/**
	 *  Get the spherical coordinate of a 3d point in the world coordinate system.
	 */
	inline void get_spherical_point_world(const uint32_t posX, const uint32_t posY, double &radius, double &phi,
			double &theta, const double unit = 0.001) {

		double x, y, z;
		get_cartesian_point_world(posX, posY, x, y, z, unit);

		// calculate the spherical coordinates
		radius = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
		phi = atan2(y, x);
		theta = acos(z / radius);

	}

};

}
#endif
