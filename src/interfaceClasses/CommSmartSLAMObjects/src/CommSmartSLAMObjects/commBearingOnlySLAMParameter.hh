//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2010 Matthias Lutz
//
//        schlegel@hs-ulm.de
//
//        Prof. Dr. Christian Schlegel
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Communication Library".
//  It provides standardized patterns for communication between
//  different components.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
// --------------------------------------------------------------------------

#ifndef _COMM_COMMSMARTSLAMOBJECTS_COMMBEARINGONLYSLAMPARAMETER_HH
#define _COMM_COMMSMARTSLAMOBJECTS_COMMBEARINGONLYSLAMPARAMETER_HH

#include <string>
#include <iostream>
// include files of classes

// include header-files of included communication objects

// include enums
#include <CommSmartSLAMObjects/gen/enumBearingOnlySLAMTag.hh>

// include client-side file generated by IDL compiler
#include "CommSmartSLAMObjects/gen/smartCommBearingOnlySLAMParameterC.hh"

#ifndef LISP_SEPARATOR
#define LISP_SEPARATOR " ()\"\n"
#define LISP_STRING    1000
#endif

namespace CommSmartSLAMObjects
{

class CommBearingOnlySLAMParameter
{
protected:
	CommSmartSLAMObjectsIDL::CommBearingOnlySLAMParameter
			idl_CommBearingOnlySLAMParameter;

public:
	CommBearingOnlySLAMParameter()
	{
	}

	CommBearingOnlySLAMParameter(
			const CommSmartSLAMObjectsIDL::CommBearingOnlySLAMParameter &obj) :
		idl_CommBearingOnlySLAMParameter(obj)
	{
	}

	virtual ~CommBearingOnlySLAMParameter()
	{
	}

	void get(CORBA::Any &a) const;
	void set(const CORBA::Any &a);

	inline const CommSmartSLAMObjectsIDL::CommBearingOnlySLAMParameter &get() const
	{
		return idl_CommBearingOnlySLAMParameter;
	}

	inline void set(
			const CommSmartSLAMObjectsIDL::CommBearingOnlySLAMParameter &obj)
	{
		idl_CommBearingOnlySLAMParameter = obj;
	}

	static inline std::string identifier(void)
	{
		return "CommSmartSLAMObjects::CommBearingOnlySLAMParameter";
	}

	//
	// user interfaces

	inline void get(BearingOnlySLAMTag &tag, int & value1, int & value2, int & value3) const
	{
		tag = idl_CommBearingOnlySLAMParameter.tag;
		value1 = idl_CommBearingOnlySLAMParameter.parameter1;
		value2 = idl_CommBearingOnlySLAMParameter.parameter2;
		value3 = idl_CommBearingOnlySLAMParameter.parameter3;
	}


	inline int set(std::string& inString)
	{
		// ----------------------------------------------------
		//
		// handle tag to BearingOnlySLAMParameter
		//
		// input
		//   LANDMARKCOUNT ?n
		//
		// output
		//   0  everything ok
		//  -1  format error occured
		// ----------------------------------------------------

		char *param = (char *)NULL;
		char *parse = (char *)NULL;
		char *input = (char *)NULL;

		int  error;
		int  i;

		input = (char *)inString.c_str();
		error = 0;

		do
		{
			param = strsep(&input,LISP_SEPARATOR);
		} while ((param != NULL) && (strlen(param)==0));

		if (strcasecmp(param,"LANDMARKCOUNT")==0)
		{
			// ---------------------------------------
			// set upper number of landmarks to initialize  -- n
			// ---------------------------------------

			idl_CommBearingOnlySLAMParameter.tag = CommSmartSLAMObjectsIDL::LITERAL_LANDMARKCOUNT;

			parse = (char *)calloc(LISP_STRING,sizeof(char));

			for (i=0; i<3; i++)
			{
				do
				{
					param = strsep(&input,LISP_SEPARATOR);
				} while ((param != NULL) && (strlen(param)==0));
				parse = strcat(parse,param);
				parse = strcat(parse," ");
			}
			if (sscanf(parse,"%d",&idl_CommBearingOnlySLAMParameter.parameter1) == 3)
			{
				error = 0;
			}
			else
			{
				error = -1;
			}
			free(parse);
		}
		else
		{
			// --------------------
			// got garbage
			// --------------------
			error = -1;
		}

		return error;
	}

};

}
#endif
