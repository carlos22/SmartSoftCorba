//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "CommManipulatorObjects".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#ifndef _COMM_COMMVISIONOBJECTS_COMMVIDEOIMAGE_HH
#define _COMM_COMMVISIONOBJECTS_COMMVIDEOIMAGE_HH

#include <string>

// include files of classes
#include <CommVisionObjects/gen/structImageParametersC.hh>
#include <CommVisionObjects/gen/enumFormatType.hh>

// include header-files of included communication objects
#include <CommBasicObjects/commBaseState.hh>
#include <CommBasicObjects/commPose3d.hh>


// include enums


// include client-side file generated by IDL compiler
#include "CommVisionObjects/gen/smartCommVideoImageC.hh"

namespace CommVisionObjects
{

class CommVideoImage
{
protected:
	CommVisionObjectsIDL::CommVideoImage idl_CommVideoImage;

public:
	CommVideoImage()
	{
	}


	CommVideoImage(unsigned int width, unsigned int height, CommVisionObjects::FormatType format, const unsigned char *data = 0);


	CommVideoImage(const CommVisionObjectsIDL::CommVideoImage &obj) :
	idl_CommVideoImage(obj)
	{
	}

	operator CommVisionObjectsIDL::CommVideoImage() const
	{
		return idl_CommVideoImage;
	}

	virtual ~CommVideoImage()
	{
	}

	void get(CORBA::Any &a) const;
	void set(const CORBA::Any &a);

	inline const CommVisionObjectsIDL::CommVideoImage &get() const
	{
		return idl_CommVideoImage;
	}

	inline void set(const CommVisionObjectsIDL::CommVideoImage &obj)
	{
		idl_CommVideoImage = obj;
	}

	static inline std::string identifier(void)
	{
		return "CommVisionObjects::CommVideoImage";
	}

	//
	// user interfaces


	/**
	 * Get the pose of the sensor relative to the robot coordinate system.
	 */
	inline CommBasicObjects::CommPose3d get_sensor_pose() const {
		return idl_CommVideoImage.sensor_pose;
	}

	/**
	 * Get the state of the base.
	 */
	inline CommBasicObjects::CommBaseState get_base_state() const {
		return idl_CommVideoImage.base_state;
	}

	/**
	 Get the width of the image in pixels.
	 */
	inline unsigned int get_width() const {
		return idl_CommVideoImage.parameter.width;
	}

	/**
	 Get the height of the image in pixels.
	 */
	inline unsigned int get_height() const {
		return idl_CommVideoImage.parameter.height;
	}

	/**
	 Get the data format of the image.
	 The <a href="http://www.thedirks.org/v4l2/">Video4Linux Two documentation</a>
	 contains
	 <a href="http://www.thedirks.org/v4l2/v4l2fmt.htm">a nice description of these formats</a>.
	 Note that the integer values of the enum members of this class do not necessarily
	 correspond to the macro values of video4linux for the same format.
	 */
	inline CommVisionObjects::FormatType get_format() const {
		return idl_CommVideoImage.parameter.format;
	}

	/**
	 Return the size of the image in memory in bytes.
	 */
	inline unsigned int get_size() const {
		return idl_CommVideoImage.parameter.size;
	}

	/**
	 Check if the image data is valid.
	 Image data may be invalid for example if the client requested a format which the
	 server isn't able to create.
	 At the moment, the server is configured by its ini file to one static format and size.
	 */
	inline bool is_data_valid() const {
		return idl_CommVideoImage.is_valid;
	}

	/**
	 Returns the server sided sequence counter of this image.
	 Use it to see if your client drops frames.
	 */
	inline unsigned long get_sequence_counter() const {
		return idl_CommVideoImage.seq_count;
	}


	//TODO !!!!
	/**
	 Return a pointer to the image data.
	 */
	inline const unsigned char* get_data() const {
		return  idl_CommVideoImage.data.get_buffer();
	}

	unsigned int get_size_as_rgb24() const;
	void get_as_rgb24(unsigned char *target) const;

	unsigned int get_size_as_rgb32() const;
	void get_as_rgb32(unsigned char *target) const;

	inline unsigned int get_size_as_bgr24() const {
		return get_size_as_rgb24();
	}
	void get_as_bgr24(unsigned char *target) const;

	inline unsigned int get_size_as_bgr32() const {
		return get_size_as_rgb32();
	}
	void get_as_bgr32(unsigned char *target) const;

	/**
	 Check if this image has a certain format.
	 */
	bool has_parameters(unsigned int width, unsigned int height, CommVisionObjects::FormatType format) const;

	//
	// helper functions for format handling
	//

	/**
	 Try to convert a string description of a format into the
	 corresponding enumeration member.
	 Returns \c false on failure.
	 */
	static bool string2format(const std::string &name, CommVisionObjects::FormatType &format);

	/**
	 Return a string describing the image format.
	 This string can be converted back to an enum member using string2format.
	 */
	static std::string format2string(CommVisionObjects::FormatType format);

	/**
	 Return the average number of bits per pixel for a given image format.
	 */
	static unsigned int depth(CommVisionObjects::FormatType format);

	/**
	 Adjust the image size to values permitted by the indicated format.
	 Certain formats require the image width to be an even number of pixels etc.
	 */
	static void adjust_size(unsigned int &width, unsigned int &height, CommVisionObjects::FormatType format);


	//	static inline void yuv2rgb(const unsigned char y, const unsigned char u, const unsigned char v, unsigned char &r,
	//			unsigned char &g, unsigned char &b);

	static inline void yuv2rgb(const unsigned char y, const unsigned char u, const unsigned char v, unsigned char &r, unsigned char &g, unsigned char &b) {
			/* Old Version which has not been tested
			 const float fy = 1.1643836 * (y -  16);
			 const float fu = 1.1339286 * (u - 128);
			 const float fv = 1.1339286 * (v - 128);
			 const float fr = fy + 1.402 * fv;
			 const float fg = fy - 0.344 * fu - 0.714 * fv;
			 const float fb = fy + 1.772 * fu;
			 */

			/* Old Version which function properly and has been used before the libdc1394 version
			 const float fr = y + 1.402 * (v - 128);
			 const float fg = y - 0.344 * (u - 128) - 0.714 * (v - 128);
			 const float fb = y + 1.772 * (u - 128);
			 */

			/* This block is needed to convert the float back to unsigned char
			 r = (fr<0)?0:(fr>255)?255:((unsigned char)::rint(fr));
			 g = (fg<0)?0:(fg>255)?255:((unsigned char)::rint(fg));
			 b = (fb<0)?0:(fb>255)?255:((unsigned char)::rint(fb));
			 */

			/**
			 * This block is taken from the libdc1394 library.
			 *
			 * The only modification is the subtraction of 128 from u and v because we use unsigned and have to shift it.
			 *
			 * The speed up of this version against the old version is about 3 to 6 times.
			 * Old Version conversion has been done in 60 to 70 ms on a 1024x768pixel (YUV422-UYVY) image.
			 * This image has then been converted into RGB32 with the same size.
			 * This Version converts in 10 to 20 ms on the same image.
			 */
			int fr = y + (((v - 128) * 1436) >> 10);
			int fg = y - (((u - 128) * 352 + (v - 128) * 731) >> 10);
			int fb = y + (((u - 128) * 1814) >> 10);
			fr = fr < 0 ? 0 : fr;
			fg = fg < 0 ? 0 : fg;
			fb = fb < 0 ? 0 : fb;
			r = fr > 255 ? 255 : fr;
			g = fg > 255 ? 255 : fg;
			b = fb > 255 ? 255 : fb;

		}


	static inline void yuv2bgr(const unsigned char y, const unsigned char u, const unsigned char v, unsigned char &b,
			unsigned char &g, unsigned char &r) {
		yuv2rgb(y, u, v, r, g, b);
	}

	/**
	 Save an XML like representation of this image to the given output stream.
	 */
	void save_xml(std::ostream &os, const std::string &indent = "") const;

private:
	void _get_as_rgb(unsigned char *target, int mode) const;
	void _get_as_bgr(unsigned char *target, int mode) const;

public:
	/**
	 * Set the pose of the sensor relative to the robot coordinate system.
	 */
	inline void set_sensor_pose(const CommBasicObjects::CommPose3d& pose) {
		idl_CommVideoImage.sensor_pose = pose;
	}

	/**
	 * Set the state of the base.
	 */
	inline void set_base_state(const CommBasicObjects::CommBaseState& state) {
		idl_CommVideoImage.base_state = state;
	}

	/**
	 Set the valid flag of the data to false.
	 The flag is automatically set to true if data is written to the image.
	 Thus the server either writes data to the image or sets the valid flag to false.
	 */
	void set_data_invalid();

	/**
	 Set the sequence counter of the image.
	 */
	void set_sequence_counter(unsigned long int n);

	/**
	 Copy image data from the memory chunk at \a data to the internal shared memory.
	 The number of bytes to copy is derived from the internal format and size descriptions.
	 */
	void set_data(const unsigned char *data);


	/**
		 Set the parameters of an image.
		 This causes currently attached shared memory to be detached, and a new shared memory segment
		 to be allocated.
	 */
	void set_parameters(unsigned int width, unsigned int height, CommVisionObjects::FormatType format);

	/**
		 Load from XML represenation on an istream.
		 Be warned, no error checking is done.
		 For details, see \ref smart_basic_com-xml.
	 */
	void load_xml(std::istream &is);




};

}
#endif
