//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "CommManipulatorObjects".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#ifndef _COMM_COMMVISIONOBJECTS_COMMKINECTIMAGE_HH
#define _COMM_COMMVISIONOBJECTS_COMMKINECTIMAGE_HH

#include <string>

// include files of classes

// include header-files of included communication objects
#include <CommBasicObjects/commBaseState.hh>
#include <CommBasicObjects/commPose3d.hh>

// include enums


// include client-side file generated by IDL compiler
#include "CommVisionObjects/gen/smartCommKinectImageC.hh"

namespace CommVisionObjects
{

class CommKinectImage
{
protected:
	CommVisionObjectsIDL::CommKinectImage idl_CommKinectImage;


private:
	arma::mat robot_mat;
	arma::mat world_mat;

	arma::mat color_intrinsic_mat;
	arma::mat color_inv_intrinsic_mat;
	arma::mat dist_intrinsic_mat;
	arma::mat camera_extrinsic_mat;


public:
	CommKinectImage()
	{
	}

	CommKinectImage(const CommVisionObjectsIDL::CommKinectImage &obj) :
		idl_CommKinectImage(obj)
	{
		// set length of 1-dim matrixes that are used as 4*4
		idl_CommKinectImage.camera_extrinsic_m.length(4*4);
		idl_CommKinectImage.color_intrinsic_m.length(4*4);
		idl_CommKinectImage.dist_intrinsic_m.length(4*4);
	}

	CommKinectImage(const uint32_t width, const uint32_t height) {
		set_parameters(width, height);
	}

	virtual ~CommKinectImage()
	{
	}

	void get(CORBA::Any &a) const;
	void set(const CORBA::Any &a);

	inline const CommVisionObjectsIDL::CommKinectImage &get() const
	{
		return idl_CommKinectImage;
	}

	inline void set(const CommVisionObjectsIDL::CommKinectImage &obj)
	{
		idl_CommKinectImage = obj;
	}

	static inline std::string identifier(void)
	{
		return "CommVisionObjects::CommKinectImage";
	}

	//
	// user interfaces
	/**
	 * Get the pose of the sensor relative to the robot coordinate system.
	 */
	inline CommBasicObjects::CommPose3d get_sensor_pose() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->sensor_pose;
		return idl_CommKinectImage.sensor_pose;
	}

	/**
	 * Get the state of the base.
	 */
	inline CommBasicObjects::CommBaseState get_base_state() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->base_state;
		return idl_CommKinectImage.base_state;
	}

	/**
	 * Get the width of the ToF image in pixels.
	 */
	inline uint32_t get_width() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->width;
		return idl_CommKinectImage.parameter.width;
	}

	/**
	 * Get the height of the ToF image in pixels.
	 */
	inline uint32_t get_height() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->height;
		return idl_CommKinectImage.parameter.height;
	}

	/**
	 * Get the minimal distance the sensor works.
	 */
	inline double_t get_min_distance(const double_t unit = 0.001) const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->min_distance * 0.001 / unit;
		return idl_CommKinectImage.min_distance * 0.001 / unit;
	}

	/**
	 * Get the maximal distance the sensor works.
	 */
	inline double_t get_max_distance(const double_t unit = 0.001) const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->max_distance * 0.001 / unit;
		return idl_CommKinectImage.max_distance * 0.001 / unit;
	}

	/**
	 * Get the opening angle of the camera in x-axis [rad].
	 * It is expected that the opening angle in positive and negative direction is the same.
	 */
	inline double_t get_opening_angle_x_axis() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->opening_angle_x_axis;
		return idl_CommKinectImage.opening_angle_x_axis;
	}

	/**
	 * Get the opening angle of the camera in y-axis [rad].
	 * It is expected that the opening angle in positive and negative direction is the same.
	 */
	inline double_t get_opening_angle_y_axis() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->opening_angle_y_axis;
		return idl_CommKinectImage.opening_angle_y_axis;
	}

	/**
	 * Return the size of the whole ToF image (incl. image parameters etc.) in memory in bytes.
	 */
	//inline uint32_t get_size() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->size;
		//return idl_CommKinectImage.parameter.size;
	//}

	/**
	 * Return the size of the color image in width*height
	 */
	inline uint32_t get_color_image_size() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->color_image_size;
		return idl_CommKinectImage.parameter.color_image_size;
	}

	/**
	 * Return the size of the distance image in width*height
	 */
	inline uint32_t get_distance_image_size() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->distance_image_size;
		return idl_CommKinectImage.parameter.distance_image_size;
	}

	/**
	 * Get the intrinsic matrix of the color camera.
	 */
	inline const arma::mat& get_color_intinsic() {

		if (color_intrinsic_mat.n_elem == 0) {
			arma::mat m(4, 4);
			for (size_t i = 0; i < 4; ++i) {
				for (size_t j = 0; j < 4; j++) {
					//m(i, j) = reinterpret_cast<const KinectImageParameters*> (shm)->color_intinsic[i][j];
					m(i, j) = idl_CommKinectImage.color_intrinsic_m[i*4 + j]; // _m is 1-dimension!
				}
			}
			color_intrinsic_mat = m;
		}

		return color_intrinsic_mat;
	}

	/**
	 * Get the intrinsic matrix of the distance camera.
	 */
	inline const arma::mat& get_distance_intrinsic() {

		if (dist_intrinsic_mat.n_elem == 0) {
			arma::mat m(4, 4);
			for (size_t i = 0; i < 4; ++i) {
				for (size_t j = 0; j < 4; j++) {
					//m(i, j) = reinterpret_cast<const KinectImageParameters*> (shm)->dist_intinsic[i][j];
					m(i, j) = idl_CommKinectImage.dist_intrinsic_m[i*4 + j]; // _m is 1-dimension!
				}
			}

			dist_intrinsic_mat = m;
		}

		return dist_intrinsic_mat;
	}

	/**
	 * Get the extrinsic matrix between the cameras.
	 */
	inline const arma::mat& get_camera_extrinsic() {

		if (camera_extrinsic_mat.n_elem == 0) {
			arma::mat m(4, 4);
			for (size_t i = 0; i < 4; ++i) {
				for (size_t j = 0; j < 4; j++) {
					//m(i, j) = reinterpret_cast<const KinectImageParameters*> (shm)->camera_extrinsic[i][j];
					m(i, j) = idl_CommKinectImage.camera_extrinsic_m[i*4 + j]; // _m is 1-dimension!
				}
			}
			camera_extrinsic_mat = m;
		}

		return camera_extrinsic_mat;
	}

	/**
	 * Check if the image data is valid.
	 */
	inline bool is_data_valid() const {
		//return (shm) && reinterpret_cast<const KinectImageParameters*> (shm)->data_valid;
		return idl_CommKinectImage.is_valid;
	}

	/**
	 * Returns the server sided sequence counter of this image.
	 * Use it to see if your client drops frames.
	 */
	inline ulong get_sequence_counter() const {
		//return reinterpret_cast<const KinectImageParameters*> (shm)->seq_count;
		return idl_CommKinectImage.seq_count;
	}

	/**
	 * Returns a pointer to rgb image
	 * The image has the size return from get_size().
	 */
	inline const uint8_t* get_rgb_image() const {
		//return reinterpret_cast<const uint8_t*> (shm) + sizeof(KinectImageParameters) / sizeof(uint8_t);
		return idl_CommKinectImage.rgb_data.get_buffer();
	}

	inline void set_rgb_image(const uint8_t* data) {
		memcpy(idl_CommKinectImage.rgb_data.get_buffer(), data, get_color_image_size() * sizeof(uint8_t) * 3);
	    idl_CommKinectImage.is_valid = true;
	}

	inline void set_rgb_image(const std::vector<uint8_t> &data) {
		for (uint32_t i = 0; i < idl_CommKinectImage.rgb_data.length(); i++) {
			idl_CommKinectImage.rgb_data[i] = data[i];
		}

	    idl_CommKinectImage.is_valid = true;
	}

	/**
	 * Returns a pointer to the first element of the coordinate image.
	 * The image has the size return from get_image_size().
	 */
	inline const float* get_distances() const {
		//return reinterpret_cast<const float*> (shm) + (sizeof(KinectImageParameters) + get_color_image_size()) / sizeof(float);
		return idl_CommKinectImage.distance_data.get_buffer();
	}

	inline void set_distances(const float* data) {
		memcpy(idl_CommKinectImage.distance_data.get_buffer(), data, get_distance_image_size() * sizeof(float));
	    idl_CommKinectImage.is_valid = true;
	}

	inline void set_distances(const std::vector<float> &data) {
		for (uint32_t i = 0; i < idl_CommKinectImage.distance_data.length(); i++) {
			idl_CommKinectImage.distance_data[i] = data[i];
		}

	    idl_CommKinectImage.is_valid = true;
	}

	/**
	 * Get the Cartesian 3d point in the sensor coordinate system.
	 */
	inline void get_cartesian_point_sensor(const uint32_t posX, const uint32_t posY, double& x, double& y, double& z,
			const double unit = 0.001) {

		if (color_inv_intrinsic_mat.n_elem == 0) {
			color_inv_intrinsic_mat = arma::inv(get_distance_intrinsic());
		}

		// get pointer to source position
		const float dist = *(get_distances() + (posY * get_width()) + posX);

		arma::vec q(4);
		q(0) = posX;
		q(1) = posY;
		q(2) = 1;
		q(3) = 1;

		q = color_inv_intrinsic_mat * q;

		arma::vec point(3);
		point(0) = q(0);
		point(1) = q(1);
		point(2) = q(2);

		point = (point / arma::norm(point, 2)) * dist;

		x = point(0) / unit;
		y = point(1) / unit;
		z = point(2) / unit;
	}

	/**
	 * Get the Cartesian 3d point in the robot coordinate system.
	 */
	inline void get_cartesian_point_robot(const uint32_t posX, const uint32_t posY, double& x, double& y, double& z,
			const double unit = 0.001) {

		if (robot_mat.n_elem == 0) {
			robot_mat = get_sensor_pose().getHomogeneousMatrix(1);
		}

		arma::vec q(4);
		get_cartesian_point_sensor(posX, posY, q(0), q(1), q(2), 1);
		q(3) = 1;

		arma::vec point = robot_mat * q;

		x = point(0) / unit;
		y = point(1) / unit;
		z = point(2) / unit;
	}

	/**
	 * Get the Cartesian 3d point in the world coordinate system.
	 */
	inline void get_cartesian_point_world(const uint32_t posX, const uint32_t posY, double& x, double& y, double& z,
			const double unit = 0.001) {

		if (world_mat.n_elem == 0) {
			arma::mat pose_robot = get_base_state().get_base_position().get_base_pose3d().getHomogeneousMatrix(1);
			arma::mat pose = get_sensor_pose().getHomogeneousMatrix(1);

			world_mat = pose_robot * pose;
		}

		arma::vec q(4);
		get_cartesian_point_sensor(posX, posY, q(0), q(1), q(2), 1);
		q(3) = 1;

		arma::vec point = world_mat * q;

		x = point(0) / unit;
		y = point(1) / unit;
		z = point(2) / unit;
	}

	/**
	 *  Get the spherical coordinate of a 3d point in the sensor coordinate system.
	 */
	inline void get_spherical_point_sensor(const uint32_t posX, const uint32_t posY, double &radius, double &phi,
			double &theta, const double unit = 0.001) {

		double x, y, z;
		get_cartesian_point_sensor(posX, posY, x, y, z, unit);

		// calculate the spherical coordinates
		radius = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
		phi = atan2(y, x);
		theta = acos(z / radius);

	}

	/**
	 *  Get the spherical coordinate of a 3d point in the robot coordinate system.
	 */
	inline void get_spherical_point_robot(const uint32_t posX, const uint32_t posY, double &radius, double &phi,
			double &theta, const double unit = 0.001) {

		double x, y, z;
		get_cartesian_point_robot(posX, posY, x, y, z, unit);

		// calculate the spherical coordinates
		radius = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
		phi = atan2(y, x);
		theta = acos(z / radius);

	}

	/**
	 *  Get the spherical coordinate of a 3d point in the world coordinate system.
	 */
	inline void get_spherical_point_world(const uint32_t posX, const uint32_t posY, double &radius, double &phi,
			double &theta, const double unit = 0.001) {

		double x, y, z;
		get_cartesian_point_world(posX, posY, x, y, z, unit);

		// calculate the spherical coordinates
		radius = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
		phi = atan2(y, x);
		theta = acos(z / radius);

	}

	/**
	 * Set the pose of the sensor relative to the robot coordinate system.
	 */
	inline void set_sensor_pose(const CommBasicObjects::CommPose3d& pose) {
		//reinterpret_cast<KinectImageParameters*> (shm)->sensor_pose.set_idl(pose.get_idl());

	}

	/**
	 * Set the state of the base.
	 */
	inline void set_base_state(const CommBasicObjects::CommBaseState& state) {
		//reinterpret_cast<KinectImageParameters*> (shm)->base_state.set_idl(state.get_idl());
		idl_CommKinectImage.base_state = state.get_idl();
	}

	/**
	 * Set the minimal distance the sensor works.
	 */
	inline void set_min_distance(const double_t value, const double_t unit = 0.001) {
		//reinterpret_cast<KinectImageParameters*> (shm)->min_distance = value * unit * 1000;
		idl_CommKinectImage.min_distance = value * unit * 1000;
	}

	/**
	 * Set the maximal distance the sensor works.
	 */
	inline void set_max_distance(const double_t value, const double_t unit = 0.001) {
		//reinterpret_cast<KinectImageParameters*> (shm)->max_distance = value * unit * 1000;
		idl_CommKinectImage.max_distance = value * unit * 1000;
	}

	/**
	 * Set the opening angle of the camera in x-axis [rad].
	 * It is expected that the opening angle in positive and negative direction is the same.
	 */
	inline void set_opening_angle_x_axis(const double_t value) {
		//reinterpret_cast<KinectImageParameters*> (shm)->opening_angle_x_axis = value;
		idl_CommKinectImage.opening_angle_x_axis = value;
	}

	/**
	 * Set the opening angle of the camera in y-axis [rad].
	 * It is expected that the opening angle in positive and negative direction is the same.
	 */
	inline void set_opening_angle_y_axis(const double_t value) {
		//reinterpret_cast<KinectImageParameters*> (shm)->opening_angle_y_axis = value;
		idl_CommKinectImage.opening_angle_y_axis = value;
	}

	/**
	 * Get the intrinsic matrix of the color camera.
	 */
	inline void set_color_intrinsic(const arma::mat& mat) {

		if (mat.n_cols != 4 && mat.n_rows != 4) {
			return;
		}

		arma::mat m(4, 4);
		for (size_t i = 0; i < 4; ++i) {
			for (size_t j = 0; j < 4; j++) {
				//reinterpret_cast<KinectImageParameters*> (shm)->color_intinsic[i][j] = mat(i, j);
				idl_CommKinectImage.color_intrinsic_m[i*4 + j] = mat(i, j);
			}
		}
	}

	/**
	 * Get the intrinsic matrix of the distance camera.
	 */
	inline void set_distance_intrinsic(const arma::mat& mat) {

		if (mat.n_cols != 4 && mat.n_rows != 4) {
			return;
		}

		arma::mat m(4, 4);
		for (size_t i = 0; i < 4; ++i) {
			for (size_t j = 0; j < 4; j++) {
				//reinterpret_cast<KinectImageParameters*> (shm)->dist_intinsic[i][j] = mat(i, j);
				idl_CommKinectImage.dist_intrinsic_m[i*4 + j] = mat(i, j);
			}
		}

	}

	/**
	 * Get the extrinsic matrix between the cameras.
	 */
	inline void set_camera_extrinsic(const arma::mat& mat) {

		if (mat.n_cols != 4 && mat.n_rows != 4) {
			return;
		}

		arma::mat m(4, 4);
		for (size_t i = 0; i < 4; ++i) {
			for (size_t j = 0; j < 4; j++) {
				//reinterpret_cast<KinectImageParameters*> (shm)->camera_extrinsic[i][j] = mat(i, j);
				idl_CommKinectImage.camera_extrinsic_m[i*4 + j] = mat(i, j);
			}
		}

	}

	/**
	 * Set the valid flag of the data.
	 * The flag is automatically set to true if data is written to the image.
	 * Thus the server either writes data to the image or sets the valid.
	 */
	void set_data_valid(bool value) {
//		if (shm != 0) {
//			reinterpret_cast<KinectImageParameters*> (shm)->data_valid = value;
//		}
		idl_CommKinectImage.is_valid = value;
	}

	/**
	 * Set the sequence counter of the image.
	 */
	void set_sequence_counter(ulong n) {
//		if (shm != 0) {
//			reinterpret_cast<KinectImageParameters*> (shm)->seq_count = n;
//		}
		idl_CommKinectImage.seq_count = n;
	}





	/**
	 * Copy data from the memory chunk at \a data to the internal shared memory.
	 * The number of bytes to copy is derived from the internal format and size descriptions.
	 */
//	void set_data(const void* data) {
//		if (shm != 0 && data != 0) {
//			memcpy(shm, data, get_size());
//		}
//	}


	/**
	 Set the parameters of an image.
	 This causes currently attached shared memory to be detached, and a new shared memory segment
	 to be allocated.
	 */
	void set_parameters(const uint32_t width, const uint32_t height) {
		//const uint32_t color_size = 3 * (width * height * sizeof(uint8_t)); // size in bytes
		//const uint32_t distance_size = (width * height * sizeof(float_t)); // size in bytes
		const uint32_t color_size = 3 * (width * height);
		const uint32_t distance_size = (width * height);

		//uint32_t allocSize = sizeof(KinectImageParameters) + color_size + distance_size;

		//KinectImageParameters *p = reinterpret_cast<KinectImageParameters*> (shm);
		idl_CommKinectImage.dist_intrinsic_m.length(4*4);
		idl_CommKinectImage.color_intrinsic_m.length(4*4);
		idl_CommKinectImage.camera_extrinsic_m.length(4*4);

		idl_CommKinectImage.distance_data.length(distance_size);
		idl_CommKinectImage.rgb_data.length(color_size);

		idl_CommKinectImage.parameter.width = width;
		idl_CommKinectImage.parameter.height = height;
		idl_CommKinectImage.parameter.color_image_size = color_size;
		idl_CommKinectImage.parameter.distance_image_size = distance_size;
		//idl_CommKinectImage.parameter.size = 0;

		idl_CommKinectImage.min_distance = 0;
		idl_CommKinectImage.max_distance = 0;
		idl_CommKinectImage.opening_angle_x_axis = 0;
		idl_CommKinectImage.opening_angle_y_axis = 0;
		idl_CommKinectImage.is_valid = false;
		idl_CommKinectImage.seq_count = 0;

		arma::mat zero(4,4);
		zero.zeros();

		set_camera_extrinsic(zero);
		set_color_intrinsic(zero);
		set_distance_intrinsic(zero);

	}





};

}
#endif
