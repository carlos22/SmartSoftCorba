//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.0
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include "commKinectImage.hh"

using namespace CommVisionObjects;

void CommKinectImage::get(CORBA::Any &a) const
{
	a <<= idl_CommKinectImage;
}

void CommKinectImage::set(const CORBA::Any &a)
{
	CommVisionObjectsIDL::CommKinectImage *tmp_cmd;
	if (a >>= tmp_cmd)
	{
		idl_CommKinectImage = *tmp_cmd;
	}
}

void CommKinectImage::save_xml(std::ostream &os, const std::string &indent)
{
	os << indent << "<kinect_image>" << std::endl;

	get_sensor_pose().save_xml(os, "  ");
	get_base_state().save_xml(os, "  ");

	os << indent << "  <rgb_width>" << get_rgb_width() << "</rgb_width>" << std::endl;
	os << indent << "  <rgb_height>" << get_rgb_height() << "</rgb_height>" << std::endl;
	os << indent << "  <distance_width>" << get_distance_width() << "</distance_width>" << std::endl;
	os << indent << "  <distance_height>" << get_distance_height() << "</distance_height>" << std::endl;

	os << indent << "  <min_distance>" << get_min_distance() << "</min_distance>" << std::endl;
	os << indent << "  <max_distance>" << get_max_distance() << "</max_distance>" << std::endl;

	os << indent << "  <color_intrinsic>";
	get_color_intrinsic().save(os);
	os << "</color_intrinsic>" << std::endl;

	os << indent << "  <distance_intrinsic>";
	get_distance_intrinsic().save(os);
	os << "</distance_intrinsic>" << std::endl;

	os << indent << "  <camera_extrinsic>";
	get_camera_extrinsic().save(os);
	os << "</camera_extrinsic>" << std::endl;

	os << indent << "  <valid>" << (int) is_data_valid() << "</valid>" << std::endl;
	os << indent << "  <sequence_count>" << get_sequence_counter() << "</sequence_count>" << std::endl;

	os << indent << "  <rgb_image>";
	os.write(reinterpret_cast<const char *> (get_rgb_image()), get_rgb_width() * get_rgb_height() * sizeof(uint8_t) * 3);
	os << "</rgb_image>" << std::endl;

	os << indent << "  <distance_image>";
	os.write(reinterpret_cast<const char *> (get_distances()), get_distance_width() * get_distance_height() * sizeof(float));
	os << "</distance_image>" << std::endl;

	os << indent << "</kinect_image>" << std::endl;
}

void CommKinectImage::load_xml(std::istream &is)
{
	static const Smart::KnuthMorrisPratt kmp_begin("<kinect_image>");

	static const Smart::KnuthMorrisPratt kmp_rgb_width("<rgb_width>");
	static const Smart::KnuthMorrisPratt kmp_rgb_height("<rgb_height>");
	static const Smart::KnuthMorrisPratt kmp_distance_width("<distance_width>");
	static const Smart::KnuthMorrisPratt kmp_distance_height("<distance_height>");

	static const Smart::KnuthMorrisPratt kmp_min_distance("<min_distance>");
	static const Smart::KnuthMorrisPratt kmp_max_distance("<max_distance>");

	static const Smart::KnuthMorrisPratt kmp_color_intrinsic("<color_intrinsic>");
	static const Smart::KnuthMorrisPratt kmp_distance_intrinsic("<distance_intrinsic>");
	static const Smart::KnuthMorrisPratt kmp_camera_extrinsic("<camera_extrinsic>");

	static const Smart::KnuthMorrisPratt kmp_valid("<valid>");
	static const Smart::KnuthMorrisPratt kmp_sequence_count("<sequence_count>");

	static const Smart::KnuthMorrisPratt kmp_rgb_image("<rgb_image>");
	static const Smart::KnuthMorrisPratt kmp_distance_image("<distance_image>");

	static const Smart::KnuthMorrisPratt kmp_end("</kinect_image>");

	uint32_t rgb_width, rgb_height;
	uint32_t distance_width, distance_height;

	kmp_begin.search(is);

	CommBasicObjects::CommPose3d sensor_pose;
	sensor_pose.load_xml(is);
	set_sensor_pose(sensor_pose);

	CommBasicObjects::CommBaseState base_state;
	base_state.load_xml(is);
	set_base_state(base_state);

	kmp_rgb_width.search(is);
	is >> rgb_width;
	kmp_rgb_height.search(is);
	is >> rgb_height;

	kmp_distance_width.search(is);
	is >> distance_width;
	kmp_distance_height.search(is);
	is >> distance_height;

	double value;
	kmp_min_distance.search(is);
	is >> value;
	set_min_distance(value);

	kmp_max_distance.search(is);
	is >> value;
	set_max_distance(value);

	arma::mat m;
	kmp_color_intrinsic.search(is);
	m.load(is);
	set_color_intrinsic(m);

	kmp_distance_intrinsic.search(is);
	m.load(is);
	set_distance_intrinsic(m);

	kmp_camera_extrinsic.search(is);
	m.load(is);
	set_camera_extrinsic(m);

	int b;
	kmp_valid.search(is);
	is >> b;
	set_data_valid(b);

	ulong l;
	kmp_sequence_count.search(is);
	is >> l;
	set_sequence_counter(l);

	kmp_rgb_image.search(is);
	uint8_t* rgb_data = new uint8_t[rgb_width * rgb_height * sizeof(uint8_t) * 3];
	is.read(reinterpret_cast<char *> (rgb_data), rgb_width * rgb_height * sizeof(uint8_t) * 3);
	set_rgb_image(rgb_data, rgb_width, rgb_height);
	delete rgb_data;

	kmp_distance_image.search(is);
	float* distance_data = new float[distance_width * distance_height];
	is.read(reinterpret_cast<char *> (distance_data), distance_width * distance_height * sizeof(float));
	set_distances(distance_data, distance_width, distance_height);
	delete distance_data;

	kmp_end.search(is);
}
